00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/4/2019 5:21:41 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Dissasembler
00000000                             3  * Written by :  Nick, Shelby, and Zoe
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7          ORG     $1000
00001000                             8          
00001000                             9  ****    MAIN LOOP   ****
00001000  4E71                      10  INIT:   NOP     * line for testing
00001002  4EB9 0000228A             11          JSR     RESET_BUF_PTR
00001008  43F9 00002505             12          LEA     WELCOME,A1      * print welcome message
0000100E  4EB9 00002214             13          JSR     WRITE_ASCII
00001014  4EB9 00002262             14          JSR     TERM_PNT_RST_BUF
0000101A                            15          
0000101A                            16  START:  
0000101A  4EB9 0000201E             17          JSR     GET_CHOICE      * get choice from user to dissasemble or quit
00001020  0C46 0002                 18          CMPI    #QUIT_PROG,D6
00001024  6700 0080                 19          BEQ     QUIT
00001028                            20          
00001028                            21  
00001028                            22  INPUT_START:
00001028  43F9 00002622             23          LEA     ST_A_MSG,A1     * load start address prompt message
0000102E  4EB9 00002214             24          JSR     WRITE_ASCII     * write to string buffer
00001034  4EB9 00002262             25          JSR     TERM_PNT_RST_BUF * terminate string buffer and print reseting pointer at A4
0000103A                            26          
0000103A  43F9 00002290             27          LEA     ST_ADDR,A1 * load start address
00001040  4291                      28          CLR.L   (A1)    * clear long at a1
00001042  103C 0002                 29          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001046  4E4F                      30          TRAP    #15
00001048  13C1 000022B0             31          MOVE.B  D1,ST_LEN    * save start length to memory 
0000104E                            32          
0000104E  4EB9 000020FA             33          JSR     IN_ADDR_TO_HEX  * convert start address to hex
00001054                            34               
00001054  43F9 000026A2             35          LEA     E_A_MSG,A1      * load end address prompt message
0000105A  4EB9 00002214             36          JSR     WRITE_ASCII     * print message
00001060  4EB9 00002262             37          JSR     TERM_PNT_RST_BUF  * print and reset buffer no newline
00001066                            38          
00001066  43F9 0000229C             39          LEA     E_ADDR,A1  * load end address
0000106C  4291                      40          CLR.L   (A1)    * clear long at end address
0000106E  103C 0002                 41          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001072  4E4F                      42          TRAP    #15
00001074  13C1 000022B1             43          MOVE.B  D1,E_LEN    * save end length to memory
0000107A                            44          
0000107A  4EB9 000020FA             45          JSR     IN_ADDR_TO_HEX  * convert end address to hex
00001080                            46          
00001080  4EB9 0000210A             47          JSR     CHK_ST_E_ADRS   * check addresses for errors
00001086  0C05 0001                 48          CMPI.B  #1,D5           * if an error occured return to start
0000108A  6600 000A                 49          BNE     ST_DIS          * branch to dissasembly if no errors
0000108E  4EB9 00002072             50          JSR     WAIT_USR_INPUT    
00001094  6092                      51          BRA     INPUT_START     * return to start
00001096                            52          
00001096                            53          * print converted addresses for testing purposes
00001096                            54          
00001096  4EB9 000010AC             55  ST_DIS  JSR     OP_CODES
0000109C                            56          
0000109C  4EB9 0000224C             57          JSR     NL_TERM_PNT_RST_BUF * print newline after op codes
000010A2                            58           
000010A2  6000 FF76                 59          BRA     START 
000010A6                            60  
000010A6                            61  
000010A6  103C 0009                 62  QUIT    MOVE.B  #9,D0
000010AA  4E4F                      63          TRAP    #15 * stop sim
000010AC                            64  
000010AC                            65  
000010AC                            66  ****    OP-CODES    ****
000010AC                            67  OP_CODES:
000010AC  4EB9 0000228A             68          JSR     RESET_BUF_PTR   * reset string buffer pointer
000010B2  2A79 00002290             69          MOVE.L  ST_ADDR,A5  * load starting address into a5
000010B8  2C79 0000229C             70          MOVE.L  E_ADDR,A6   * load ending address into a6
000010BE                            71          
000010BE                            72  OP_START:          
000010BE                            73          * write address and a tab to str buffer
000010BE  220D                      74          MOVE.L  A5,D1   * load address from A5 into D1
000010C0  23C1 000022AC             75          MOVE.L  D1,CURRENT_ADDR * save backup of opcode word address
000010C6  7A20                      76          MOVEQ   #32,D5   * set hex length to long for address printing
000010C8  4EB9 000021C2             77          JSR     WRITE_HEX_TO_ASCII
000010CE  4EB9 0000223E             78          JSR     WRITE_TAB_A4
000010D4                            79          
000010D4  3415                      80          MOVE.W (A5),D2 * load word of memory into D1
000010D6                            81  
000010D6                            82          * clear ea mode and register values
000010D6  13FC 0000 000023A8        83          MOVE.B #0,SRC_REG
000010DE  13FC 0000 000023A6        84          MOVE.B #0,DEST_REG
000010E6  13FC 0000 000023A7        85          MOVE.B #0,SRC_MODE
000010EE  13FC 0000 000023A5        86          MOVE.B #0,DEST_MODE
000010F6  23FC 00000000 000022A8    87          MOVE.L  #0,END_OP_CODE_PTR * clear end of op-code str buffer pointer
00001100  13FC 0000 000023A9        88          MOVE.B  #0,EA_ERR_FLAG * clear ea error flag
00001108                            89          
00001108                            90  CHK_LFT_NIB:
00001108  2602                      91          MOVE.L  D2,D3   * copy to d2
0000110A                            92          
0000110A  0243 F000                 93          ANDI.W  #Nib3Mask,D3 * clear all but left four bits
0000110E  0C43 1000                 94          CMPI.W  #$1000,D3   * if nibble3 == 1, branch to move byte (1)
00001112  6700 0082                 95          BEQ     load_MOVE_B
00001116  0C43 2000                 96          CMPI.W  #$2000,D3   * if nibble3 == 2, branch to that set (move.l, movea.l)
0000111A  6700 00AA                 97          BEQ     OP_2
0000111E  0C43 3000                 98          CMPI.W  #$3000,D3   * if nibble3 == 3, branch to that set (move.w, movea.w)
00001122  6700 0112                 99          BEQ     OP_3              
00001126  0C43 4000                100          CMPI.W  #$4000,D3   * if nibble3 == 4 branch to that set (not/nop/rts/jsr/movem/lea)
0000112A  6700 017A                101          BEQ     OP_4 
0000112E  0C43 5000                102          CMPI.W  #$5000,D3   * if nibble3 == 5, branch to ADDQ (5)
00001132  6700 0320                103          BEQ     ADDQ_
00001136  0C43 6000                104          CMPI.W  #$6000,D3   * if nibble3 == 6, branch to that set (bra, bcc)
0000113A  6700 03A2                105          BEQ     OP_6
0000113E  0C43 7000                106          CMPI.W  #$7000,D3   * if nibble3 == 7, branch to MOVEQ
00001142  6700 041E                107          BEQ     load_MOVEQ
00001146  0C43 8000                108          CMPI.W  #$8000,D3   * if nibble3 == 8, branch to that set (divu, or)
0000114A  6700 042C                109          BEQ     OP_8
0000114E  0C43 9000                110          CMPI.W  #$9000,D3   * if nibble3 == 9, branch to SUB
00001152  6700 047E                111          BEQ     load_SUB
00001156  0C43 C000                112          CMPI.W  #$C000,D3   * if nibble3 == C, branch to that set (muls, and)
0000115A  6700 0498                113          BEQ     OP_C
0000115E  0C43 D000                114          CMPI.W  #$D000,D3   * if nibble3 == D, branch to that set (add, adda)
00001162  6700 04E4                115          BEQ     OP_D
00001166  0C43 E000                116          CMPI.W  #$E000,D3   * if nibble3 == E, branch to that set (asl, asr, lsl, lsr)
0000116A  6700 053A                117          BEQ     OP_E
0000116E                           118                         
0000116E  4EB9 0000208C            119  OP_ERR  JSR     LOAD_DATA_STR_INTO_BUF   
00001174                           120  
00001174                           121  DECODE_DONE:    * print newline then check if op-code loop is done
00001174  4EB9 0000224C            122          JSR     NL_TERM_PNT_RST_BUF * write newline then print
0000117A  0C39 00FF 000023A9       123          CMP.B   #-1,EA_ERR_FLAG
00001182  6600 0008                124          BNE     NO_EA_ERROR
00001186  2A79 000022AC            125          MOVEA.L CURRENT_ADDR,A5 * reset curent address if ea error occurred
0000118C                           126   NO_EA_ERROR:
0000118C  548D                     127          ADD.L   #2,A5   * increment current address pointer by 2 bytes 
0000118E  BBCE                     128          CMP.L   A6,A5  * loop if start is less than or equal to end
00001190  6F00 FF2C                129          BLE     OP_START
00001194  4E75                     130  OP_DONE RTS
00001196                           131  
00001196                           132  load_MOVE_B:    * load and print MOVE.B neumonic return to op loop
00001196  43F9 000023DB            133          LEA     _MOVE_B,A1
0000119C  4EB9 00002214            134          JSR     WRITE_ASCII
000011A2  4EB9 00002244            135          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011A8  13FC 0001 000023A4       136          MOVE.B  #BYTE,INST_SZ   * save instruction size
000011B0  4243                     137          CLR     D3
000011B2  4EB9 0000196E            138          JSR     MOVE_EA
000011B8                           139          **** EA CODE GOES HERE ****
000011B8                           140          * must set unused mode/reg vars to 0
000011B8  4EB9 00001EA4            141          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000011BE  4EB9 00001F68            142          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000011C4  60AE                     143          BRA     DECODE_DONE
000011C6                           144         
000011C6                           145  OP_2:   * could be MOVE.L or MOVEA.L
000011C6  2602                     146          MOVE.L  D2,D3   * copy instruction word
000011C8  0243 01C0                147          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000011CC  0C43 0040                148          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.L
000011D0  6700 000A                149          BEQ     load_MOVEA_L
000011D4  0C43 0040                150          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.L
000011D8  6600 002C                151          BNE     load_MOVE_L
000011DC                           152          
000011DC                           153  load_MOVEA_L:   * load and print MOVEA.L neumonic return to op loop
000011DC  43F9 000023F3            154          LEA     _MOVEA_L,A1
000011E2  4EB9 00002214            155          JSR     WRITE_ASCII
000011E8  4EB9 00002244            156          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011EE  13FC 0002 000023A4       157          MOVE.B  #LONG,INST_SZ   * save instruction size
000011F6                           158           **** EA CODE GOES HERE ****
000011F6  4EB9 0000196E            159          JSR     MOVE_EA
000011FC                           160          * must set unused mode/reg vars to 0
000011FC  4EB9 00001EA4            161          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001202  6000 FF70                162          BRA     DECODE_DONE
00001206                           163  
00001206                           164  load_MOVE_L:    * load and print MOVE.L neumonic return to op loop
00001206  43F9 000023E3            165          LEA     _MOVE_L,A1
0000120C  4EB9 00002214            166          JSR     WRITE_ASCII
00001212  4EB9 00002244            167          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001218  13FC 0002 000023A4       168          MOVE.B  #LONG,INST_SZ   * save instruction size
00001220  4EB9 0000196E            169          JSR     MOVE_EA
00001226  4EB9 00001EA4            170          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000122C  4EB9 00001F68            171          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001232  6000 FF40                172          BRA     DECODE_DONE
00001236                           173          
00001236                           174  OP_3:   * could be MOVE.W or MOVEA.W
00001236  2602                     175          MOVE.L  D2,D3   * copy instruction word
00001238  0243 01C0                176          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
0000123C  0C43 0040                177          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.W
00001240  6700 000A                178          BEQ     load_MOVEA_W
00001244  0C43 0040                179          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.W
00001248  6600 002C                180          BNE     load_MOVE_W
0000124C                           181          
0000124C                           182  load_MOVEA_W:   * load and print MOVEA.W neumonic return to op loop
0000124C  43F9 000023FC            183          LEA     _MOVEA_W,A1
00001252  4EB9 00002214            184          JSR     WRITE_ASCII
00001258  4EB9 00002244            185          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000125E  13FC 0003 000023A4       186          MOVE.B  #WORD,INST_SZ   * save instruction size
00001266                           187           **** EA CODE GOES HERE ****
00001266  4EB9 0000196E            188          JSR     MOVE_EA
0000126C                           189          * must set unused mode/reg vars to 0
0000126C  4EB9 00001EA4            190          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001272  6000 FF00                191          BRA     DECODE_DONE
00001276                           192  
00001276                           193  load_MOVE_W:    * load and print MOVE.W neumonic return to op loop
00001276  43F9 000023EB            194          LEA     _MOVE_W,A1
0000127C  4EB9 00002214            195          JSR     WRITE_ASCII
00001282  4EB9 00002244            196          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001288  13FC 0003 000023A4       197          MOVE.B  #WORD,INST_SZ   * save instruction size
00001290  4EB9 0000196E            198          JSR     MOVE_EA
00001296  4EB9 00001EA4            199          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000129C  4EB9 00001F68            200          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000012A2  6000 FED0                201          BRA     DECODE_DONE
000012A6                           202  
000012A6                           203  OP_4:   * could be not, nop, rts, jsr, MOVEM.L, lea
000012A6  2602                     204          MOVE.L  D2,D3   * copy instruction word
000012A8  0243 0F00                205          ANDI.W  #Nib2Mask,D3
000012AC  0C43 0600                206          CMPI.W  #$0600,D3   * if nibble 2 is 6, instruction is NOT
000012B0  6700 0032                207          BEQ     NOT_
000012B4                           208  
000012B4  0C43 0E00                209          CMPI.W  #$0E00,D3  * if nibble 2 is E could be nop or rts or jsr
000012B8  6700 00C6                210          BEQ     NOP_RTS_JSR
000012BC                           211          
000012BC                           212          * try for LEA
000012BC  2602                     213          MOVE.L  D2,D3
000012BE  0243 01C0                214          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012C2  0C43 01C0                215          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LEA
000012C6  6700 010C                216          BEQ     load_LEA
000012CA                           217          
000012CA                           218          * try for MOVEM.W or MOVEM.L
000012CA  2602                     219          MOVE.L  D2,D3
000012CC  0243 01C0                220          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 for size
000012D0  0C43 0080                221          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is MOVEM.W
000012D4  6700 0136                222          BEQ     load_MOVEM_W
000012D8  0C43 00C0                223          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is MOVEM.L
000012DC  6700 0152                224          BEQ     load_MOVEM_L
000012E0                           225  
000012E0                           226          
000012E0  6000 FE8C                227          BRA     OP_ERR  * return to error decoding
000012E4                           228          
000012E4                           229  NOT_:   * instruction is not, determine size
000012E4  2602                     230          MOVE.L  D2,D3
000012E6  0243 01C0                231          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012EA  0C43 0000                232          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is NOT.B
000012EE  6700 0012                233          BEQ     load_NOT_B
000012F2  0C43 0040                234          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is NOT.W
000012F6  6700 0034                235          BEQ     load_NOT_W
000012FA  0C43 0080                236          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is NOT.L
000012FE  6700 0056                237          BEQ     load_NOT_L
00001302                           238           
00001302                           239         
00001302                           240  load_NOT_B:   * load and print NOT.B neumonic return to op loop
00001302  43F9 000023AA            241          LEA     _NOT_B,A1
00001308  4EB9 00002214            242          JSR     WRITE_ASCII
0000130E  4EB9 00002244            243          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001314  13FC 0001 000023A4       244          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000131C                           245           **** EA CODE GOES HERE ****
0000131C                           246          * must set unused mode/reg vars to 0
0000131C  4EB9 00001EA4            247          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001322  4EB9 00001F68            248          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001328  6000 FE4A                249          BRA     DECODE_DONE
0000132C                           250          
0000132C                           251  load_NOT_W:   * load and print NOT.W neumonic return to op loop
0000132C  43F9 000023B1            252          LEA     _NOT_W,A1
00001332  4EB9 00002214            253          JSR     WRITE_ASCII
00001338  4EB9 00002244            254          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000133E  13FC 0003 000023A4       255          MOVE.B  #WORD,INST_SZ   * save instruction size
00001346                           256           **** EA CODE GOES HERE ****
00001346                           257          * must set unused mode/reg vars to 0
00001346  4EB9 00001EA4            258          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000134C  4EB9 00001F68            259          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001352  6000 FE20                260          BRA     DECODE_DONE
00001356                           261          
00001356                           262  load_NOT_L:   * load and print NOT.L neumonic return to op loop
00001356  43F9 000023B8            263          LEA     _NOT_L,A1
0000135C  4EB9 00002214            264          JSR     WRITE_ASCII
00001362  4EB9 00002244            265          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001368  13FC 0002 000023A4       266          MOVE.B  #LONG,INST_SZ   * save instruction size
00001370                           267           **** EA CODE GOES HERE ****
00001370                           268          * must set unused mode/reg vars to 0
00001370  4EB9 00001EA4            269          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001376  4EB9 00001F68            270          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
0000137C  6000 FDF6                271          BRA     DECODE_DONE
00001380                           272  
00001380                           273  NOP_RTS_JSR: * could be NOP or RTS or JSR
00001380  2602                     274          MOVE.L  D2,D3
00001382  0243 01C0                275          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001386  0C43 0080                276          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is JSR
0000138A  6700 006A                277          BEQ     load_JSR
0000138E                           278      
0000138E  2602                     279          MOVE.L  D2,D3       *copy instruction word
00001390  0243 00FF                280          ANDI.W  #Byte0Mask,D3 * isolate right most byte
00001394                           281          
00001394  0C03 0071                282          CMPI.B  #$71,D3     * test for NOP
00001398  6700 000E                283          BEQ     load_NOP
0000139C  0C03 0075                284          CMPI.B  #$75, D3    * test for RTS
000013A0  6700 001C                285          BEQ     load_RTS
000013A4                           286              
000013A4  6000 FDC8                287          BRA     OP_ERR  * return to error decoding
000013A8                           288  
000013A8                           289  load_NOP:   * load and print NOP neumonic return to op loop
000013A8  43F9 000023BF            290          LEA     _NOP,A1
000013AE  4EB9 00002214            291          JSR     WRITE_ASCII
000013B4  4EB9 00002244            292          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013BA  6000 FDB8                293          BRA     DECODE_DONE
000013BE                           294          
000013BE                           295  load_RTS:   * load and print RTS neumonic return to op loop
000013BE  43F9 000023C4            296          LEA     _RTS,A1
000013C4  4EB9 00002214            297          JSR     WRITE_ASCII
000013CA  4EB9 00002244            298          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013D0  6000 FDA2                299          BRA     DECODE_DONE
000013D4                           300          
000013D4                           301  load_LEA:   * load and print LEA neumonic return to op loop
000013D4  43F9 0000240A            302          LEA     _LEA,A1
000013DA  4EB9 00002214            303          JSR     WRITE_ASCII
000013E0  4EB9 00002244            304          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013E6                           305           **** EA CODE GOES HERE ****
000013E6  4EB9 000019DE            306           JSR    LEA_EA
000013EC                           307          * must set unused mode/reg vars to 0
000013EC  4EB9 00001EA4            308          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000013F2  6000 FD80                309          BRA     DECODE_DONE
000013F6                           310          
000013F6                           311  load_JSR:   * load and print JSR neumonic return to op loop
000013F6  43F9 00002405            312          LEA     _JSR,A1
000013FC  4EB9 00002214            313          JSR     WRITE_ASCII
00001402  4EB9 00002244            314          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001408  6000 FD6A                315          BRA     DECODE_DONE
0000140C                           316          
0000140C                           317  load_MOVEM_W:   * load and print MOVEM.W neumonic return to op loop
0000140C  43F9 000023C9            318          LEA     _MOVEM_W,A1
00001412  4EB9 00002214            319          JSR     WRITE_ASCII
00001418  4EB9 00002244            320          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000141E  13FC 0003 000023A4       321      MOVE.B  #WORD,INST_SZ   * save instruction size
00001426                           322           **** EA CODE GOES HERE ****
00001426                           323          * must set unused mode/reg vars to 0
00001426  4EB9 00001EA4            324          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000142C  6000 FD46                325          BRA     DECODE_DONE
00001430                           326          
00001430                           327  load_MOVEM_L:   * load and print MOVEM.L neumonic return to op loop
00001430  43F9 000023D2            328          LEA     _MOVEM_L,A1
00001436  4EB9 00002214            329          JSR     WRITE_ASCII
0000143C  4EB9 00002244            330          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001442  13FC 0002 000023A4       331          MOVE.B  #LONG,INST_SZ   * save instruction size
0000144A                           332           **** EA CODE GOES HERE ****
0000144A                           333          * must set unused mode/reg vars to 0
0000144A  4EB9 00001EA4            334          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001450  6000 FD22                335          BRA     DECODE_DONE
00001454                           336  
00001454                           337  ADDQ_:  * instruction is addq, determine size
00001454  2602                     338          MOVE.L  D2,D3
00001456  0243 01C0                339          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
0000145A  0C43 0000                340          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ADDQ.B
0000145E  6700 0012                341          BEQ     load_ADDQ_B
00001462  0C43 0040                342          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ADDQ.W
00001466  6700 002E                343          BEQ     load_ADDQ_W
0000146A  0C43 0080                344          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ADDQ.L
0000146E  6700 004A                345          BEQ     load_ADDQ_L           
00001472                           346  
00001472                           347  load_ADDQ_B:  * load and print ADDQ.B neumonic return to op loop
00001472  43F9 0000240F            348          LEA     _ADDQ_B,A1
00001478  4EB9 00002214            349          JSR     WRITE_ASCII
0000147E  4EB9 00002244            350          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001484  13FC 0001 000023A4       351          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000148C                           352           **** EA CODE GOES HERE ****
0000148C                           353          * must set unused mode/reg vars to 0
0000148C  4EB9 00001EA4            354          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001492  6000 FCE0                355          BRA     DECODE_DONE
00001496                           356        
00001496                           357  load_ADDQ_W:  * load and print ADDQ.W neumonic return to op loop
00001496  43F9 00002417            358          LEA     _ADDQ_W,A1
0000149C  4EB9 00002214            359          JSR     WRITE_ASCII
000014A2  4EB9 00002244            360          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014A8  13FC 0003 000023A4       361          MOVE.B  #WORD,INST_SZ   * save instruction size
000014B0                           362           **** EA CODE GOES HERE ****
000014B0                           363          * must set unused mode/reg vars to 0
000014B0  4EB9 00001EA4            364          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014B6  6000 FCBC                365          BRA     DECODE_DONE
000014BA                           366          
000014BA                           367  load_ADDQ_L:  * load and print ADDQ.L neumonic return to op loop
000014BA  43F9 0000241F            368          LEA     _ADDQ_L,A1
000014C0  4EB9 00002214            369          JSR     WRITE_ASCII
000014C6  4EB9 00002244            370          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014CC  13FC 0002 000023A4       371          MOVE.B  #LONG,INST_SZ
000014D4                           372           **** EA CODE GOES HERE ****
000014D4                           373          * must set unused mode/reg vars to 0
000014D4  4EB9 00001EA4            374          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014DA  6000 FC98                375          BRA     DECODE_DONE
000014DE                           376          
000014DE                           377  OP_6:   * could be BRA, BEQ, BGT, BLE
000014DE  2602                     378          MOVE.L  D2,D3   * copy instruction word
000014E0  0243 0F00                379          ANDI.W  #Nib2Mask,D3
000014E4  0C43 0000                380          CMPI.W  #$0000,D3   * if nibble 2 is 0, instruction is BRA
000014E8  6700 001A                381          BEQ     load_BRA
000014EC  0C43 0700                382          CMPI.W  #$0700,D3   * if nibble 2 is 7, instruction is BEQ
000014F0  6700 0028                383          BEQ     load_BEQ
000014F4  0C43 0E00                384          CMPI.W  #$0E00,D3   * if nibble 2 is E, instruction is BGT
000014F8  6700 003C                385          BEQ     load_BGT
000014FC  0C43 0F00                386          CMPI.W  #$0F00,D3   * if nibble 2 is F, instruction is BLE
00001500  6700 004A                387          BEQ     load_BLE
00001504                           388          
00001504                           389  load_BRA:   * load and print BRA neumonic return to op loop
00001504  43F9 00002427            390          LEA     _BRA,A1
0000150A  4EB9 00002214            391          JSR     WRITE_ASCII
00001510  4EB9 00002244            392          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001516  6000 FC5C                393          BRA     DECODE_DONE
0000151A                           394          
0000151A                           395  load_BEQ:   * load and print BEQ neumonic return to op loop
0000151A  43F9 0000242C            396          LEA     _BEQ,A1
00001520  4EB9 00002214            397          JSR     WRITE_ASCII
00001526  4EB9 00001FF0            398          JSR     NEXT_MEM_WORD_TO_BUF
0000152C  4EB9 00002244            399          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001532  6000 FC40                400          BRA     DECODE_DONE
00001536                           401  
00001536                           402  load_BGT:   * load and print BGT neumonic return to op loop
00001536  43F9 00002431            403          LEA     _BGT,A1
0000153C  4EB9 00002214            404          JSR     WRITE_ASCII
00001542  4EB9 00002244            405          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001548  6000 FC2A                406          BRA     DECODE_DONE
0000154C                           407          
0000154C                           408  load_BLE:   * load and print BLE neumonic return to op loop
0000154C  43F9 00002436            409          LEA     _BLE,A1
00001552  4EB9 00002214            410          JSR     WRITE_ASCII
00001558  4EB9 00002244            411          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000155E  6000 FC14                412          BRA     DECODE_DONE
00001562                           413          
00001562                           414  load_MOVEQ: * load and print MOVEQ neumonic return to op loop
00001562  43F9 0000243B            415          LEA     _MOVEQ,A1
00001568  4EB9 00002214            416          JSR     WRITE_ASCII
0000156E  4EB9 00002244            417          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001574  6000 FBFE                418          BRA     DECODE_DONE
00001578                           419          
00001578                           420  OP_8:       * could be DIVU or OR
00001578  2602                     421          MOVE.L  D2,D3       * copy instruction word
0000157A  0243 01C0                422          ANDI.W  #Bit1Mask,D3   * mask, isolate distinguishing bits 8-6
0000157E  0C43 00C0                423          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is DIVU
00001582  6700 000A                424          BEQ     load_DIVU
00001586  0C43 00C0                425          CMPI.W  #$00C0,D3       * if bits 8-6 are NOT 011, instruction is OR
0000158A  6600 0024                426          BNE     load_OR
0000158E                           427  
0000158E                           428  load_DIVU:  * load and print DIVU neumonic return to op loop
0000158E  43F9 00002442            429          LEA     _DIVU,A1
00001594  4EB9 00002214            430          JSR     WRITE_ASCII
0000159A  4EB9 00002244            431          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015A0                           432           **** EA CODE GOES HERE ****
000015A0  4EB9 00001A44            433          JSR     DIVU_EA
000015A6                           434          * must set unused mode/reg vars to 0
000015A6  4EB9 00001EA4            435          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015AC  6000 FBC6                436          BRA     DECODE_DONE
000015B0                           437          
000015B0                           438  load_OR:    * load and print DIVU neuomnic return to op loop
000015B0  43F9 00002448            439          LEA     _OR,A1
000015B6  4EB9 00002214            440          JSR     WRITE_ASCII
000015BC  4EB9 00002244            441          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015C2                           442           **** EA CODE GOES HERE ****
000015C2  4EB9 00001AAE            443          JSR     OPMODE_EA
000015C8                           444          * must set unused mode/reg vars to 0
000015C8  4EB9 00001EA4            445          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015CE  6000 FBA4                446          BRA     DECODE_DONE
000015D2                           447  
000015D2                           448  load_SUB:   * load and print SUB neumonic return to op loop
000015D2  43F9 00002457            449          LEA     _SUB,A1
000015D8  4EB9 00002214            450          JSR     WRITE_ASCII
000015DE  4EB9 00002244            451          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015E4                           452           **** EA CODE GOES HERE ****
000015E4  4EB9 00001AAE            453          JSR     OPMODE_EA
000015EA                           454  
000015EA                           455          * must set unused mode/reg vars to 0
000015EA  4EB9 00001EA4            456          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015F0  6000 FB82                457          BRA     DECODE_DONE
000015F4                           458  
000015F4                           459  OP_C:       * could be MULS or AND
000015F4  2602                     460          MOVE.L  D2,D3       * copy instruction word
000015F6  0243 01C0                461          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000015FA  0C43 01C0                462          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is MULS
000015FE  6700 000A                463          BEQ     load_MULS
00001602  0C43 01C0                464          CMPI.W  #$01C0,D3       * if bits 8-6 are NOT 111, instruction is AND
00001606  6600 001E                465          BNE     load_AND
0000160A                           466          
0000160A                           467  load_MULS:  * load and print MULS neumonic return to op loop
0000160A  43F9 0000245C            468          LEA     _MULS,A1
00001610  4EB9 00002214            469          JSR     WRITE_ASCII
00001616  4EB9 00002244            470          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000161C                           471           **** EA CODE GOES HERE ****
0000161C                           472          * must set unused mode/reg vars to 0
0000161C  4EB9 00001EA4            473          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001622  6000 FB50                474          BRA     DECODE_DONE
00001626                           475          
00001626                           476  load_AND:   * load and print AND neumonic return to op loop
00001626  43F9 00002462            477          LEA     _AND,A1
0000162C  4EB9 00002214            478          JSR     WRITE_ASCII
00001632  4EB9 00002244            479          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001638                           480           **** EA CODE GOES HERE ****
00001638  4EB9 00001AAE            481          JSR     OPMODE_EA
0000163E                           482          * must set unused mode/reg vars to 0
0000163E  4EB9 00001EA4            483          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001644  6000 FB2E                484          BRA     DECODE_DONE
00001648                           485  
00001648                           486  OP_D:       * could be ADD or ADDA
00001648  2602                     487          MOVE.L  D2,D3       * copy instruction word
0000164A  0243 01C0                488          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 (opmode but distinguishes instr.)
0000164E  0C43 00C0                489          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ADDA
00001652  6700 000E                490          BEQ     load_ADDA
00001656  0C43 01C0                491          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is also ADDA
0000165A  6700 0006                492          BEQ     load_ADDA
0000165E  6600 0024                493          BNE     load_ADD        * if bits 8-6 are not either, instruction is ADD
00001662                           494          
00001662                           495  load_ADDA:  * load and print ADDA neumonic return to op loop
00001662  43F9 0000246C            496          LEA     _ADDA,A1
00001668  4EB9 00002214            497          JSR     WRITE_ASCII
0000166E  4EB9 00002244            498          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001674                           499           **** EA CODE GOES HERE ****
00001674  4EB9 00001AAE            500          JSR     OPMODE_EA
0000167A                           501          * must set unused mode/reg vars to 0
0000167A  4EB9 00001EA4            502          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001680  6000 FAF2                503          BRA     DECODE_DONE
00001684                           504  
00001684                           505  load_ADD:   * load and print ADD neumonic return to op loop
00001684  43F9 00002467            506          LEA     _ADD,A1
0000168A  4EB9 00002214            507          JSR     WRITE_ASCII
00001690  4EB9 00002244            508          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001696                           509           **** EA CODE GOES HERE ****
00001696  4EB9 00001AAE            510          JSR     OPMODE_EA
0000169C                           511          * must set unused mode/reg vars to 0
0000169C  4EB9 00001EA4            512          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000016A2  6000 FAD0                513          BRA     DECODE_DONE
000016A6                           514  
000016A6                           515  OP_E:       * could be ASL, ASR, LSL, LSR (memory or register)
000016A6  2602                     516          MOVE.L  D2,D3       * copy instruction word
000016A8  0283 FFFF00FF            517          ANDI.L  #$FFFF00FF,D3   * mask, isolate bits 7-6
000016AE  0C43 00C0                518          CMPI.W  #$00C0,D3       * if bits 7-6 are 11, instruction is MEMORY shift
000016B2  6700 000A                519          BEQ     MEMORY_shift
000016B6  0C43 00C0                520          CMPI.W  #$00C0,D3       * if bits 7-6 are NOT 11, instruction is REG shift
000016BA  6600 00B4                521          BNE     REG_shift
000016BE                           522          
000016BE                           523  MEMORY_shift:   * could be ASL, ASR, LSL, LSR (memory)
000016BE  2602                     524          MOVE.L  D2,D3       * copy instruction word
000016C0  0243 0E00                525          ANDI.W  #Bit0Mask,D3    * mask, isolate bits 11-9
000016C4  0C43 0000                526          CMPI.W  #$0000,D3       * if bits 11-9 are 000, instruction is ASL or ASR (memory)
000016C8  6700 000A                527          BEQ     ASL_ASR_MEM
000016CC  0C43 0200                528          CMPI.W  #$0200,D3       * if bits 11-9 are 001, instruction is LSL or LSR (memory)
000016D0  6700 0050                529          BEQ     LSL_LSR_MEM
000016D4                           530          
000016D4                           531  ASL_ASR_MEM:    * could be ASL or ASR (memory)
000016D4  2602                     532          MOVE.L  D2,D3       * copy instruction word
000016D6  0243 01C0                533          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000016DA  0C43 00C0                534          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ASR memory
000016DE  6700 000A                535          BEQ     load_ASR_MEM
000016E2  0C43 01C0                536          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is ASL memory
000016E6  6700 001E                537          BEQ     load_ASL_MEM
000016EA                           538          
000016EA                           539  load_ASR_MEM:   * load and print ASR neumonic return to op loop
000016EA  43F9 00002477            540          LEA     _ASR,A1
000016F0  4EB9 00002214            541          JSR     WRITE_ASCII
000016F6  4EB9 00002244            542          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000016FC                           543           **** EA CODE GOES HERE ****
000016FC                           544          * must set unused mode/reg vars to 0
000016FC  4EB9 00001EA4            545          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001702  6000 FA70                546          BRA     DECODE_DONE
00001706                           547          
00001706                           548  load_ASL_MEM:   * load and print ASL neumonic return to op loop
00001706  43F9 00002472            549          LEA     _ASL,A1
0000170C  4EB9 00002214            550          JSR     WRITE_ASCII
00001712  4EB9 00002244            551          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001718                           552           **** EA CODE GOES HERE ****
00001718                           553          * must set unused mode/reg vars to 0
00001718  4EB9 00001EA4            554          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000171E  6000 FA54                555          BRA     DECODE_DONE
00001722                           556  
00001722                           557  LSL_LSR_MEM:    * could be LSL or LSR (memory)
00001722  2602                     558          MOVE.L  D2,D3       * copy instruction word
00001724  0243 01C0                559          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001728  0C43 00C0                560          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is LSR memory
0000172C  6700 000A                561          BEQ     load_LSR_MEM
00001730  0C43 01C0                562          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LSL memory
00001734  6700 001E                563          BEQ     load_LSL_MEM 
00001738                           564          
00001738                           565  load_LSR_MEM:   * load and print LSR neumonic return to op loop
00001738  43F9 00002481            566          LEA     _LSR,A1
0000173E  4EB9 00002214            567          JSR     WRITE_ASCII
00001744  4EB9 00002244            568          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000174A                           569           **** EA CODE GOES HERE ****
0000174A                           570          * must set unused mode/reg vars to 0
0000174A  4EB9 00001EA4            571          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001750  6000 FA22                572          BRA     DECODE_DONE
00001754                           573          
00001754                           574  load_LSL_MEM:   * load and print LSL neumonic return to op loop
00001754  43F9 0000247C            575          LEA     _LSL,A1
0000175A  4EB9 00002214            576          JSR     WRITE_ASCII
00001760  4EB9 00002244            577          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001766                           578           **** EA CODE GOES HERE ****
00001766                           579          * must set unused mode/reg vars to 0
00001766  4EB9 00001EA4            580          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000176C  6000 FA06                581          BRA     DECODE_DONE
00001770                           582  
00001770                           583  REG_shift:      * could be ASL, ASR, LSL, LSR (register)
00001770  2602                     584          MOVE.L  D2,D3       * copy instruction word
00001772  0243 0038                585          ANDI.W  #Bit2Mask,D3    * mask, isolate bits 5-3
00001776  0C43 0000                586          CMPI.W  #$0000,D3        * if bits 5-3 are 000, instruction is ASL or ASR (reg)
0000177A  6700 001A                587          BEQ     ASL_ASR_REG
0000177E  0C43 0020                588          CMPI.W  #$0020,D3       * if bits 5-3 are 100, instruction is ASL or ASR (reg)
00001782  6700 0012                589          BEQ     ASL_ASR_REG
00001786  0C43 0008                590          CMPI.W  #$0008,D3       * if bits 5-3 are 001, instruction is LSL or LSR (reg)
0000178A  6700 00F6                591          BEQ     LSL_LSR_REG
0000178E  0C43 0028                592          CMPI.W  #$0028,D3       * if bits 5-3 are 101, instruction is LSL or LSR (reg)
00001792  6700 00EE                593          BEQ     LSL_LSR_REG
00001796                           594          
00001796                           595  ASL_ASR_REG:    * could be ASL or ASR (register)
00001796  2602                     596          MOVE.L  D2,D3       * copy instruction word
00001798  0283 000001C0            597          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
0000179E                           598          
0000179E  0C43 0000                599          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ASR.B register
000017A2  6700 002A                600          BEQ     load_ASR_B_REG
000017A6  0C43 0040                601          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ASR.W register
000017AA  6700 0040                602          BEQ     load_ASR_W_REG
000017AE  0C43 0080                603          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ASR.L register
000017B2  6700 0056                604          BEQ     load_ASR_L_REG
000017B6                           605          
000017B6  0C43 0100                606          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is ASL.B register
000017BA  6700 006C                607          BEQ     load_ASL_B_REG
000017BE  0C43 0140                608          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is ASL.W register
000017C2  6700 0082                609          BEQ     load_ASL_W_REG
000017C6  0C43 0180                610          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is ASL.L register
000017CA  6700 0098                611          BEQ     load_ASL_L_REG
000017CE                           612  
000017CE                           613  load_ASR_B_REG:   * load and print ASR.B neumonic return to op loop
000017CE  43F9 0000249B            614          LEA     _ASR_B,A1
000017D4  4EB9 00002214            615          JSR     WRITE_ASCII
000017DA  4EB9 00002244            616          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000017E0  13FC 0001 000023A4       617          MOVE.B  #BYTE,INST_SZ   * save instruction size
000017E8  6000 F98A                618          BRA     DECODE_DONE
000017EC                           619          
000017EC                           620  load_ASR_W_REG:   * load and print ASR.W neumonic return to op loop
000017EC  43F9 000024A2            621          LEA     _ASR_W,A1
000017F2  4EB9 00002214            622          JSR     WRITE_ASCII
000017F8  4EB9 00002244            623          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000017FE  13FC 0003 000023A4       624          MOVE.B  #WORD,INST_SZ   * save instruction size
00001806  6000 F96C                625          BRA     DECODE_DONE
0000180A                           626          
0000180A                           627  load_ASR_L_REG:   * load and print ASR.L neumonic return to op loop
0000180A  43F9 000024A9            628          LEA     _ASR_L,A1
00001810  4EB9 00002214            629          JSR     WRITE_ASCII
00001816  4EB9 00002244            630          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000181C  13FC 0002 000023A4       631          MOVE.B  #LONG,INST_SZ   * save instruction size
00001824  6000 F94E                632          BRA     DECODE_DONE
00001828                           633          
00001828                           634  load_ASL_B_REG:   * load and print ASL.B neumonic return to op loop
00001828  43F9 00002486            635          LEA     _ASL_B,A1
0000182E  4EB9 00002214            636          JSR     WRITE_ASCII
00001834  4EB9 00002244            637          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000183A  13FC 0001 000023A4       638          MOVE.B  #BYTE,INST_SZ   * save instruction size
00001842  6000 F930                639          BRA     DECODE_DONE
00001846                           640          
00001846                           641  load_ASL_W_REG:   * load and print ASL.W neumonic return to op loop
00001846  43F9 0000248D            642          LEA     _ASL_W,A1
0000184C  4EB9 00002214            643          JSR     WRITE_ASCII
00001852  4EB9 00002244            644          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001858  13FC 0003 000023A4       645          MOVE.B  #WORD,INST_SZ   * save instruction size
00001860  6000 F912                646          BRA     DECODE_DONE
00001864                           647          
00001864                           648  load_ASL_L_REG:   * load and print ASL.L neumonic return to op loop
00001864  43F9 00002494            649          LEA     _ASL_L,A1
0000186A  4EB9 00002214            650          JSR     WRITE_ASCII
00001870  4EB9 00002244            651          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001876  13FC 0002 000023A4       652          MOVE.B  #LONG,INST_SZ   * save instruction size
0000187E  6000 F8F4                653          BRA     DECODE_DONE
00001882                           654  
00001882                           655  LSL_LSR_REG:    * could be LSL or LSR (register)
00001882  2602                     656          MOVE.L  D2,D3       * copy instruction word
00001884  0283 000001C0            657          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
0000188A                           658          
0000188A  0C43 0000                659          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is LSR.B register
0000188E  6700 002A                660          BEQ     load_LSR_B_REG
00001892  0C43 0040                661          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is LSR.W register
00001896  6700 0040                662          BEQ     load_LSR_W_REG
0000189A  0C43 0080                663          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is LSR.L register
0000189E  6700 0056                664          BEQ     load_LSR_L_REG
000018A2                           665          
000018A2  0C43 0100                666          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is LSL.B register
000018A6  6700 006C                667          BEQ     load_LSL_B_REG
000018AA  0C43 0140                668          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is LSL.W register
000018AE  6700 0082                669          BEQ     load_LSL_W_REG
000018B2  0C43 0180                670          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is LSL.L register
000018B6  6700 0098                671          BEQ     load_LSL_L_REG
000018BA                           672  
000018BA                           673  load_LSR_B_REG:   * load and print LSR.B neumonic return to op loop
000018BA  43F9 000024C5            674          LEA     _LSR_B,A1
000018C0  4EB9 00002214            675          JSR     WRITE_ASCII
000018C6  4EB9 00002244            676          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018CC  13FC 0001 000023A4       677          MOVE.B  #BYTE,INST_SZ   * save instruction size
000018D4  6000 F89E                678          BRA     DECODE_DONE
000018D8                           679          
000018D8                           680  load_LSR_W_REG:   * load and print LSR.W neumonic return to op loop
000018D8  43F9 000024CC            681          LEA     _LSR_W,A1
000018DE  4EB9 00002214            682          JSR     WRITE_ASCII
000018E4  4EB9 00002244            683          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018EA  13FC 0003 000023A4       684          MOVE.B  #WORD,INST_SZ   * save instruction size
000018F2  6000 F880                685          BRA     DECODE_DONE
000018F6                           686          
000018F6                           687  load_LSR_L_REG:   * load and print LSR.L neumonic return to op loop
000018F6  43F9 000024D3            688          LEA     _LSR_L,A1
000018FC  4EB9 00002214            689          JSR     WRITE_ASCII
00001902  4EB9 00002244            690          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001908  13FC 0002 000023A4       691          MOVE.B  #LONG,INST_SZ   * save instruction size
00001910  6000 F862                692          BRA     DECODE_DONE
00001914                           693          
00001914                           694  load_LSL_B_REG:   * load and print LSL.B neumonic return to op loop
00001914  43F9 000024B0            695          LEA     _LSL_B,A1
0000191A  4EB9 00002214            696          JSR     WRITE_ASCII
00001920  4EB9 00002244            697          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001926  13FC 0001 000023A4       698          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000192E  6000 F844                699          BRA     DECODE_DONE
00001932                           700          
00001932                           701  load_LSL_W_REG:   * load and print LSL.W neumonic return to op loop
00001932  43F9 000024B7            702          LEA     _LSL_W,A1
00001938  4EB9 00002214            703          JSR     WRITE_ASCII
0000193E  4EB9 00002244            704          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001944  13FC 0003 000023A4       705          MOVE.B  #WORD,INST_SZ   * save instruction size
0000194C  6000 F826                706          BRA     DECODE_DONE
00001950                           707          
00001950                           708  load_LSL_L_REG:   * load and print LSL.L neumonic return to op loop
00001950  43F9 000024BE            709          LEA     _LSL_L,A1
00001956  4EB9 00002214            710          JSR     WRITE_ASCII
0000195C  4EB9 00002244            711          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001962  13FC 0002 000023A4       712          MOVE.B  #LONG,INST_SZ   * save instruction size
0000196A  6000 F808                713          BRA     DECODE_DONE
0000196E                           714  
0000196E                           715  ****       EA       ****
0000196E                           716  
0000196E                           717  **** MOVE_EA FIRST EA COMMAND *********
0000196E                           718  MOVE_EA:
0000196E  2602                     719          MOVE.L  D2,D3           *copy instruction to D3 for register
00001970  2802                     720          MOVE.L  D2,D4           *copy instruction to D4 for mode
00001972  0244 0038                721          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001976  0243 0007                722          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
0000197A  E68C                     723          LSR.L   #3,D4
0000197C  13C4 000023A7            724          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001982  13C3 000023A8            725          MOVE.B  D3,SRC_REG      * save source register to memory
00001988  C8FC 0006                726          MULU    #6,D4
0000198C  C6FC 0006                727          MULU    #6,D3
00001990  43F9 00001CE8            728          LEA     EA_MODE,A1
00001996  4EB1 4000                729          JSR     (A1,D4)
0000199A  43F9 00002503            730          LEA     _COMMA,A1
000019A0  4EB9 00002214            731          JSR     WRITE_ASCII
000019A6                           732  
000019A6  4243                     733          CLR     D3
000019A8  4244                     734          CLR     D4 
000019AA                           735  ******* MOVE_EA SECOND EA COMMAND **********
000019AA  2602                     736          MOVE.L  D2,D3           *copy instruction to D3 for register
000019AC  2802                     737          MOVE.L  D2,D4           *copy instruction to D4 for modE
000019AE  0243 0E00                738          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
000019B2  0244 01C0                739          ANDI.W  #Bit1Mask,D4    *mask to isolate 3-bit mode
000019B6  1A3C 0009                740          MOVE.B  #9, D5
000019BA  EA6B                     741          LSR     D5,D3 
000019BC  EC8C                     742          LSR.L   #6,D4
000019BE  13C4 000023A5            743          MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
000019C4  13C3 000023A6            744          MOVE.B  D3,DEST_REG      * save destination register to memory 
000019CA  C8FC 0006                745          MULU   #6,D4
000019CE  C6FC 0006                746          MULU   #6,D3
000019D2                           747         
000019D2  43F9 00001CE8            748          LEA     EA_MODE,A1 
000019D8  4EB1 4000                749          JSR     (A1,D4)
000019DC  4E75                     750          RTS
000019DE                           751  
000019DE                           752  ********** LEA_EA ***********
000019DE                           753  LEA_EA:
000019DE  2602                     754          MOVE.L  D2,D3 
000019E0  2802                     755          MOVE.L  D2,D4
000019E2  0244 0038                756          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
000019E6  0243 0007                757          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
000019EA  E68C                     758          LSR.L   #3,D4
000019EC  13C4 000023A7            759          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
000019F2  13C3 000023A8            760          MOVE.B  D3,SRC_REG      * save source register to memory
000019F8  C8FC 0006                761          MULU    #6,D4
000019FC  C6FC 0006                762          MULU    #6,D3
00001A00                           763  
00001A00  43F9 00001CE8            764          LEA     EA_MODE,A1
00001A06  4EB1 4000                765          JSR     (A1,D4)
00001A0A  43F9 00002503            766          LEA     _COMMA,A1
00001A10  4EB9 00002214            767          JSR     WRITE_ASCII
00001A16                           768  
00001A16  4243                     769          CLR     D3
00001A18  4244                     770          CLR     D4 
00001A1A                           771  
00001A1A                           772  
00001A1A  2602                     773          MOVE.L  D2,D3 
00001A1C  0243 0E00                774          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001A20  1A3C 0009                775          MOVE.B  #9, D5
00001A24  EA6B                     776          LSR     D5,D3 
00001A26  13C3 000023A6            777          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001A2C  C6FC 0006                778          MULU   #6,D3
00001A30  383C 0001                779          MOVE.W  #$0001,D4       *set mode to address register
00001A34  C8FC 0006                780          MULU    #6,D4
00001A38                           781  
00001A38                           782  
00001A38  43F9 00001CE8            783          LEA     EA_MODE,A1 
00001A3E  4EB1 4000                784          JSR     (A1,D4)
00001A42  4E75                     785          RTS
00001A44                           786  
00001A44                           787  ********* DIVU_EA ************
00001A44                           788  DIVU_EA:
00001A44  2602                     789          MOVE.L  D2,D3 
00001A46  2802                     790          MOVE.L  D2,D4
00001A48  0244 0038                791          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001A4C  0243 0007                792          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001A50  E68C                     793          LSR.L   #3,D4
00001A52  13C4 000023A7            794          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001A58  13C3 000023A8            795          MOVE.B  D3,SRC_REG      * save source register to memory
00001A5E  C8FC 0006                796          MULU    #6,D4
00001A62  C6FC 0006                797          MULU    #6,D3
00001A66                           798  
00001A66  43F9 00001CE8            799          LEA     EA_MODE,A1
00001A6C  4EB1 4000                800          JSR     (A1,D4)
00001A70  43F9 00002503            801          LEA     _COMMA,A1
00001A76  4EB9 00002214            802          JSR     WRITE_ASCII
00001A7C                           803  
00001A7C  4243                     804          CLR     D3
00001A7E  4244                     805          CLR     D4 
00001A80                           806  
00001A80  2602                     807          MOVE.L  D2,D3 
00001A82  0243 0E00                808          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001A86  1A3C 0009                809          MOVE.B  #9, D5
00001A8A  EA6B                     810          LSR     D5,D3 
00001A8C  13C3 000023A6            811          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001A92  C6FC 0006                812          MULU   #6,D3
00001A96  43F9 000024DA            813          LEA     _DR,A1 
00001A9C  4EB9 00002214            814          JSR WRITE_ASCII
00001AA2                           815  
00001AA2                           816  
00001AA2  43F9 00001E04            817          LEA     EA_REG,A1 
00001AA8  4EB1 3000                818          JSR     (A1,D3)
00001AAC  4E75                     819          RTS 
00001AAE                           820  
00001AAE                           821  ****** 0PMODE_EA ************
00001AAE                           822  OPMODE_EA:
00001AAE  2802                     823          MOVE.L  D2,D4
00001AB0  0244 01C0                824          ANDI.W  #Bit1Mask,D4            *FIND OPMODE
00001AB4  EC8C                     825          LSR.L   #6,D4
00001AB6  13C4 000023A5            826          MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
00001ABC  C8FC 0006                827          MULU    #6,D4 
00001AC0                           828  
00001AC0  43F9 00001C2E            829          LEA     OPMODE,A1               *LOAD OPMODE TABLE
00001AC6  4EB1 4000                830          JSR     (A1,D4)                 *JMP TO OPMODE TABLE
00001ACA                           831  
00001ACA                           832  
00001ACA  BA3C 0001                833          CMP.B   #%1,D5                  *if flag == 1, <ea> V Dn - Dn
00001ACE  6700 0082                834          BEQ     D_TO_EA
00001AD2  BA3C 0003                835          CMP.B   #%11,D5                 *if flag == 2, <ea> - An
00001AD6  6700 00E8                836          BEQ     EA_TO_A
00001ADA  BA3C 0001                837          CMP.B   #%1,D5                  *else, Dn V <ea> - <ea>
00001ADE  6600 0004                838          BNE     EA_TO_D
00001AE2  4E75                     839          RTS
00001AE4                           840  EA_TO_D:
00001AE4  4243                     841          CLR     D3
00001AE6  4244                     842          CLR     D4
00001AE8                           843  
00001AE8  2602                     844          MOVE.L  D2,D3 
00001AEA  2802                     845          MOVE.L  D2,D4
00001AEC  0244 0038                846          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001AF0  0243 0007                847          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001AF4  E68C                     848          LSR.L   #3,D4
00001AF6  13C4 000023A7            849          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001AFC  13C3 000023A8            850          MOVE.B  D3,SRC_REG      * save source register to memory
00001B02  C8FC 0006                851          MULU    #6,D4
00001B06  C6FC 0006                852          MULU    #6,D3
00001B0A                           853  
00001B0A  43F9 00001CE8            854          LEA     EA_MODE,A1
00001B10  4EB1 4000                855          JSR     (A1,D4)
00001B14  43F9 00002503            856          LEA     _COMMA,A1
00001B1A  4EB9 00002214            857          JSR     WRITE_ASCII
00001B20                           858  
00001B20  4243                     859          CLR     D3
00001B22  4244                     860          CLR     D4 
00001B24                           861  
00001B24  2602                     862          MOVE.L  D2,D3 
00001B26  0243 0E00                863          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001B2A  1A3C 0009                864          MOVE.B  #9, D5
00001B2E  EA6B                     865          LSR     D5,D3 
00001B30  13C3 000023A6            866          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001B36  C6FC 0006                867          MULU   #6,D3
00001B3A  43F9 000024DA            868          LEA     _DR,A1 
00001B40  4EB9 00002214            869          JSR WRITE_ASCII
00001B46                           870  
00001B46                           871  
00001B46  43F9 00001E04            872          LEA     EA_REG,A1 
00001B4C  4EB1 3000                873          JSR     (A1,D3)
00001B50  4E75                     874          RTS
00001B52                           875  
00001B52                           876  D_TO_EA:
00001B52                           877  
00001B52  4243                     878          CLR     D3
00001B54  4244                     879          CLR     D4 
00001B56                           880  
00001B56  2602                     881          MOVE.L  D2,D3 
00001B58  0243 0E00                882          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001B5C  1A3C 0009                883          MOVE.B  #9, D5
00001B60  EA6B                     884          LSR     D5,D3 
00001B62  13C3 000023A6            885          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001B68  C6FC 0006                886          MULU   #6,D3
00001B6C  43F9 000024DA            887          LEA     _DR,A1 
00001B72  4EB9 00002214            888          JSR WRITE_ASCII
00001B78                           889  
00001B78                           890  
00001B78  43F9 00001E04            891          LEA     EA_REG,A1 
00001B7E  4EB1 3000                892          JSR     (A1,D3)
00001B82  43F9 00002503            893          LEA     _COMMA,A1
00001B88  4EB9 00002214            894          JSR     WRITE_ASCII
00001B8E                           895  
00001B8E  4243                     896          CLR     D3
00001B90  4244                     897          CLR     D4
00001B92                           898  
00001B92  2602                     899          MOVE.L  D2,D3 
00001B94  2802                     900          MOVE.L  D2,D4
00001B96  0244 0038                901          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001B9A  0243 0007                902          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001B9E  E68C                     903          LSR.L   #3,D4
00001BA0  13C4 000023A7            904          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001BA6  13C3 000023A8            905          MOVE.B  D3,SRC_REG      * save source register to memory
00001BAC  C8FC 0006                906          MULU    #6,D4
00001BB0  C6FC 0006                907          MULU    #6,D3
00001BB4                           908  
00001BB4  43F9 00001CE8            909          LEA     EA_MODE,A1
00001BBA  4EB1 4000                910          JSR     (A1,D4)
00001BBE  4E75                     911          RTS
00001BC0                           912  
00001BC0                           913  EA_TO_A:
00001BC0  4243                     914          CLR     D3
00001BC2  4244                     915          CLR     D4
00001BC4                           916  
00001BC4  2602                     917          MOVE.L  D2,D3 
00001BC6  2802                     918          MOVE.L  D2,D4
00001BC8  0244 0038                919          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001BCC  0243 0007                920          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001BD0  E68C                     921          LSR.L   #3,D4
00001BD2  13C4 000023A7            922          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001BD8  13C3 000023A8            923          MOVE.B  D3,SRC_REG      * save source register to memory
00001BDE  C8FC 0006                924          MULU    #6,D4
00001BE2  C6FC 0006                925          MULU    #6,D3
00001BE6                           926  
00001BE6  43F9 00001CE8            927          LEA     EA_MODE,A1
00001BEC  4EB1 4000                928          JSR     (A1,D4)
00001BF0  43F9 00002503            929          LEA     _COMMA,A1
00001BF6  4EB9 00002214            930          JSR     WRITE_ASCII
00001BFC                           931  
00001BFC  4243                     932          CLR     D3
00001BFE  4244                     933          CLR     D4 
00001C00                           934  
00001C00  2602                     935          MOVE.L  D2,D3 
00001C02  0243 0E00                936          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001C06  1A3C 0009                937          MOVE.B  #9, D5
00001C0A  EA6B                     938          LSR     D5,D3 
00001C0C  13C3 000023A6            939          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001C12  C6FC 0006                940          MULU   #6,D3
00001C16  43F9 000024DC            941          LEA     _AR,A1 
00001C1C  4EB9 00002214            942          JSR WRITE_ASCII
00001C22                           943  
00001C22                           944  
00001C22  43F9 00001E04            945          LEA     EA_REG,A1 
00001C28  4EB1 3000                946          JSR     (A1,D3)
00001C2C  4E75                     947          RTS
00001C2E                           948  
00001C2E                           949  ******* OPMODE **********
00001C2E                           950  OPMODE:
00001C2E  4EF9 00001C5E            951          JMP     OM000
00001C34  4EF9 00001C6E            952          JMP     OM001
00001C3A  4EF9 00001C7E            953          JMP     OM010
00001C40  4EF9 00001C8E            954          JMP     OM011
00001C46  4EF9 00001CA0            955          JMP     OM100
00001C4C  4EF9 00001CB2            956          JMP     OM101
00001C52  4EF9 00001CC4            957          JMP     OM110
00001C58  4EF9 00001CD6            958          JMP     OM111
00001C5E                           959  
00001C5E                           960  OM000:
00001C5E  43F9 0000244B            961          LEA     _B,A1
00001C64  4EB9 00002214            962          JSR     WRITE_ASCII
00001C6A  4245                     963          CLR     D5
00001C6C  4E75                     964          RTS   
00001C6E                           965  OM001:
00001C6E  43F9 0000244F            966          LEA     _W,A1
00001C74  4EB9 00002214            967          JSR     WRITE_ASCII
00001C7A  4245                     968          CLR     D5
00001C7C                           969  
00001C7C  4E75                     970          RTS   
00001C7E                           971  OM010:
00001C7E  43F9 00002453            972          LEA     _L,A1
00001C84  4EB9 00002214            973          JSR     WRITE_ASCII
00001C8A  4245                     974          CLR     D5
00001C8C                           975  
00001C8C  4E75                     976          RTS   
00001C8E                           977  OM011:
00001C8E  43F9 0000244F            978          LEA     _W,A1
00001C94  4EB9 00002214            979          JSR     WRITE_ASCII
00001C9A  1A3C 0003                980          MOVE.B  #%11,D5
00001C9E  4E75                     981          RTS   
00001CA0                           982  OM100:
00001CA0  43F9 0000244B            983          LEA     _B,A1
00001CA6  4EB9 00002214            984          JSR     WRITE_ASCII
00001CAC  1A3C 0001                985          MOVE.B  #%1,D5
00001CB0                           986  
00001CB0  4E75                     987          RTS   
00001CB2                           988  OM101:
00001CB2  43F9 0000244F            989          LEA     _W,A1
00001CB8  4EB9 00002214            990          JSR     WRITE_ASCII
00001CBE  1A3C 0001                991          MOVE.B  #%1,D5
00001CC2                           992  
00001CC2  4E75                     993          RTS   
00001CC4                           994  OM110:
00001CC4  43F9 00002453            995          LEA     _L,A1
00001CCA  4EB9 00002214            996          JSR     WRITE_ASCII
00001CD0  1A3C 0001                997          MOVE.B  #%1,D5
00001CD4                           998  
00001CD4  4E75                     999          RTS   
00001CD6                          1000  OM111:
00001CD6  43F9 00002453           1001          LEA     _L,A1
00001CDC  4EB9 00002214           1002          JSR     WRITE_ASCII
00001CE2  1A3C 0003               1003          MOVE.B  #%11,D5
00001CE6  4E75                    1004          RTS   
00001CE8                          1005   
00001CE8                          1006          
00001CE8                          1007  
00001CE8                          1008  
00001CE8                          1009  ******** JUMP TABLE FOR EA MODES *********
00001CE8                          1010  EA_MODE:
00001CE8  4EF9 00001D18           1011          JMP     EA000
00001CEE  4EF9 00001D30           1012          JMP     EA001
00001CF4  4EF9 00001D48           1013          JMP     EA010
00001CFA  4EF9 00001D6C           1014          JMP     EA011
00001D00  4EF9 00001D90           1015          JMP     EA100
00001D06  4EF9 00001DB4           1016          JMP     EA101
00001D0C  4EF9 00001DB6           1017          JMP     EA110
00001D12  4EF9 00001DB8           1018          JMP     EA111
00001D18                          1019  
00001D18                          1020  EA000:
00001D18  43F9 000024DA           1021          LEA     _DR,A1 
00001D1E  4EB9 00002214           1022          JSR     WRITE_ASCII
00001D24  43F9 00001E04           1023          LEA     EA_REG,A1
00001D2A  4EB1 3000               1024          JSR     (A1,D3)
00001D2E  4E75                    1025          RTS     
00001D30                          1026  EA001:
00001D30  43F9 000024DC           1027          LEA     _AR,A1 
00001D36  4EB9 00002214           1028          JSR     WRITE_ASCII
00001D3C  43F9 00001E04           1029          LEA     EA_REG,A1
00001D42  4EB1 3000               1030          JSR     (A1,D3)
00001D46  4E75                    1031          RTS     
00001D48                          1032  EA010:
00001D48  43F9 000024DE           1033          LEA     _IND_AR1,A1 
00001D4E  4EB9 00002214           1034          JSR     WRITE_ASCII
00001D54  43F9 00001E04           1035          LEA     EA_REG,A1
00001D5A  4EB1 3000               1036          JSR     (A1,D3)
00001D5E  43F9 000024E1           1037          LEA     _IND_AR2,A1
00001D64  4EB9 00002214           1038          JSR     WRITE_ASCII
00001D6A  4E75                    1039          RTS     
00001D6C                          1040      
00001D6C                          1041  EA011:
00001D6C  43F9 000024E3           1042          LEA     _AR_POST1,A1 
00001D72  4EB9 00002214           1043          JSR     WRITE_ASCII
00001D78  43F9 00001E04           1044          LEA     EA_REG,A1
00001D7E  4EB1 3000               1045          JSR     (A1,D3)
00001D82  43F9 000024E6           1046          LEA     _AR_POST2,A1
00001D88  4EB9 00002214           1047          JSR     WRITE_ASCII
00001D8E  4E75                    1048          RTS
00001D90                          1049       
00001D90                          1050      
00001D90                          1051  EA100:
00001D90  43F9 000024E9           1052          LEA     _AR_PRE1,A1 
00001D96  4EB9 00002214           1053          JSR     WRITE_ASCII
00001D9C  43F9 00001E04           1054          LEA     EA_REG,A1
00001DA2  4EB1 3000               1055          JSR     (A1,D3)
00001DA6  43F9 000024ED           1056          LEA     _AR_PRE2,A1
00001DAC  4EB9 00002214           1057          JSR     WRITE_ASCII
00001DB2  4E75                    1058          RTS   
00001DB4                          1059  
00001DB4  4E75                    1060  EA101:  RTS
00001DB6                          1061  
00001DB6  4E75                    1062  EA110:  RTS
00001DB8                          1063  
00001DB8                          1064  EA111:      
00001DB8  86FC 0006               1065          DIVU    #6,D3   * divide register num by 6 to undo jmp table multiplication
00001DBC                          1066          
00001DBC  B67C 0000               1067          CMP #0,D3   * if reg 0 load word from mem
00001DC0  6600 0016               1068          BNE EA111_R1
00001DC4  43F9 000024EF           1069          LEA _ABS,A1
00001DCA  4EB9 00002214           1070          JSR WRITE_ASCII     * write $ to buffer
00001DD0  4EB9 00001FF0           1071          JSR NEXT_MEM_WORD_TO_BUF
00001DD6  4E75                    1072          RTS
00001DD8                          1073  EA111_R1:
00001DD8  B67C 0001               1074          CMP #1,D3   * if reg 1 load long from mem
00001DDC  6600 0016               1075          BNE EA111_R4
00001DE0  43F9 000024EF           1076          LEA _ABS,A1
00001DE6  4EB9 00002214           1077          JSR WRITE_ASCII     * write $ to buffer
00001DEC  4EB9 00002006           1078          JSR NEXT_MEM_LONG_TO_BUF
00001DF2  4E75                    1079          RTS
00001DF4                          1080  EA111_R4:       
00001DF4  B67C 0004               1081          CMP #%100,D3  * if reg 4 load immediate value
00001DF8                          1082          * will need to know instruction size to propperly grab this
00001DF8  6600 0008               1083          BNE EA_MODE_DONE    * EA error if not equal to one of the valid modes
00001DFC  4EB9 00001FA2           1084          JSR ADD_IMMEDIATE_TO_BUF
00001E02                          1085  EA_MODE_DONE:
00001E02  4E75                    1086          RTS
00001E04                          1087          
00001E04                          1088  
00001E04                          1089  ********* JUMP TABLE FOR REGISTERS ******
00001E04                          1090  EA_REG:
00001E04  4EF9 00001E34           1091          JMP     REG000
00001E0A  4EF9 00001E42           1092          JMP     REG001
00001E10  4EF9 00001E50           1093          JMP     REG010
00001E16  4EF9 00001E5E           1094          JMP     REG011
00001E1C  4EF9 00001E6C           1095          JMP     REG100
00001E22  4EF9 00001E7A           1096          JMP     REG101
00001E28  4EF9 00001E88           1097          JMP     REG110
00001E2E  4EF9 00001E96           1098          JMP     REG111
00001E34                          1099  
00001E34                          1100  REG000:
00001E34  43F9 000024F3           1101          LEA     _ZERO,A1 
00001E3A  4EB9 00002214           1102          JSR     WRITE_ASCII
00001E40  4E75                    1103          RTS   
00001E42                          1104  REG001:
00001E42  43F9 000024F5           1105          LEA     _ONE,A1 
00001E48  4EB9 00002214           1106          JSR     WRITE_ASCII
00001E4E  4E75                    1107          RTS   
00001E50                          1108  REG010:
00001E50  43F9 000024F7           1109          LEA     _TWO,A1 
00001E56  4EB9 00002214           1110          JSR     WRITE_ASCII
00001E5C  4E75                    1111          RTS   
00001E5E                          1112  REG011:
00001E5E  43F9 000024F9           1113          LEA     _THREE,A1 
00001E64  4EB9 00002214           1114          JSR     WRITE_ASCII
00001E6A  4E75                    1115          RTS   
00001E6C                          1116  REG100:
00001E6C  43F9 000024FB           1117          LEA     _FOUR,A1 
00001E72  4EB9 00002214           1118          JSR     WRITE_ASCII
00001E78  4E75                    1119          RTS   
00001E7A                          1120  REG101:
00001E7A  43F9 000024FD           1121          LEA     _FIVE,A1 
00001E80  4EB9 00002214           1122          JSR     WRITE_ASCII
00001E86  4E75                    1123          RTS   
00001E88                          1124  REG110:
00001E88  43F9 000024FF           1125          LEA     _SIX,A1 
00001E8E  4EB9 00002214           1126          JSR     WRITE_ASCII
00001E94  4E75                    1127          RTS   
00001E96                          1128  REG111:
00001E96  43F9 00002501           1129          LEA     _SEVEN,A1 
00001E9C  4EB9 00002214           1130          JSR     WRITE_ASCII
00001EA2  4E75                    1131          RTS   
00001EA4                          1132    
00001EA4                          1133   
00001EA4                          1134  ***      EA ERRORS      ***
00001EA4                          1135  
00001EA4                          1136  * invalid codes for all instructions
00001EA4                          1137  BASE_EA_ERR_CHK:
00001EA4  48E7 C080               1138          MOVEM.L D0-D1/A0,-(SP)
00001EA8                          1139          * load source modes and registers
00001EA8  1039 000023A7           1140          MOVE.B  SRC_MODE,D0
00001EAE  1239 000023A8           1141          MOVE.B  SRC_REG,D1
00001EB4  0C00 0008               1142          CMPI.B  #8,D0
00001EB8  6C00 0068               1143          BGE     EA_ERR
00001EBC  C0FC 0006               1144          MULU   #6,D0       
00001EC0  41F9 00001EF2           1145          LEA     BASE_EA_ERR_MODES,A0 
00001EC6  4EB0 0000               1146          JSR     (A0,D0)
00001ECA                          1147  
00001ECA                          1148          * load destination modes and registers
00001ECA  1039 000023A5           1149          MOVE.B  DEST_MODE,D0
00001ED0  1239 000023A6           1150          MOVE.B  DEST_REG,D1
00001ED6  0C00 0008               1151          CMPI.B  #8,D0
00001EDA  6C00 0046               1152          BGE     EA_ERR
00001EDE  C0FC 0006               1153          MULU   #6,D0
00001EE2  41F9 00001EF2           1154          LEA     BASE_EA_ERR_MODES,A0 
00001EE8  4EB0 0000               1155          JSR     (A0,D0)
00001EEC                          1156  
00001EEC  4CDF 0103               1157          MOVEM.L (SP)+,D0-D1/A0
00001EF0  4E75                    1158          RTS
00001EF2                          1159  * jmp table to handle base ea errors        
00001EF2                          1160  BASE_EA_ERR_MODES:
00001EF2                          1161          * NOP slide to catch good modes and direct to rts
00001EF2  4E71                    1162          NOP
00001EF4  4E71                    1163          NOP
00001EF6  4E71                    1164          NOP
00001EF8  4E71                    1165          NOP
00001EFA  4E71                    1166          NOP
00001EFC  4E71                    1167          NOP
00001EFE  4E71                    1168          NOP
00001F00  4E71                    1169          NOP
00001F02  4E71                    1170          NOP
00001F04  4E71                    1171          NOP
00001F06  4E71                    1172          NOP
00001F08  4E71                    1173          NOP
00001F0A  4E75                    1174          RTS * return on good modes
00001F0C  4E71                    1175          NOP * 2 extra words needed for ofset to jmps
00001F0E  4E71                    1176          NOP
00001F10  4EF9 00001F22           1177          JMP EA_ERR      * mode (d16,An)      
00001F16  4EF9 00001F22           1178          JMP EA_ERR      * mode (d8,An,Xn)
00001F1C  4EF9 00001F52           1179          JMP MODE_7_CHK
00001F22                          1180  
00001F22                          1181          
00001F22                          1182  * write error to string buffer and move on to next instruction
00001F22                          1183  EA_ERR:
00001F22  48E7 8040               1184          MOVEM.L D0/A1,-(SP)
00001F26  2039 000022A8           1185          MOVE.L  END_OP_CODE_PTR,D0      * load end of opcode pointer
00001F2C  0C80 00000000           1186          CMPI.L  #0,D0                   * if ptr is 0 use existing str buf value
00001F32  6700 0004               1187          BEQ     LOAD_EA_ERR_MSG
00001F36  2840                    1188          MOVEA.L D0,A4                   * reset string buffer pointer to end of opcode neumonic 
00001F38                          1189          * load error message to buffer
00001F38                          1190  LOAD_EA_ERR_MSG:
00001F38  43F9 000027B8           1191          LEA     EA_ERR_MSG,A1
00001F3E  4EB9 00002214           1192          JSR     WRITE_ASCII
00001F44  13FC 00FF 000023A9      1193          MOVE.B  #-1,EA_ERR_FLAG
00001F4C  4CDF 0201               1194          MOVEM.L (SP)+,D0/A1
00001F50  4E75                    1195          RTS
00001F52                          1196  
00001F52                          1197  * check mode 7 for invalid reg values
00001F52                          1198  MODE_7_CHK:
00001F52  48E7 4000               1199          MOVEM.L D1,-(SP)
00001F56  B23C 0002               1200          CMP.B #%010,D1 * check for (d16,PC) 
00001F5A  67C6                    1201          BEQ   EA_ERR
00001F5C  B23C 0003               1202          CMP.B #%011,D1 * check for (d8,PC,Xn)
00001F60  67C0                    1203          BEQ   EA_ERR
00001F62  4CDF 0002               1204          MOVEM.L (SP)+,D1
00001F66  4E75                    1205          RTS   
00001F68                          1206  
00001F68                          1207  * destination adress register and imediate mode are invalid eas
00001F68                          1208  DEST_AN_IM_INVALID:
00001F68  48E7 C000               1209          MOVEM.L D0-D1,-(SP)
00001F6C                          1210          * load source modes and registers
00001F6C                          1211    * load destination modes and registers
00001F6C  1039 000023A5           1212          MOVE.B  DEST_MODE,D0
00001F72  1239 000023A6           1213          MOVE.B  DEST_REG,D1
00001F78  B03C 0001               1214          CMP.B   #1,D0   * if address register mode error
00001F7C  6600 000A               1215          BNE     AN_IM_01
00001F80  4EB8 1F22               1216          JSR     EA_ERR
00001F84  6000 0016               1217          BRA     AN_IM_02
00001F88                          1218  AN_IM_01:
00001F88  B03C 0007               1219          CMP.B   #7,D0    * if immediate data error
00001F8C  6600 000E               1220          BNE     AN_IM_02
00001F90  B23C 0004               1221          CMP.B   #4,D1
00001F94  6600 0006               1222          BNE     AN_IM_02
00001F98  4EB8 1F22               1223          JSR     EA_ERR     
00001F9C                          1224  AN_IM_02: 
00001F9C  4CDF 0003               1225          MOVEM.L (SP)+,D0-D1
00001FA0  4E75                    1226          RTS
00001FA2                          1227  
00001FA2                          1228  ***       UTILS     ****
00001FA2                          1229  
00001FA2                          1230  ADD_IMMEDIATE_TO_BUF:
00001FA2  48E7 4040               1231          MOVEM.L D1/A1,-(SP)
00001FA6  1239 000023A4           1232          MOVE.B  INST_SZ,D1  * load instruction size
00001FAC  0C01 0001               1233          CMPI.B  #BYTE,D1
00001FB0  6700 000A               1234          BEQ IN_IM_W     * if byte goto word since behavior is the same
00001FB4  0C01 0003               1235                  CMPI.B  #WORD,D1
00001FB8  6600 001A               1236          BNE CMP_IM_L    * if not equal to word branch compare to long
00001FBC                          1237  IN_IM_W:
00001FBC  43F9 000024F1           1238          LEA _IMD,A1     * print next mem word as imediate data to buffer
00001FC2  4EB9 00002214           1239          JSR WRITE_ASCII
00001FC8  4EB9 00001FF0           1240          JSR NEXT_MEM_WORD_TO_BUF
00001FCE  4CDF 0202               1241          MOVEM.L (SP)+,D1/A1
00001FD2  4E75                    1242          RTS
00001FD4                          1243  CMP_IM_L:
00001FD4  0C01 0002               1244          CMPI.B  #LONG,D1
00001FD8                          1245  *       TODO BNE        EA ERROR
00001FD8  43F9 000024F1           1246          LEA _IMD,A1      * print next mem long as imediate data to buffer
00001FDE  4EB9 00002214           1247          JSR WRITE_ASCII
00001FE4  4EB9 00002006           1248          JSR     NEXT_MEM_LONG_TO_BUF
00001FEA  4CDF 0202               1249          MOVEM.L (SP)+,D1/A1
00001FEE  4E75                    1250          RTS
00001FF0                          1251  
00001FF0                          1252  * read next word of memory to str_buffer advancing current pointer
00001FF0                          1253  NEXT_MEM_WORD_TO_BUF:
00001FF0  48E7 4400               1254          MOVEM.L D1/D5,-(SP)
00001FF4  548D                    1255          ADDA.L  #2,A5   * advance pointer
00001FF6  3215                    1256          MOVE.W  (A5),D1 * load next word of memory
00001FF8  7A00                    1257          MOVEQ.L #0,D5   * set hex length to word
00001FFA  4EB9 000021C2           1258          JSR     WRITE_HEX_TO_ASCII
00002000  4CDF 0022               1259          MOVEM.L (SP)+,D1/D5
00002004  4E75                    1260          RTS
00002006                          1261          
00002006                          1262  * read next Long of memory to str_buffer advancing current pointer
00002006                          1263  NEXT_MEM_LONG_TO_BUF:
00002006  48E7 4400               1264          MOVEM.L D1/D5,-(SP)
0000200A  548D                    1265          ADDA.L  #2,A5 * advance pointer
0000200C  2215                    1266          MOVE.L  (A5),D1
0000200E  548D                    1267          ADDA.L  #2,A5 * advance pointer again to account for long
00002010  7A20                    1268          MOVEQ.L #32,D5  * set hex length to long
00002012  4EB9 000021C2           1269          JSR     WRITE_HEX_TO_ASCII
00002018  4CDF 0022               1270          MOVEM.L (SP)+,D1/D5
0000201C  4E75                    1271          RTS
0000201E                          1272  
0000201E                          1273  * prompts user for choice
0000201E                          1274  * sets d6 to valid choice
0000201E                          1275  GET_CHOICE: 
0000201E  48E7 C040               1276          MOVEM.L   D0/D1/A1,-(SP)
00002022                          1277  HC_INT_LP:
00002022  4EB9 0000228A           1278          JSR     RESET_BUF_PTR   * move a4 to start of string buffer
00002028  43F9 00002593           1279          LEA     CHOICE_PROMPT,A1
0000202E  4EB9 00002214           1280          JSR     WRITE_ASCII
00002034  4EB9 00002262           1281          JSR     TERM_PNT_RST_BUF
0000203A  103C 0004               1282          MOVE.B  #4,D0   * read a number from keyboard into d1
0000203E  4E4F                    1283          TRAP    #15
00002040                          1284  CHOICE_1:
00002040  0C41 0001               1285          CMPI    #DISSASEMBLE ,D1
00002044  6700 0024               1286          BEQ     CHOICE_DNE    
00002048                          1287  CHOICE_2:
00002048  0C41 0002               1288          CMPI    #QUIT_PROG,D1
0000204C  6700 001C               1289          BEQ     CHOICE_DNE    
00002050                          1290  CHOICE_ERR:
00002050  43F9 000025E8           1291          LEA     INV_CHOICE,A1
00002056  4EB9 00002214           1292          JSR     WRITE_ASCII
0000205C  4EB9 00002262           1293          JSR     TERM_PNT_RST_BUF
00002062  4EB9 00002072           1294          JSR     WAIT_USR_INPUT
00002068  60B8                    1295          BRA     HC_INT_LP
0000206A                          1296          
0000206A                          1297  CHOICE_DNE:
0000206A  1C01                    1298          MOVE.B  D1,D6
0000206C  4CDF 0203               1299          MOVEM.L   (SP)+,D0/D1/A1
00002070  4E75                    1300          RTS               
00002072                          1301  
00002072                          1302  * prompt user to press enter to continue
00002072                          1303  WAIT_USR_INPUT:            
00002072  48E7 C040               1304          MOVEM.L   D0/D1/A1,-(SP)
00002076  43F9 00002603           1305          LEA     ENT_TO_CONT,A1  * load and print prompt
0000207C  4EB9 000021B2           1306          JSR     PRINT_A1
00002082  7005                    1307          MOVEQ.L #5,D0   * read in a char from keyboard
00002084  4E4F                    1308          TRAP    #15
00002086  4CDF 0203               1309          MOVEM.L   (SP)+,D0/D1/A1
0000208A  4E75                    1310          RTS
0000208C                          1311  
0000208C                          1312  LOAD_DATA_STR_INTO_BUF: * expects address to be in a5
0000208C  48E7 4000               1313          MOVEM.L   D1,-(SP)
00002090  4EB9 0000228A           1314          JSR     RESET_BUF_PTR
00002096  220D                    1315          MOVE.L  A5,D1
00002098  7A20                    1316          MOVEQ   #32,D5   * set hex length to long for address
0000209A  4EB9 000021C2           1317          JSR     WRITE_HEX_TO_ASCII * write memory address to buffer
000020A0  4EB9 0000223E           1318          JSR     WRITE_TAB_A4    * wrtie a tab
000020A6  43F9 000027D9           1319          LEA     DATA_MSG,A1     * Load template for data
000020AC  4EB9 00002214           1320          JSR     WRITE_ASCII     * write 'DATA    $' to buffer
000020B2  3215                    1321          MOVE.W  (A5),D1   * load address contents of memory to d1 for printing
000020B4  7A00                    1322          MOVEQ   #0,D5   * set hex length to word for memory contents
000020B6  4EB9 000021C2           1323          JSR     WRITE_HEX_TO_ASCII * save to buffer
000020BC  4CDF 0002               1324          MOVEM.L   (SP)+,D1
000020C0  4E75                    1325          RTS
000020C2                          1326  
000020C2  103C 0009               1327  DONE    MOVE.B  #9,D0       * Trap task 9 halt simulator
000020C6  4E4F                    1328          TRAP    #15
000020C8                          1329          
000020C8                          1330  * Converts ASCII string containing chars 0-9 and A-F uppercase to hexidecimal number
000020C8                          1331  * returns result in D6
000020C8                          1332  TO_HEX
000020C8  48E7 E060               1333          MOVEM.L   D0-D2/A1-A2,-(SP)   * save state of registers to be changed
000020CC  4282                    1334          CLR.L   D2      * clear to hold digit magnitude
000020CE  4286                    1335          CLR.L   D6      * clear to hold result
000020D0  5341                    1336          SUBI    #1,D1    * subtract 1
000020D2  C2FC 0004               1337          MULU    #4,D1   * multiply length by four to get length in binary
000020D6                          1338          
000020D6                          1339  TO_HEX_INTERNAL:
000020D6  1019                    1340          MOVE.B  (A1)+,D0     * Load char at A1 into D0
000020D8  6700 001A               1341          BEQ     END_H       * GOTO end if byte is zero (null terminated)
000020DC  0C40 0039               1342          CMPI    #$39,D0     * compare char value to 39
000020E0  6F00 0004               1343          BLE     _0_9        * GOTO 0_9 if <= 39
000020E4  5F00                    1344  A_F     SUBI.B  #$7,D0      * Subtract 7 from D0) for ASCII A-F
000020E6  0200 000F               1345  _0_9    ANDI.B  #$0F,D0     * AND with 00001111 to isolate left most 4 bits, converts to hex
000020EA  2400                    1346          MOVE.L  D0,D2        * put hex digit in D2
000020EC  E3AA                    1347          LSL.L   D1,D2       * shift hex digit final postion    
000020EE  DC82                    1348          ADD.L   D2,D6       * add to hex result
000020F0  5981                    1349          SUBI.L    #4,D1       * subract one hex digit of bits from remaining length 
000020F2  60E2                    1350          BRA     TO_HEX_INTERNAL   * convert next byte
000020F4  4CDF 0607               1351  END_H   MOVEM.L (SP)+,D0-D2/A1-A2
000020F8  4E75                    1352          RTS
000020FA                          1353  
000020FA                          1354  
000020FA                          1355  *   input address to hexadecimal saves output at A1
000020FA                          1356  IN_ADDR_TO_HEX:
000020FA  48E7 0200               1357          MOVEM.L   D6,-(SP)
000020FE  4EB8 20C8               1358          JSR     TO_HEX          * else convert to hex
00002102  2286                    1359          MOVE.L  D6,(A1)
00002104  4CDF 0040               1360          MOVEM.L   (SP)+,D6
00002108  4E75                    1361          RTS
0000210A                          1362  
0000210A                          1363  * check start and end addresses for errors
0000210A                          1364  CHK_ST_E_ADRS: * sets D5 to 1 if an error has ocurred
0000210A  48E7 4800               1365          MOVEM.L   D1/D4,-(SP)
0000210E  7A00                    1366          MOVEQ   #0,D5       * clear error flag
00002110  2439 00002290           1367          MOVE.L  ST_ADDR,D2  * load start address
00002116  2639 0000229C           1368          MOVE.L  E_ADDR,D3   * load end address
0000211C                          1369          
0000211C                          1370  LEN_CHK:                    * check address length
0000211C  1239 000022B0           1371          MOVE.B  ST_LEN,D1   * load start and end address lengths
00002122  1839 000022B1           1372          MOVE.B  E_LEN,D4
00002128                          1373          
00002128  0C01 0008               1374          CMPI.B  #8,D1       * check if start addr length is less than or equal to 8
0000212C  6F00 000E               1375          BLE     E_LEN_CHK   * check end address if no length error
00002130  4EB9 00002170           1376          JSR     PLEN_ERR    * print length error message
00002136  7A01                    1377          MOVEQ   #1,D5       * set error flag
00002138  6000 0012               1378          BRA     ODD_CHK     * skip end length check if start failed
0000213C                          1379  E_LEN_CHK:
0000213C  0C04 0008               1380          CMPI.B  #8,D4
00002140  6F00 000A               1381          BLE     ODD_CHK     * if no error skip to odd checking
00002144  4EB9 00002170           1382          JSR     PLEN_ERR    * print length error message
0000214A  7A01                    1383          MOVEQ   #1,D5       * set error flag
0000214C                          1384  
0000214C                          1385  ODD_CHK:                    * check if start address is odd
0000214C  0802 0000               1386          BTST.L  #0,D2       * test start addres LSB to see if even
00002150  6700 000A               1387          BEQ     S_GT_E
00002154  4EB9 00002186           1388          JSR     PODD_ERR    * print odd start address error
0000215A  7A01                    1389          MOVEQ   #1,D5       * set error flag
0000215C                          1390          
0000215C                          1391  S_GT_E:                     * start address greater than or less than end
0000215C  B483                    1392          CMP.L   D3,D2      * check if end is greater than or equal to start
0000215E  6F00 000A               1393          BLE     CHK_SEA_DONE   * skip to end if no error
00002162  4EB9 0000219C           1394          JSR     PS_GT_ERR   * print start greater than end error
00002168  7A01                    1395          MOVEQ   #1,D5       * set error flag
0000216A                          1396        
0000216A                          1397  CHK_SEA_DONE:
0000216A  4CDF 0012               1398          MOVEM.L   (SP)+,D1/D4
0000216E  4E75                    1399          RTS             
00002170                          1400          
00002170                          1401  *   print address length input error
00002170                          1402  PLEN_ERR:
00002170  48E7 0040               1403          MOVEM.L   A1,-(SP) 
00002174  43F9 000026B5           1404          LEA     ADR_LEN_ERR,A1   * load address input error message 
0000217A  4EB9 000021B2           1405          JSR     PRINT_A1
00002180  4CDF 0200               1406          MOVEM.L   (SP)+,A1
00002184  4E75                    1407          RTS         
00002186                          1408  
00002186                          1409  PODD_ERR: * print start address odd error
00002186  48E7 0040               1410          MOVEM.L   A1,-(SP) 
0000218A  43F9 000026FA           1411          LEA     ADR_ODD_ERR,A1
00002190  4EB9 000021B2           1412          JSR     PRINT_A1
00002196  4CDF 0200               1413          MOVEM.L   (SP)+,A1
0000219A  4E75                    1414          RTS
0000219C                          1415  
0000219C                          1416  PS_GT_ERR: * print start address greater than end address error
0000219C  48E7 0040               1417          MOVEM.L   A1,-(SP) 
000021A0  43F9 00002730           1418          LEA     ADR_S_GT_E,A1
000021A6  4EB9 000021B2           1419          JSR     PRINT_A1
000021AC  4CDF 0200               1420          MOVEM.L   (SP)+,A1
000021B0  4E75                    1421          RTS
000021B2                          1422  
000021B2                          1423   
000021B2                          1424  PRINT_A1:
000021B2  48E7 8000               1425          MOVEM.L   D0,-(SP) * save register state
000021B6  103C 000E               1426          MOVE.B  #14,D0   * print A1
000021BA  4E4F                    1427          TRAP    #15
000021BC  4CDF 0001               1428          MOVEM.L   (SP)+,D0  *  restore register state
000021C0  4E75                    1429          RTS
000021C2                          1430  
000021C2                          1431  ****************************************************
000021C2                          1432  * Subroutines for printing and writing to and from
000021C2                          1433  * the string buffer at A4
000021C2                          1434  ****************************************************        
000021C2                          1435  
000021C2                          1436  * d5 is a flag for hex value length d5==32 long is used
000021C2                          1437  * any other value short is used        
000021C2                          1438  WRITE_HEX_TO_ASCII: * write hex in d1 to a4 as ascii
000021C2                          1439          * may need to add case to handle sign extended shorts
000021C2  48E7 3800               1440          MOVEM.L   D2-D4,-(SP)
000021C6  2401                    1441          MOVE.L  D1,D2   * copy input to working temp var
000021C8  0C85 00000020           1442          CMPI.L  #32,D5           * if masked value is 0 there is no value in long portion of register for unsigned ints
000021CE  6600 000E               1443          BNE     h_short         * if not 32 hex value is short else long
000021D2                          1444          * setup params for long processing
000021D2  263C F0000000           1445          MOVE.L  #$F0000000,D3   * init mask for isolating first long hex most significand digit
000021D8  781C                    1446          MOVE.L  #28,D4          * init shift value for first long hex MSD
000021DA  6000 000A               1447          BRA     h_a_loop
000021DE                          1448          
000021DE                          1449  h_short: * setup params for short processing
000021DE  263C 0000F000           1450          MOVE.L  #$F000,D3   * init mask for isolating first short hex most significand digit
000021E4  780C                    1451          MOVE.L  #12,D4      * init shift value for first short hex MSD
000021E6                          1452          
000021E6                          1453  h_a_loop:
000021E6  0C84 00000000           1454          CMPI.L  #0,D4   * compare shift value to 0
000021EC  6D00 0020               1455          BLT     h_a_dne * done if less than 0
000021F0  2401                    1456          MOVE.L  D1,D2   * copy input to working temp var
000021F2  C483                    1457          AND.L   D3,D2   * isolate digit
000021F4  E8AA                    1458          LSR.L   D4,D2   * shift to rightmost position
000021F6                          1459          
000021F6  0C82 0000000A           1460          CMPI.L  #$A,D2   * compare to A
000021FC  6D00 0004               1461          BLT     h_a_low  * if less than A 0-9
00002200  5E42                    1462          ADDI    #7,D2    * add an additional 7 to A-F     
00002202                          1463  h_a_low:
00002202  0642 0030               1464          ADDI    #$30,D2  * add $30 to convert to ascii
00002206  18C2                    1465          MOVE.B  D2,(A4)+ * write digit to pointer location
00002208                          1466          
00002208  E88B                    1467          LSR.L   #4,D3   * shift mask to isolate next hex digit
0000220A  5984                    1468          SUBI.L  #4,D4   * subtract shift for next digit
0000220C  60D8                    1469          BRA     h_a_loop    * return to loop start
0000220E  4CDF 001C               1470  h_a_dne MOVEM.L   (SP)+,D2-D4
00002212  4E75                    1471          RTS
00002214                          1472  
00002214                          1473  WRITE_ASCII:    * copies null terminated string from A1 to A4 without null
00002214  48E7 4040               1474          MOVEM.L   D1/A1,-(SP)
00002218                          1475  w_a_loop:
00002218  1219                    1476          MOVE.B  (A1)+,D1    * load value at A1
0000221A  6700 0006               1477          BEQ     w_a_done    * if 0(null) is moved copy is done
0000221E  18C1                    1478          MOVE.B  D1,(A4)+    * else copy value to A4
00002220  60F6                    1479          BRA     w_a_loop
00002222                          1480  w_a_done:
00002222  4CDF 0202               1481          MOVEM.L   (SP)+,D1/A1
00002226  4E75                    1482          RTS
00002228                          1483  
00002228                          1484  WRITE_NULL_A4: * used to terminate a string in memory 
00002228  18FC 0000               1485          MOVE.B  #0,(A4)+
0000222C  4E75                    1486          RTS
0000222E                          1487          
0000222E                          1488  WRITE_SPC_A4: * writes an ascii space at a4
0000222E  18FC 0020               1489          MOVE.B  #SPACE,(A4)+
00002232  4E75                    1490          RTS 
00002234                          1491  
00002234                          1492  WRITE_NL_A4: * writes a newline at a4
00002234  18FC 000D               1493          MOVE.B  #CR,(A4)+
00002238  18FC 000A               1494          MOVE.B  #LF,(A4)+
0000223C  4E75                    1495          RTS
0000223E                          1496          
0000223E                          1497  WRITE_TAB_A4:
0000223E  18FC 0009               1498          MOVE.B  #TAB,(A4)+
00002242  4E75                    1499          RTS   
00002244                          1500  
00002244                          1501  * writes current string buffer pointer address to end_op_code_ptr
00002244                          1502  SET_END_OP_CODE_PTR:
00002244  23CC 000022A8           1503          MOVE.L  A4,END_OP_CODE_PTR
0000224A  4E75                    1504          RTS
0000224C                          1505  
0000224C                          1506  NL_TERM_PNT_RST_BUF: * write newline, null then print contents then reset bufffer
0000224C  4EB8 2234               1507          JSR     WRITE_NL_A4
00002250  4EB8 2228               1508          JSR     WRITE_NULL_A4
00002254  4EB9 00002274           1509          JSR     PRINT_STR_BUF
0000225A  4EB9 0000228A           1510          JSR     RESET_BUF_PTR
00002260  4E75                    1511          RTS
00002262                          1512          
00002262                          1513  TERM_PNT_RST_BUF: * write null then print contents then reset bufffer pointer
00002262  4EB8 2228               1514          JSR     WRITE_NULL_A4
00002266  4EB9 00002274           1515          JSR     PRINT_STR_BUF
0000226C  4EB9 0000228A           1516          JSR     RESET_BUF_PTR
00002272  4E75                    1517          RTS
00002274                          1518          
00002274                          1519  PRINT_STR_BUF: * prints string buffer contents to console
00002274  48E7 8040               1520          MOVEM.L   D0/A1,-(SP)
00002278  43F9 000022B3           1521          LEA     STR_BUF,A1  * load string buffer
0000227E  303C 000E               1522          MOVE    #14,D0       * print contents
00002282  4E4F                    1523          TRAP    #15
00002284  4CDF 0201               1524          MOVEM.L   (SP)+,D0/A1
00002288  4E75                    1525          RTS
0000228A                          1526  
0000228A                          1527  RESET_BUF_PTR:  * sets a4 to start of string buffer
0000228A  387C 22B3               1528          MOVEA   #STR_BUF,A4
0000228E  4E75                    1529          RTS        
00002290                          1530  
00002290                          1531  ****    VARS    ****
00002290                          1532  ST_ADDR DS.L    3   * allocate 3 longs for address ascii input needs 9 bytes to get 8 chars 
0000229C                          1533  E_ADDR  DS.L    3   * and null terminator, allocating 12 bytes to account for this
000022A8                          1534  
000022A8                          1535  END_OP_CODE_PTR:
000022A8= 00000000                1536          DCB.L   1,0 * pointer to end of opcode neumonic in the string buffer, used for ea errors
000022AC                          1537  
000022AC                          1538  CURRENT_ADDR:
000022AC= 00000000                1539          DCB.L   1,0 * BACKUP FOR CURRENT ADDRESS POINTER
000022B0                          1540  
000022B0= 00                      1541  ST_LEN  DCB.B   1,0 * var to track start address length
000022B1= 01 00                   1542  E_LEN   DC.B    1,0 * var to track end address length
000022B3= 00 00 00 00 00 00 ...   1543  STR_BUF DCB.B   241,0  * buffer to hold 240 chars + null terminator. 3 80 char lines
000023A4= 00                      1544  INST_SZ DCB.B   1,0     * used to store instuction size
000023A5                          1545  DEST_MODE:
000023A5= 00                      1546          DCB.B   1,0     * var for destination ea mode
000023A6                          1547  DEST_REG:
000023A6= 00                      1548          DCB.B   1,0     * var to save destination register in
000023A7                          1549  SRC_MODE:
000023A7= 00                      1550          DCB.B   1,0     * var for source ea mode
000023A8                          1551  SRC_REG: 
000023A8= 00                      1552          DCB.B   1,0     * var to save source register in  
000023A9                          1553  EA_ERR_FLAG:
000023A9= 00                      1554          DCB.B   1,0     * var for ea error status
000023AA                          1555           
000023AA                          1556  ****    CONST   ****
000023AA  =0000000D               1557  CR          EQU     $0D     * carraige return          
000023AA  =0000000A               1558  LF          EQU     $0A     * line feed
000023AA  =00000020               1559  SPACE       EQU     $20     * ascii space
000023AA  =00000009               1560  TAB         EQU     $09     * ascii tab character
000023AA  =00000001               1561  DISSASEMBLE EQU     $01     * dissasemble choice number
000023AA  =00000002               1562  QUIT_PROG   EQU     $02     * quit choice number
000023AA  =00000001               1563  BYTE        EQU     %01
000023AA  =00000003               1564  WORD        EQU     %11
000023AA  =00000002               1565  LONG        EQU     %10
000023AA                          1566  
000023AA                          1567  * masks for isolating nibbles with and 0 being least significant nibble
000023AA  =0000F000               1568  Nib3Mask    EQU     $F000 
000023AA  =00000F00               1569  Nib2Mask    EQU     $0F00
000023AA  =000000F0               1570  Nib1Mask    EQU     $00F0
000023AA  =0000000F               1571  Nib0Mask    EQU     $000F
000023AA                          1572  
000023AA  =00000E00               1573  Bit0Mask    EQU     $0E00
000023AA  =000001C0               1574  Bit1Mask    EQU     $01C0
000023AA  =00000038               1575  Bit2Mask    EQU     $0038
000023AA  =00000007               1576  Bit3Mask    EQU     $0007
000023AA                          1577  
000023AA  =000000FF               1578  Byte0Mask   EQU     $00FF
000023AA  =0000FF00               1579  Byte1Mask   EQU     $FF00
000023AA                          1580  
000023AA                          1581  ****    Instructions    ****
000023AA= 4E 4F 54 2E 42 20 00    1582  _NOT_B  DC.B    'NOT.B ',0
000023B1= 4E 4F 54 2E 57 20 00    1583  _NOT_W  DC.B    'NOT.W ',0
000023B8= 4E 4F 54 2E 4C 20 00    1584  _NOT_L  DC.B    'NOT.L ',0
000023BF= 4E 4F 50 20 00          1585  _NOP    DC.B    'NOP ',0
000023C4= 52 54 53 20 00          1586  _RTS    DC.B    'RTS ',0
000023C9= 4D 4F 56 45 4D 2E ...   1587  _MOVEM_W DC.B   'MOVEM.W ',0
000023D2= 4D 4F 56 45 4D 2E ...   1588  _MOVEM_L DC.B   'MOVEM.L ',0
000023DB= 4D 4F 56 45 2E 42 ...   1589  _MOVE_B DC.B    'MOVE.B ',0
000023E3= 4D 4F 56 45 2E 4C ...   1590  _MOVE_L DC.B    'MOVE.L ',0
000023EB= 4D 4F 56 45 2E 57 ...   1591  _MOVE_W DC.B    'MOVE.W ',0
000023F3= 4D 4F 56 45 41 2E ...   1592  _MOVEA_L DC.B   'MOVEA.L ',0
000023FC= 4D 4F 56 45 41 2E ...   1593  _MOVEA_W DC.B   'MOVEA.W ',0
00002405= 4A 53 52 20 00          1594  _JSR    DC.B    'JSR ',0
0000240A= 4C 45 41 20 00          1595  _LEA    DC.B    'LEA ',0
0000240F= 41 44 44 51 2E 42 ...   1596  _ADDQ_B DC.B    'ADDQ.B ',0
00002417= 41 44 44 51 2E 57 ...   1597  _ADDQ_W DC.B    'ADDQ.W ',0
0000241F= 41 44 44 51 2E 4C ...   1598  _ADDQ_L DC.B    'ADDQ.L ',0
00002427= 42 52 41 20 00          1599  _BRA    DC.B    'BRA ',0
0000242C= 42 45 51 20 00          1600  _BEQ    DC.B    'BEQ ',0
00002431= 42 47 54 20 00          1601  _BGT    DC.B    'BGT ',0
00002436= 42 4C 45 20 00          1602  _BLE    DC.B    'BLE ',0
0000243B= 4D 4F 56 45 51 20 00    1603  _MOVEQ  DC.B    'MOVEQ ',0
00002442= 44 49 56 55 20 00       1604  _DIVU   DC.B    'DIVU ',0
00002448= 4F 52 00                1605  _OR     DC.B    'OR',0
0000244B= 2E 42 20 00             1606  _B   DC.B    '.B ',0
0000244F= 2E 57 20 00             1607  _W   DC.B    '.W ',0
00002453= 2E 4C 20 00             1608  _L   DC.B    '.L ',0
00002457= 53 55 42 20 00          1609  _SUB    DC.B    'SUB ',0
0000245C= 4D 55 4C 53 20 00       1610  _MULS   DC.B    'MULS ',0
00002462= 41 4E 44 20 00          1611  _AND    DC.B    'AND ',0
00002467= 41 44 44 20 00          1612  _ADD    DC.B    'ADD ',0
0000246C= 41 44 44 41 20 00       1613  _ADDA   DC.B    'ADDA ',0
00002472= 41 53 4C 20 00          1614  _ASL    DC.B    'ASL ',0
00002477= 41 53 52 20 00          1615  _ASR    DC.B    'ASR ',0
0000247C= 4C 53 4C 20 00          1616  _LSL    DC.B    'LSL ',0
00002481= 4C 53 52 20 00          1617  _LSR    DC.B    'LSR ',0
00002486= 41 53 4C 2E 42 20 00    1618  _ASL_B  DC.B    'ASL.B ',0
0000248D= 41 53 4C 2E 57 20 00    1619  _ASL_W  DC.B    'ASL.W ',0
00002494= 41 53 4C 2E 4C 20 00    1620  _ASL_L  DC.B    'ASL.L ',0
0000249B= 41 53 52 2E 42 20 00    1621  _ASR_B  DC.B    'ASR.B ',0
000024A2= 41 53 52 2E 57 20 00    1622  _ASR_W  DC.B    'ASR.W ',0
000024A9= 41 53 52 2E 4C 20 00    1623  _ASR_L  DC.B    'ASR.L ',0
000024B0= 4C 53 4C 2E 42 20 00    1624  _LSL_B  DC.B    'LSL.B ',0
000024B7= 4C 53 4C 2E 57 20 00    1625  _LSL_W  DC.B    'LSL.W ',0
000024BE= 4C 53 4C 2E 4C 20 00    1626  _LSL_L  DC.B    'LSL.L ',0
000024C5= 4C 53 52 2E 42 20 00    1627  _LSR_B  DC.B    'LSR.B ',0
000024CC= 4C 53 52 2E 57 20 00    1628  _LSR_W  DC.B    'LSR.W ',0
000024D3= 4C 53 52 2E 4C 20 00    1629  _LSR_L  DC.B    'LSR.L ',0
000024DA                          1630  
000024DA                          1631  ****    Modes    ****
000024DA= 44 00                   1632  _DR             DC.B   'D',0
000024DC= 41 00                   1633  _AR             DC.B   'A',0
000024DE= 28 41 00                1634  _IND_AR1        DC.B   '(A',0
000024E1= 29 00                   1635  _IND_AR2        DC.B   ')',0
000024E3= 28 41 00                1636  _AR_POST1       DC.B   '(A',0
000024E6= 29 2B 00                1637  _AR_POST2       DC.B   ')+',0
000024E9= 2D 28 41 00             1638  _AR_PRE1        DC.B   '-(A',0
000024ED= 29 00                   1639  _AR_PRE2        DC.B   ')',0
000024EF= 24 00                   1640  _ABS            DC.B    '$',0
000024F1= 23 00                   1641  _IMD            DC.B    '#',0
000024F3                          1642  
000024F3                          1643  ****    Numbers    ****
000024F3= 30 00                   1644  _ZERO   DC.B    '0',0
000024F5= 31 00                   1645  _ONE    DC.B    '1',0
000024F7= 32 00                   1646  _TWO    DC.B    '2',0
000024F9= 33 00                   1647  _THREE  DC.B    '3',0
000024FB= 34 00                   1648  _FOUR   DC.B    '4',0
000024FD= 35 00                   1649  _FIVE   DC.B    '5',0
000024FF= 36 00                   1650  _SIX    DC.B    '6',0
00002501= 37 00                   1651  _SEVEN  DC.B    '7',0
00002503= 2C 00                   1652  _COMMA  DC.B    ',',0
00002505                          1653  
00002505                          1654  ****    MODE CMP VALUES    ****
00002505  =00000000               1655  cDR             EQU     $0000
00002505  =00000040               1656  cAR             EQU     $0040
00002505  =00000080               1657  cIND_AR         EQU     $0080
00002505  =000000C0               1658  cAR_POST        EQU     $00C0
00002505  =00000100               1659  cAR_PRE         EQU     $0100
00002505  =000001C0               1660  cABS            EQU     $01C0
00002505                          1661  
00002505                          1662  ****    MESSAGES    ****
00002505                          1663  
00002505= 2A 2A 2A 2A 2A 2A ...   1664  WELCOME     DC.B    '*********************************************',CR,LF
00002534= 2A 20 57 65 6C 63 ...   1665              DC.B    '* Welcome to EASY 68K Disasembler by Nibble *',CR,LF
00002563= 2A 2A 2A 2A 2A 2A ...   1666              DC.B    '*********************************************',CR,LF,0
00002593                          1667              
00002593                          1668  CHOICE_PROMPT:
00002593= 45 6E 74 65 72 20 ...   1669              DC.B    'Enter a number to make a choice:',CR,LF
000025B5= 31 3A 20 44 69 73 ...   1670              DC.B    '1: Dissasemble an Address Range',CR,LF
000025D6= 32 3A 20 45 78 69 ...   1671              DC.B    '2: Exit Program',CR,LF,0
000025E8                          1672         
000025E8= 45 52 52 4F 52 3A ...   1673  INV_CHOICE  DC.B    'ERROR: INVALID selection',CR,LF,0
00002603                          1674  
00002603= 0D 0A 50 72 65 73 ...   1675  ENT_TO_CONT DC.B    CR,LF,'Press enter to continue...',CR,LF,0
00002622                          1676  
00002622= 0D 0A 45 6E 74 65 ...   1677  ST_A_MSG    DC.B    CR,LF,'Enter an address range in hexidecimal to be dissasembled',CR,LF * start address message
0000265E= 56 61 6C 69 64 20 ...   1678              DC.B    'Valid address chars: 0-1 A-F case insensitive',CR,LF  
0000268D= 45 6E 74 65 72 20 ...   1679              DC.B    'Enter start address:',0    
000026A2                          1680              
000026A2= 45 6E 74 65 72 20 ...   1681  E_A_MSG     DC.B    'Enter end address:',0    * end address message
000026B5                          1682  
000026B5= 0D 0A 45 52 52 4F ...   1683  ADR_LEN_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-8 hexidecimal digits long',CR,LF,0    * address input error message
000026FA                          1684  
000026FA= 0D 0A 45 52 52 4F ...   1685  ADR_ODD_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must be even',CR,LF,0  * odd input address error message
00002730                          1686              
00002730= 0D 0A 45 52 52 4F ...   1687  ADR_S_GT_E  DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must come before end address',CR,LF,0 * start greater than end address error msg
00002776                          1688  
00002776= 0D 0A 45 52 52 4F ...   1689  HEX_ERR     DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-1 A-F case insensitive',CR,LF,0
000027B8                          1690  
000027B8= 45 52 52 4F 52 3A ...   1691  EA_ERR_MSG  DC.B    'ERROR: INVALID EFFECTIVE ADDRESS',0      * error message for invalid eas
000027D9                          1692  
000027D9= 44 41 54 41 20 20 ...   1693  DATA_MSG    DC.B    'DATA   $',0
000027E2                          1694  
000027E2= 43 4F 4E 56 45 52 ...   1695  TEST_MSG    DC.B    'CONVERTED ADDRESS IS: ',0  * test message for printing start and end addresses
000027F9                          1696              
000027F9                          1697              END     INIT        * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDQ_               1454
ADD_IMMEDIATE_TO_BUF  1FA2
ADR_LEN_ERR         26B5
ADR_ODD_ERR         26FA
ADR_S_GT_E          2730
AN_IM_01            1F88
AN_IM_02            1F9C
ASL_ASR_MEM         16D4
ASL_ASR_REG         1796
A_F                 20E4
BASE_EA_ERR_CHK     1EA4
BASE_EA_ERR_MODES   1EF2
BIT0MASK            E00
BIT1MASK            1C0
BIT2MASK            38
BIT3MASK            7
BYTE                1
BYTE0MASK           FF
BYTE1MASK           FF00
CABS                1C0
CAR                 40
CAR_POST            C0
CAR_PRE             100
CDR                 0
CHK_LFT_NIB         1108
CHK_SEA_DONE        216A
CHK_ST_E_ADRS       210A
CHOICE_1            2040
CHOICE_2            2048
CHOICE_DNE          206A
CHOICE_ERR          2050
CHOICE_PROMPT       2593
CIND_AR             80
CMP_IM_L            1FD4
CR                  D
CURRENT_ADDR        22AC
DATA_MSG            27D9
DECODE_DONE         1174
DEST_AN_IM_INVALID  1F68
DEST_MODE           23A5
DEST_REG            23A6
DISSASEMBLE         1
DIVU_EA             1A44
DONE                20C2
D_TO_EA             1B52
EA000               1D18
EA001               1D30
EA010               1D48
EA011               1D6C
EA100               1D90
EA101               1DB4
EA110               1DB6
EA111               1DB8
EA111_R1            1DD8
EA111_R4            1DF4
EA_ERR              1F22
EA_ERR_FLAG         23A9
EA_ERR_MSG          27B8
EA_MODE             1CE8
EA_MODE_DONE        1E02
EA_REG              1E04
EA_TO_A             1BC0
EA_TO_D             1AE4
END_H               20F4
END_OP_CODE_PTR     22A8
ENT_TO_CONT         2603
E_ADDR              229C
E_A_MSG             26A2
E_LEN               22B1
E_LEN_CHK           213C
GET_CHOICE          201E
HC_INT_LP           2022
HEX_ERR             2776
H_A_DNE             220E
H_A_LOOP            21E6
H_A_LOW             2202
H_SHORT             21DE
INIT                1000
INPUT_START         1028
INST_SZ             23A4
INV_CHOICE          25E8
IN_ADDR_TO_HEX      20FA
IN_IM_W             1FBC
LEA_EA              19DE
LEN_CHK             211C
LF                  A
LOAD_ADD            1684
LOAD_ADDA           1662
LOAD_ADDQ_B         1472
LOAD_ADDQ_L         14BA
LOAD_ADDQ_W         1496
LOAD_AND            1626
LOAD_ASL_B_REG      1828
LOAD_ASL_L_REG      1864
LOAD_ASL_MEM        1706
LOAD_ASL_W_REG      1846
LOAD_ASR_B_REG      17CE
LOAD_ASR_L_REG      180A
LOAD_ASR_MEM        16EA
LOAD_ASR_W_REG      17EC
LOAD_BEQ            151A
LOAD_BGT            1536
LOAD_BLE            154C
LOAD_BRA            1504
LOAD_DATA_STR_INTO_BUF  208C
LOAD_DIVU           158E
LOAD_EA_ERR_MSG     1F38
LOAD_JSR            13F6
LOAD_LEA            13D4
LOAD_LSL_B_REG      1914
LOAD_LSL_L_REG      1950
LOAD_LSL_MEM        1754
LOAD_LSL_W_REG      1932
LOAD_LSR_B_REG      18BA
LOAD_LSR_L_REG      18F6
LOAD_LSR_MEM        1738
LOAD_LSR_W_REG      18D8
LOAD_MOVEA_L        11DC
LOAD_MOVEA_W        124C
LOAD_MOVEM_L        1430
LOAD_MOVEM_W        140C
LOAD_MOVEQ          1562
LOAD_MOVE_B         1196
LOAD_MOVE_L         1206
LOAD_MOVE_W         1276
LOAD_MULS           160A
LOAD_NOP            13A8
LOAD_NOT_B          1302
LOAD_NOT_L          1356
LOAD_NOT_W          132C
LOAD_OR             15B0
LOAD_RTS            13BE
LOAD_SUB            15D2
LONG                2
LSL_LSR_MEM         1722
LSL_LSR_REG         1882
MEMORY_SHIFT        16BE
MODE_7_CHK          1F52
MOVE_EA             196E
NEXT_MEM_LONG_TO_BUF  2006
NEXT_MEM_WORD_TO_BUF  1FF0
NIB0MASK            F
NIB1MASK            F0
NIB2MASK            F00
NIB3MASK            F000
NL_TERM_PNT_RST_BUF  224C
NOP_RTS_JSR         1380
NOT_                12E4
NO_EA_ERROR         118C
ODD_CHK             214C
OM000               1C5E
OM001               1C6E
OM010               1C7E
OM011               1C8E
OM100               1CA0
OM101               1CB2
OM110               1CC4
OM111               1CD6
OPMODE              1C2E
OPMODE_EA           1AAE
OP_2                11C6
OP_3                1236
OP_4                12A6
OP_6                14DE
OP_8                1578
OP_C                15F4
OP_CODES            10AC
OP_D                1648
OP_DONE             1194
OP_E                16A6
OP_ERR              116E
OP_START            10BE
PLEN_ERR            2170
PODD_ERR            2186
PRINT_A1            21B2
PRINT_STR_BUF       2274
PS_GT_ERR           219C
QUIT                10A6
QUIT_PROG           2
REG000              1E34
REG001              1E42
REG010              1E50
REG011              1E5E
REG100              1E6C
REG101              1E7A
REG110              1E88
REG111              1E96
REG_SHIFT           1770
RESET_BUF_PTR       228A
SET_END_OP_CODE_PTR  2244
SPACE               20
SRC_MODE            23A7
SRC_REG             23A8
START               101A
STR_BUF             22B3
ST_ADDR             2290
ST_A_MSG            2622
ST_DIS              1096
ST_LEN              22B0
S_GT_E              215C
TAB                 9
TERM_PNT_RST_BUF    2262
TEST_MSG            27E2
TO_HEX              20C8
TO_HEX_INTERNAL     20D6
WAIT_USR_INPUT      2072
WELCOME             2505
WORD                3
WRITE_ASCII         2214
WRITE_HEX_TO_ASCII  21C2
WRITE_NL_A4         2234
WRITE_NULL_A4       2228
WRITE_SPC_A4        222E
WRITE_TAB_A4        223E
W_A_DONE            2222
W_A_LOOP            2218
_0_9                20E6
_ABS                24EF
_ADD                2467
_ADDA               246C
_ADDQ_B             240F
_ADDQ_L             241F
_ADDQ_W             2417
_AND                2462
_AR                 24DC
_AR_POST1           24E3
_AR_POST2           24E6
_AR_PRE1            24E9
_AR_PRE2            24ED
_ASL                2472
_ASL_B              2486
_ASL_L              2494
_ASL_W              248D
_ASR                2477
_ASR_B              249B
_ASR_L              24A9
_ASR_W              24A2
_B                  244B
_BEQ                242C
_BGT                2431
_BLE                2436
_BRA                2427
_COMMA              2503
_DIVU               2442
_DR                 24DA
_FIVE               24FD
_FOUR               24FB
_IMD                24F1
_IND_AR1            24DE
_IND_AR2            24E1
_JSR                2405
_L                  2453
_LEA                240A
_LSL                247C
_LSL_B              24B0
_LSL_L              24BE
_LSL_W              24B7
_LSR                2481
_LSR_B              24C5
_LSR_L              24D3
_LSR_W              24CC
_MOVEA_L            23F3
_MOVEA_W            23FC
_MOVEM_L            23D2
_MOVEM_W            23C9
_MOVEQ              243B
_MOVE_B             23DB
_MOVE_L             23E3
_MOVE_W             23EB
_MULS               245C
_NOP                23BF
_NOT_B              23AA
_NOT_L              23B8
_NOT_W              23B1
_ONE                24F5
_OR                 2448
_RTS                23C4
_SEVEN              2501
_SIX                24FF
_SUB                2457
_THREE              24F9
_TWO                24F7
_W                  244F
_ZERO               24F3
