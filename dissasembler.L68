00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/26/2019 3:29:43 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Dissasembler
00000000                             3  * Written by :  Nick, Shelby, and Zoe
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7          ORG     $1000
00001000                             8          
00001000                             9  ****    MAIN LOOP   ****
00001000  4E71                      10  INIT:   NOP     * line for testing
00001002  4EB9 000019D8             11          JSR     RESET_BUF_PTR
00001008  43F9 00001BA7             12          LEA     WELCOME,A1      * print welcome message
0000100E  4EB9 0000196A             13          JSR     WRITE_ASCII
00001014  4EB9 000019B0             14          JSR     TERM_PNT_RST_BUF
0000101A                            15          
0000101A                            16  START:  
0000101A  4EB9 00001774             17          JSR     GET_CHOICE      * get choice from user to dissasemble or quit
00001020  0C46 0002                 18          CMPI    #QUIT_PROG,D6
00001024  6700 00D2                 19          BEQ     QUIT
00001028                            20          
00001028                            21  
00001028                            22  INPUT_START:
00001028  43F9 00001CC4             23          LEA     ST_A_MSG,A1     * load start address prompt message
0000102E  4EB9 0000196A             24          JSR     WRITE_ASCII     * write to string buffer
00001034  4EB9 000019B0             25          JSR     TERM_PNT_RST_BUF * terminate string buffer and print reseting pointer at A4
0000103A                            26          
0000103A  43F9 000019DE             27          LEA     ST_ADDR,A1 * load start address
00001040  4291                      28          CLR.L   (A1)    * clear long at a1
00001042  103C 0002                 29          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001046  4E4F                      30          TRAP    #15
00001048  13C1 000019F6             31          MOVE.B  D1,ST_LEN    * save start length to memory 
0000104E                            32          
0000104E  4EB9 00001850             33          JSR     IN_ADDR_TO_HEX  * convert start address to hex
00001054                            34               
00001054  43F9 00001D44             35          LEA     E_A_MSG,A1      * load end address prompt message
0000105A  4EB9 0000196A             36          JSR     WRITE_ASCII     * print message
00001060  4EB9 000019B0             37          JSR     TERM_PNT_RST_BUF  * print and reset buffer no newline
00001066                            38          
00001066  43F9 000019EA             39          LEA     E_ADDR,A1  * load end address
0000106C  4291                      40          CLR.L   (A1)    * clear long at end address
0000106E  103C 0002                 41          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001072  4E4F                      42          TRAP    #15
00001074  13C1 000019F7             43          MOVE.B  D1,E_LEN    * save end length to memory
0000107A                            44          
0000107A  4EB9 00001850             45          JSR     IN_ADDR_TO_HEX  * convert end address to hex
00001080                            46          
00001080  4EB9 00001860             47          JSR     CHK_ST_E_ADRS   * check addresses for errors
00001086  0C05 0001                 48          CMPI.B  #1,D5           * if an error occured return to start
0000108A  6600 000A                 49          BNE     ST_DIS          * branch to dissasembly if no errors
0000108E  4EB9 000017C8             50          JSR     WAIT_USR_INPUT    
00001094  6092                      51          BRA     INPUT_START     * return to start
00001096                            52          
00001096                            53          * print converted addresses for testing purposes
00001096                            54          
00001096  4EB9 000019D8             55  ST_DIS  JSR     RESET_BUF_PTR         * move a4 to start of string buffer
0000109C                            56          
0000109C  4EB9 0000198A             57          JSR     WRITE_NL_A4           * write newline to buffer
000010A2                            58          
000010A2  43F9 00001E63             59          LEA     TEST_MSG,A1
000010A8  4EB9 0000196A             60          JSR     WRITE_ASCII
000010AE                            61          
000010AE  2239 000019DE             62          MOVE.L  ST_ADDR,D1    * test print from string buffer
000010B4  7A00                      63          MOVEQ   #0,D5   * set hex length to word
000010B6  4EB9 00001918             64          JSR     WRITE_HEX_TO_ASCII    * call conversion subroutine
000010BC                            65  
000010BC  4EB9 0000198A             66          JSR     WRITE_NL_A4           * write newline to buffer
000010C2                            67          
000010C2  43F9 00001E63             68          LEA     TEST_MSG,A1
000010C8  4EB9 0000196A             69          JSR     WRITE_ASCII           * copy test_msg to buffer  
000010CE                            70          
000010CE  2239 000019EA             71          MOVE.L  E_ADDR,D1             * write end address to buffer
000010D4  7A00                      72          MOVEQ   #0,D5   * set hex length to word
000010D6  4EB9 00001918             73          JSR     WRITE_HEX_TO_ASCII
000010DC                            74          
000010DC                            75  
000010DC  4EB9 0000198A             76          JSR     WRITE_NL_A4           * write newline to buffer
000010E2  4EB9 0000199A             77          JSR     NL_TERM_PNT_RST_BUF   * print buffer contents
000010E8                            78          
000010E8                            79          * end test printing converted numbers
000010E8                            80          
000010E8  4EB9 000010FE             81          JSR     OP_CODES
000010EE                            82          
000010EE  4EB9 0000199A             83          JSR     NL_TERM_PNT_RST_BUF * print newline after op codes
000010F4                            84           
000010F4  6000 FF24                 85          BRA     START 
000010F8                            86  
000010F8                            87  
000010F8  103C 0009                 88  QUIT    MOVE.B  #9,D0
000010FC  4E4F                      89          TRAP    #15 * stop sim
000010FE                            90  
000010FE                            91  
000010FE                            92  ****    OP-CODES    ****
000010FE                            93  OP_CODES:
000010FE  4EB9 000019D8             94          JSR     RESET_BUF_PTR   * reset string buffer pointer
00001104  2A79 000019DE             95          MOVE.L  ST_ADDR,A5  * load starting address into a5
0000110A  2C79 000019EA             96          MOVE.L  E_ADDR,A6   * load ending address into a6
00001110                            97          
00001110                            98  OP_START:
00001110                            99          * write address and a tab to str buffer
00001110  220D                     100          MOVE.L  A5,D1   * load address from A5 into D1
00001112  7A20                     101          MOVEQ   #32,D5   * set hex length to long for address printing
00001114  4EB9 00001918            102          JSR     WRITE_HEX_TO_ASCII
0000111A  4EB9 00001994            103          JSR     WRITE_TAB_A4
00001120                           104          
00001120  3415                     105          MOVE.W (A5),D2 * load word of memory into D1
00001122                           106          
00001122                           107          
00001122                           108  CHK_LFT_NIB:
00001122  2602                     109          MOVE.L  D2,D3   * copy to d3
00001124                           110          
00001124  0243 F000                111          ANDI.W  #Nib3Mask,D3 * clear all but left four bits
00001128  0C43 1000                112          CMPI.W  #$1000,D3   * if nibble3 == 1, branch to move byte (1)
0000112C  6700 0070                113          BEQ     load_MOVE_B
00001130                           114  
00001130  0C43 2000                115          CMPI.W  #$2000,D3   * if nibble3 == 2, branch to that set (move.l, movea.l)
00001134  6700 007E                116          BEQ     OP_2
00001138  0C43 3000                117          CMPI.W  #$3000,D3   * if nibble3 == 3, branch to that set (move.w, movea.w)
0000113C  6700 00AE                118          BEQ     OP_3              
00001140  0C43 4000                119          CMPI.W  #$4000,D3   * if nibble3 == 4 branch to that set (not/nop/rts/jsr/movem/lea)
00001144                           120  
00001144  6700 00E2                121          BEQ     OP_4 
00001148  0C43 5000                122          CMPI.W  #$5000,D3   * if nibble3 == 5, branch to ADDQ (5)
0000114C  6700 01B0                123          BEQ     load_ADDQ
00001150  0C43 6000                124          CMPI.W  #$6000,D3   * if nibble3 == 6, branch to that set (bra, bcc)
00001154  6700 01B8                125          BEQ     OP_6
00001158  0C43 7000                126          CMPI.W  #$7000,D3   * if nibble3 == 7, branch to MOVEQ
0000115C  6700 0216                127          BEQ     load_MOVEQ
00001160  0C43 8000                128          CMPI.W  #$8000,D3   * if nibble3 == 8, branch to that set (divu, or)
00001164  6700 021E                129          BEQ     OP_8
00001168  0C43 9000                130          CMPI.W  #$9000,D3   * if nibble3 == 9, branch to SUB
0000116C  6700 024C                131          BEQ     load_SUB
00001170  0C43 C000                132          CMPI.W  #$C000,D3   * if nibble3 == C, branch to that set (muls, and)
00001174  6700 0254                133          BEQ     OP_C
00001178  0C43 D000                134          CMPI.W  #$D000,D3   * if nibble3 == D, branch to that set (add, adda)
0000117C  6700 0282                135          BEQ     OP_D
00001180  0C43 E000                136          CMPI.W  #$E000,D3   * if nibble3 == E, branch to that set (asl, asr, lsl, lsr)
00001184  6700 02B4                137          BEQ     OP_E
00001188                           138                         
00001188  4EB9 000017E2            139  OP_ERR  JSR     LOAD_DATA_STR_INTO_BUF
0000118E                           140          
0000118E                           141  
0000118E                           142  DECODE_DONE:    * print newline then check if op-code loop is done
0000118E  4EB9 0000199A            143          JSR     NL_TERM_PNT_RST_BUF * write newline then print
00001194  548D                     144          ADD.L   #2,A5   * increment current address pointer by 2 bytes 
00001196  BBCE                     145          CMP.L   A6,A5  * loop if start is less than or equal to end
00001198  6F00 FF76                146          BLE     OP_START
0000119C  4E75                     147  OP_DONE RTS
0000119E                           148  
0000119E                           149  load_MOVE_B:    * load and print MOVE.B neumonic return to op loop
0000119E  43F9 00001B06            150          LEA     _MOVE_B,A1
000011A4  4EB9 0000196A            151          JSR     WRITE_ASCII
000011AA  4243                     152          CLR     D3
000011AC  4EB9 000015AA            153          JSR     MOVE_EA
000011B2  60DA                     154          BRA     DECODE_DONE
000011B4                           155         
000011B4                           156  OP_2:   * could be MOVE.L or MOVEA.L
000011B4  2602                     157          MOVE.L  D2,D3   * copy instruction word
000011B6  0243 01C0                158          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000011BA  0C43 0028                159          CMPI.W  #0040,D3        * if bits 8-6 are 001, instruction is MOVEA.L
000011BE  6700 000A                160          BEQ     load_MOVEA_L
000011C2  0C43 0028                161          CMPI.W  #0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.L
000011C6  6600 0010                162          BNE     load_MOVE_L
000011CA                           163          
000011CA                           164  load_MOVEA_L:   * load and print MOVEA.L neumonic return to op loop
000011CA  43F9 00001B1B            165          LEA     _MOVEA_L,A1
000011D0  4EB9 0000196A            166          JSR     WRITE_ASCII
000011D6  60B6                     167          BRA     DECODE_DONE
000011D8                           168  
000011D8                           169  load_MOVE_L:    * load and print MOVE.L neumonic return to op loop
000011D8  43F9 00001B0D            170          LEA     _MOVE_L,A1
000011DE  4EB9 0000196A            171          JSR     WRITE_ASCII
000011E4  4EB9 000015AA            172          JSR     MOVE_EA
000011EA  60A2                     173          BRA     DECODE_DONE
000011EC                           174          
000011EC                           175  OP_3:   * could be MOVE.W or MOVEA.W
000011EC  2602                     176          MOVE.L  D2,D3   * copy instruction word
000011EE  0243 01C0                177          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000011F2  0C43 0028                178          CMPI.W  #0040,D3        * if bits 8-6 are 001, instruction is MOVEA.W
000011F6  6700 000A                179          BEQ     load_MOVEA_W
000011FA  0C43 0028                180          CMPI.W  #0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.W
000011FE  6600 0012                181          BNE     load_MOVE_W
00001202                           182          
00001202                           183  load_MOVEA_W:   * load and print MOVEA.W neumonic return to op loop
00001202  43F9 00001B23            184          LEA     _MOVEA_W,A1
00001208  4EB9 0000196A            185          JSR     WRITE_ASCII
0000120E  6000 FF7E                186          BRA     DECODE_DONE
00001212                           187  
00001212                           188  load_MOVE_W:    * load and print MOVE.W neumonic return to op loop
00001212  43F9 00001B14            189          LEA     _MOVE_W,A1
00001218  4EB9 0000196A            190          JSR     WRITE_ASCII
0000121E  4EB9 000015AA            191          JSR     MOVE_EA
00001224  6000 FF68                192          BRA     DECODE_DONE
00001228                           193  
00001228                           194  OP_4:   * could be not, nop, rts, jsr, MOVEM.L, lea
00001228  2602                     195          MOVE.L  D2,D3   * copy instruction word
0000122A  0243 0F00                196          ANDI.W  #Nib2Mask,D3
0000122E  0C43 0600                197          CMPI.W  #$0600,D3   * if nibble 2 is 6, instruction is NOT
00001232  6700 0032                198          BEQ     load_NOT
00001236                           199  
00001236  0C43 0E00                200          CMPI.W  #$0E00,D3  * if nibble 2 is E could be nop or rts or jsr
0000123A  6700 003A                201          BEQ     NOP_RTS_JSR
0000123E                           202          
0000123E                           203          * try for LEA
0000123E  2602                     204          MOVE.L  D2,D3
00001240  0243 01C0                205          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001244  0C43 01C0                206          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LEA
00001248  6700 0074                207          BEQ     load_LEA
0000124C                           208          
0000124C                           209          * try for MOVEM.W or MOVEM.L
0000124C  2602                     210          MOVE.L  D2,D3
0000124E  0243 01C0                211          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 for size
00001252  0C43 0080                212          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is MOVEM.W
00001256  6700 0086                213          BEQ     load_MOVEM_W
0000125A  0C43 00C0                214          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is MOVEM.L
0000125E  6700 008E                215          BEQ     load_MOVEM_L
00001262                           216  
00001262                           217          
00001262  6000 FF24                218          BRA     OP_ERR  * return to error decoding
00001266                           219          
00001266                           220  load_NOT:   * load and print NOT neumonic return to op loop
00001266  43F9 00001AEA            221          LEA     _NOT,A1
0000126C  4EB9 0000196A            222          JSR     WRITE_ASCII
00001272  6000 FF1A                223          BRA     DECODE_DONE
00001276                           224  
00001276                           225  NOP_RTS_JSR: * could be NOP or RTS or JSR
00001276  2602                     226          MOVE.L  D2,D3
00001278  0243 01C0                227          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
0000127C  0C43 0080                228          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is JSR
00001280  6700 004C                229          BEQ     load_JSR
00001284                           230      
00001284  2602                     231          MOVE.L  D2,D3       *copy instruction word
00001286  0243 00FF                232          ANDI.W  #Byte0Mask,D3 * isolate right most byte
0000128A                           233          
0000128A  0C03 0071                234          CMPI.B  #$71,D3     * test for NOP
0000128E  6700 000E                235          BEQ     load_NOP
00001292  0C03 0075                236          CMPI.B  #$75, D3    * test for RTS
00001296  6700 0016                237          BEQ     load_RTS
0000129A                           238              
0000129A  6000 FEEC                239          BRA     OP_ERR  * return to error decoding
0000129E                           240  
0000129E                           241  load_NOP:   * load and print NOP neumonic return to op loop
0000129E  43F9 00001AEE            242          LEA     _NOP,A1
000012A4  4EB9 0000196A            243          JSR     WRITE_ASCII
000012AA  6000 FEE2                244          BRA     DECODE_DONE
000012AE                           245          
000012AE                           246  load_RTS:   * load and print RTS neumonic return to op loop
000012AE  43F9 00001AF2            247          LEA     _RTS,A1
000012B4  4EB9 0000196A            248          JSR     WRITE_ASCII
000012BA  6000 FED2                249          BRA     DECODE_DONE
000012BE                           250          
000012BE                           251  load_LEA:   * load and print LEA neumonic return to op loop
000012BE  43F9 00001B2F            252          LEA     _LEA,A1
000012C4  4EB9 0000196A            253          JSR     WRITE_ASCII
000012CA  6000 FEC2                254          BRA     DECODE_DONE
000012CE                           255          
000012CE                           256  load_JSR:   * load and print JSR neumonic return to op loop
000012CE  43F9 00001B2B            257          LEA     _JSR,A1
000012D4  4EB9 0000196A            258          JSR     WRITE_ASCII
000012DA  6000 FEB2                259          BRA     DECODE_DONE
000012DE                           260          
000012DE                           261  load_MOVEM_W:   * load and print MOVEM.W neumonic return to op loop
000012DE  43F9 00001AF6            262          LEA     _MOVEM_W,A1
000012E4  4EB9 0000196A            263          JSR     WRITE_ASCII
000012EA  6000 FEA2                264          BRA     DECODE_DONE
000012EE                           265          
000012EE                           266  load_MOVEM_L:   * load and print MOVEM.L neumonic return to op loop
000012EE  43F9 00001AFE            267          LEA     _MOVEM_L,A1
000012F4  4EB9 0000196A            268          JSR     WRITE_ASCII
000012FA  6000 FE92                269          BRA     DECODE_DONE
000012FE                           270  
000012FE                           271  load_ADDQ:  * load and print ADDQ neumonic return to op loop
000012FE  43F9 00001B33            272          LEA     _ADDQ,A1
00001304  4EB9 0000196A            273          JSR     WRITE_ASCII
0000130A  6000 FE82                274          BRA     DECODE_DONE
0000130E                           275          
0000130E                           276  OP_6:   * could be BRA, BEQ, BGT, BLE
0000130E  2602                     277          MOVE.L  D2,D3   * copy instruction word
00001310  0243 0F00                278          ANDI.W  #Nib2Mask,D3
00001314  0C43 0000                279          CMPI.W  #$0000,D3   * if nibble 2 is 0, instruction is BRA
00001318  6700 001A                280          BEQ     load_BRA
0000131C  0C43 0700                281          CMPI.W  #$0700,D3   * if nibble 2 is 7, instruction is BEQ
00001320  6700 0022                282          BEQ     load_BEQ
00001324  0C43 0E00                283          CMPI.W  #$0E00,D3   * if nibble 2 is E, instruction is BGT
00001328  6700 002A                284          BEQ     load_BGT
0000132C  0C43 0F00                285          CMPI.W  #$0F00,D3   * if nibble 2 is F, instruction is BLE
00001330  6700 0032                286          BEQ     load_BLE
00001334                           287          
00001334                           288  load_BRA:   * load and print BRA neumonic return to op loop
00001334  43F9 00001B38            289          LEA     _BRA,A1
0000133A  4EB9 0000196A            290          JSR     WRITE_ASCII
00001340  6000 FE4C                291          BRA     DECODE_DONE
00001344                           292          
00001344                           293  load_BEQ:   * load and print BEQ neumonic return to op loop
00001344  43F9 00001B3C            294          LEA     _BEQ,A1
0000134A  4EB9 0000196A            295          JSR     WRITE_ASCII
00001350  6000 FE3C                296          BRA     DECODE_DONE
00001354                           297  
00001354                           298  load_BGT:   * load and print BGT neumonic return to op loop
00001354  43F9 00001B40            299          LEA     _BGT,A1
0000135A  4EB9 0000196A            300          JSR     WRITE_ASCII
00001360  6000 FE2C                301          BRA     DECODE_DONE
00001364                           302          
00001364                           303  load_BLE:   * load and print BLE neumonic return to op loop
00001364  43F9 00001B44            304          LEA     _BLE,A1
0000136A  4EB9 0000196A            305          JSR     WRITE_ASCII
00001370  6000 FE1C                306          BRA     DECODE_DONE
00001374                           307          
00001374                           308  load_MOVEQ: * load and print MOVEQ neumonic return to op loop
00001374  43F9 00001B48            309          LEA     _MOVEQ,A1
0000137A  4EB9 0000196A            310          JSR     WRITE_ASCII
00001380  6000 FE0C                311          BRA     DECODE_DONE
00001384                           312          
00001384                           313  OP_8:       * could be DIVU or OR
00001384  2602                     314          MOVE.L  D2,D3       * copy instruction word
00001386  0243 01C0                315          ANDI.W  #Bit1Mask,D3   * mask, isolate distinguishing bits 8-6
0000138A  0C43 00C0                316          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is DIVU
0000138E  6700 000A                317          BEQ     load_DIVU
00001392  0C43 00C0                318          CMPI.W  #$00C0,D3       * if bits 8-6 are NOT 011, instruction is OR
00001396  6600 0012                319          BNE     load_OR
0000139A                           320  
0000139A                           321  load_DIVU:  * load and print DIVU neumonic return to op loop
0000139A  43F9 00001B4E            322          LEA     _DIVU,A1
000013A0  4EB9 0000196A            323          JSR     WRITE_ASCII
000013A6  6000 FDE6                324          BRA     DECODE_DONE
000013AA                           325          
000013AA                           326  load_OR:    * load and print DIVU neuomnic return to op loop
000013AA  43F9 00001B53            327          LEA     _OR,A1
000013B0  4EB9 0000196A            328          JSR     WRITE_ASCII
000013B6  6000 FDD6                329          BRA     DECODE_DONE
000013BA                           330  
000013BA                           331  load_SUB:   * load and print SUB neumonic return to op loop
000013BA  43F9 00001B56            332          LEA     _SUB,A1
000013C0  4EB9 0000196A            333          JSR     WRITE_ASCII
000013C6  6000 FDC6                334          BRA     DECODE_DONE
000013CA                           335  
000013CA                           336  OP_C:       * could be MULS or AND
000013CA  2602                     337          MOVE.L  D2,D3       * copy instruction word
000013CC  0243 01C0                338          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000013D0  0C43 01C0                339          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is MULS
000013D4  6700 000A                340          BEQ     load_MULS
000013D8  0C43 01C0                341          CMPI.W  #$01C0,D3       * if bits 8-6 are NOT 111, instruction is AND
000013DC  6600 0012                342          BNE     load_AND
000013E0                           343          
000013E0                           344  load_MULS:  * load and print MULS neumonic return to op loop
000013E0  43F9 00001B5A            345          LEA     _MULS,A1
000013E6  4EB9 0000196A            346          JSR     WRITE_ASCII
000013EC  6000 FDA0                347          BRA     DECODE_DONE
000013F0                           348          
000013F0                           349  load_AND:   * load and print AND neumonic return to op loop
000013F0  43F9 00001B5F            350          LEA     _AND,A1
000013F6  4EB9 0000196A            351          JSR     WRITE_ASCII
000013FC  6000 FD90                352          BRA     DECODE_DONE
00001400                           353  
00001400                           354  OP_D:       * could be ADD or ADDA
00001400  2602                     355          MOVE.L  D2,D3       * copy instruction word
00001402  0243 01C0                356          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 (opmode but distinguishes instr.)
00001406  0C43 00C0                357          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ADDA
0000140A  6700 000E                358          BEQ     load_ADDA
0000140E  0C43 01C0                359          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is also ADDA
00001412  6700 0006                360          BEQ     load_ADDA
00001416  6600 0012                361          BNE     load_ADD        * if bits 8-6 are not either, instruction is ADD
0000141A                           362          
0000141A                           363  load_ADDA:  * load and print ADDA neumonic return to op loop
0000141A  43F9 00001B67            364          LEA     _ADDA,A1
00001420  4EB9 0000196A            365          JSR     WRITE_ASCII
00001426  6000 FD66                366          BRA     DECODE_DONE
0000142A                           367  
0000142A                           368  load_ADD:   * load and print ADD neumonic return to op loop
0000142A  43F9 00001B63            369          LEA     _ADD,A1
00001430  4EB9 0000196A            370          JSR     WRITE_ASCII
00001436  6000 FD56                371          BRA     DECODE_DONE
0000143A                           372  
0000143A                           373  OP_E:       * could be ASL, ASR, LSL, LSR (memory or register)
0000143A  2602                     374          MOVE.L  D2,D3       * copy instruction word
0000143C  0283 FFFF00FF            375          ANDI.L  #$FFFF00FF,D3   * mask, isolate bits 7-6
00001442  0C43 00C0                376          CMPI.W  #$00C0,D3       * if bits 7-6 are 11, instruction is MEMORY shift
00001446  6700 000A                377          BEQ     MEMORY_shift
0000144A  0C43 00C0                378          CMPI.W  #$00C0,D3       * if bits 7-6 are NOT 11, instruction is REG shift
0000144E  6600 0084                379          BNE     REG_shift
00001452                           380          
00001452                           381  MEMORY_shift:   * could be ASL, ASR, LSL, LSR (memory)
00001452  2602                     382          MOVE.L  D2,D3       * copy instruction word
00001454  0243 0E00                383          ANDI.W  #Bit0Mask,D3    * mask, isolate bits 11-9
00001458  0C43 0000                384          CMPI.W  #$0000,D3       * if bits 11-9 are 000, instruction is ASL or ASR (memory)
0000145C  6700 000A                385          BEQ     ASL_ASR_MEM
00001460  0C43 0200                386          CMPI.W  #$0200,D3       * if bits 11-9 are 001, instruction is LSL or LSR (memory)
00001464  6700 0038                387          BEQ     LSL_LSR_MEM
00001468                           388          
00001468                           389  ASL_ASR_MEM:    * could be ASL or ASR (memory)
00001468  2602                     390          MOVE.L  D2,D3       * copy instruction word
0000146A  0243 01C0                391          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
0000146E  0C43 00C0                392          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ASR memory
00001472  6700 000A                393          BEQ     load_ASR_MEM
00001476  0C43 01C0                394          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is ASL memory
0000147A  6700 0012                395          BEQ     load_ASL_MEM
0000147E                           396          
0000147E                           397  load_ASR_MEM:   * load and print ASR neumonic return to op loop
0000147E  43F9 00001B70            398          LEA     _ASR,A1
00001484  4EB9 0000196A            399          JSR     WRITE_ASCII
0000148A  6000 FD02                400          BRA     DECODE_DONE
0000148E                           401          
0000148E                           402  load_ASL_MEM:   * load and print ASL neumonic return to op loop
0000148E  43F9 00001B6C            403          LEA     _ASL,A1
00001494  4EB9 0000196A            404          JSR     WRITE_ASCII
0000149A  6000 FCF2                405          BRA     DECODE_DONE
0000149E                           406  
0000149E                           407  LSL_LSR_MEM:    * could be LSL or LSR (memory)
0000149E  2602                     408          MOVE.L  D2,D3       * copy instruction word
000014A0  0243 01C0                409          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000014A4  0C43 00C0                410          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is LSR memory
000014A8  6700 000A                411          BEQ     load_LSR_MEM
000014AC  0C43 01C0                412          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LSL memory
000014B0  6700 0012                413          BEQ     load_LSL_MEM 
000014B4                           414          
000014B4                           415  load_LSR_MEM:   * load and print LSR neumonic return to op loop
000014B4  43F9 00001B78            416          LEA     _LSR,A1
000014BA  4EB9 0000196A            417          JSR     WRITE_ASCII
000014C0  6000 FCCC                418          BRA     DECODE_DONE
000014C4                           419          
000014C4                           420  load_LSL_MEM:   * load and print LSL neumonic return to op loop
000014C4  43F9 00001B74            421          LEA     _LSL,A1
000014CA  4EB9 0000196A            422          JSR     WRITE_ASCII
000014D0  6000 FCBC                423          BRA     DECODE_DONE
000014D4                           424  
000014D4                           425  REG_shift:      * could be ASL, ASR, LSL, LSR (register)
000014D4  2602                     426          MOVE.L  D2,D3       * copy instruction word
000014D6  0243 0038                427          ANDI.W  #Bit2Mask,D3    * mask, isolate bits 5-3
000014DA  0C43 0000                428          CMPI.W  #$0000,D3        * if bits 5-3 are 000, instruction is ASL or ASR (reg)
000014DE  6700 001A                429          BEQ     ASL_ASR_REG
000014E2  0C43 0020                430          CMPI.W  #$0020,D3       * if bits 5-3 are 100, instruction is ASL or ASR (reg)
000014E6  6700 0012                431          BEQ     ASL_ASR_REG
000014EA  0C43 0008                432          CMPI.W  #$0008,D3       * if bits 5-3 are 001, instruction is LSL or LSR (reg)
000014EE  6700 0062                433          BEQ     LSL_LSR_REG
000014F2  0C43 0028                434          CMPI.W  #$0028,D3       * if bits 5-3 are 101, instruction is LSL or LSR (reg)
000014F6  6700 005A                435          BEQ     LSL_LSR_REG
000014FA                           436          
000014FA                           437  ASL_ASR_REG:    * could be ASL or ASR (register)
000014FA  2602                     438          MOVE.L  D2,D3       * copy instruction word
000014FC  0283 000001C0            439          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
00001502                           440          
00001502  0C43 0000                441          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ASR register
00001506  6700 002A                442          BEQ     load_ASR_REG
0000150A  0C43 0040                443          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ASR register
0000150E  6700 0022                444          BEQ     load_ASR_REG
00001512  0C43 0080                445          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ASR register
00001516  6700 001A                446          BEQ     load_ASR_REG
0000151A                           447          
0000151A  0C43 0100                448          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is ASL register
0000151E  6700 0022                449          BEQ     load_ASL_REG
00001522  0C43 0140                450          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is ASL register
00001526  6700 001A                451          BEQ     load_ASL_REG
0000152A  0C43 0180                452          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is ASL register
0000152E  6700 0012                453          BEQ     load_ASL_REG
00001532                           454  
00001532                           455  load_ASR_REG:   * load and print ASR neumonic return to op loop
00001532  43F9 00001B70            456          LEA     _ASR,A1
00001538  4EB9 0000196A            457          JSR     WRITE_ASCII
0000153E  6000 FC4E                458          BRA     DECODE_DONE
00001542                           459          
00001542                           460  load_ASL_REG:   * load and print ASL neumonic return to op loop
00001542  43F9 00001B6C            461          LEA     _ASL,A1
00001548  4EB9 0000196A            462          JSR     WRITE_ASCII
0000154E  6000 FC3E                463          BRA     DECODE_DONE
00001552                           464  
00001552                           465  LSL_LSR_REG:    * could be LSL or LSR (register)
00001552  2602                     466          MOVE.L  D2,D3       * copy instruction word
00001554  0283 000001C0            467          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
0000155A                           468          
0000155A  0C43 0000                469          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is LSR register
0000155E  6700 002A                470          BEQ     load_LSR_REG
00001562  0C43 0040                471          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is LSR register
00001566  6700 0022                472          BEQ     load_LSR_REG
0000156A  0C43 0080                473          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is LSR register
0000156E  6700 001A                474          BEQ     load_LSR_REG
00001572                           475          
00001572  0C43 0100                476          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is LSL register
00001576  6700 0022                477          BEQ     load_LSL_REG
0000157A  0C43 0140                478          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is LSL register
0000157E  6700 001A                479          BEQ     load_LSL_REG
00001582  0C43 0180                480          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is LSL register
00001586  6700 0012                481          BEQ     load_LSL_REG
0000158A                           482  
0000158A                           483  load_LSR_REG:   * load and print LSR neumonic return to op loop
0000158A  43F9 00001B78            484          LEA     _LSR,A1
00001590  4EB9 0000196A            485          JSR     WRITE_ASCII
00001596  6000 FBF6                486          BRA     DECODE_DONE
0000159A                           487          
0000159A                           488  load_LSL_REG:   * load and print LSL neumonic return to op loop
0000159A  43F9 00001B74            489          LEA     _LSL,A1
000015A0  4EB9 0000196A            490          JSR     WRITE_ASCII
000015A6  6000 FBE6                491          BRA     DECODE_DONE
000015AA                           492  
000015AA                           493  
000015AA                           494  ****       EA       ****
000015AA                           495  
000015AA                           496  **** FIRST EA COMMAND *********
000015AA                           497  MOVE_EA:
000015AA  2602                     498          MOVE.L  D2,D3           *copy instruction to D3 for register
000015AC  2802                     499          MOVE.L  D2,D4           *copy instruction to D4 for mode
000015AE  0244 0038                500          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
000015B2  0243 0007                501          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register
000015B6  E68C                     502          LSR.L   #3,D4
000015B8  C8FC 0006                503          MULU    #6,D4
000015BC  C6FC 0006                504          MULU    #6,D3
000015C0  43F9 00001602            505          LEA     EA_MODE,A1
000015C6  4EB1 4000                506          JSR     (A1,D4)
000015CA  43F9 00001BA5            507          LEA     _COMMA,A1
000015D0  4EB9 0000196A            508          JSR     WRITE_ASCII
000015D6                           509  
000015D6  4243                     510          CLR     D3
000015D8  4244                     511          CLR     D4 
000015DA                           512  ******* SECOND EA COMMAND **********
000015DA  2602                     513          MOVE.L  D2,D3           *copy instruction to D3 for register
000015DC  2802                     514          MOVE.L  D2,D4           *copy instruction to D4 for modE
000015DE  0243 0E00                515          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
000015E2  0244 01C0                516          ANDI.W  #Bit1Mask,D4    *mask to isolate 3-bit opmode
000015E6  1A3C 0009                517          MOVE.B  #9, D5
000015EA  EA6B                     518          LSR     D5,D3
000015EC  C6FC 0006                519          MULU   #6,D3 
000015F0  EC8C                     520          LSR.L   #6,D4
000015F2  C8FC 0006                521          MULU   #6,D4
000015F6                           522         
000015F6  43F9 00001602            523          LEA     EA_MODE,A1 
000015FC  4EB1 4000                524          JSR     (A1,D4)
00001600  4E75                     525          RTS
00001602                           526  
00001602                           527  
00001602                           528  ******** JUMP TABLE FOR EA MODES *********
00001602                           529  EA_MODE:
00001602  4EF9 00001632            530          JMP     EA000
00001608  4EF9 0000164A            531          JMP     EA001
0000160E  4EF9 00001662            532          JMP     EA010
00001614  4EF9 00001686            533          JMP     EA011
0000161A  4EF9 000016AA            534          JMP     EA100
00001620  4EF9 000016CE            535          JMP     EA101
00001626  4EF9 000016D0            536          JMP     EA110
0000162C  4EF9 000016D2            537          JMP     EA111
00001632                           538  
00001632                           539  EA000:
00001632  43F9 00001B7C            540          LEA     _DR,A1 
00001638  4EB9 0000196A            541          JSR     WRITE_ASCII
0000163E  43F9 000016D4            542          LEA     EA_REG,A1
00001644  4EB1 3000                543          JSR     (A1,D3)
00001648  4E75                     544          RTS     
0000164A                           545  EA001:
0000164A  43F9 00001B7E            546          LEA     _AR,A1 
00001650  4EB9 0000196A            547          JSR     WRITE_ASCII
00001656  43F9 000016D4            548          LEA     EA_REG,A1
0000165C  4EB1 3000                549          JSR     (A1,D3)
00001660  4E75                     550          RTS     
00001662                           551  EA010:
00001662  43F9 00001B80            552          LEA     _IND_AR1,A1 
00001668  4EB9 0000196A            553          JSR     WRITE_ASCII
0000166E  43F9 000016D4            554          LEA     EA_REG,A1
00001674  4EB1 3000                555          JSR     (A1,D3)
00001678  43F9 00001B83            556          LEA     _IND_AR2,A1
0000167E  4EB9 0000196A            557          JSR     WRITE_ASCII
00001684  4E75                     558          RTS     
00001686                           559      
00001686                           560  EA011:
00001686  43F9 00001B85            561          LEA     _AR_POST1,A1 
0000168C  4EB9 0000196A            562          JSR     WRITE_ASCII
00001692  43F9 000016D4            563          LEA     EA_REG,A1
00001698  4EB1 3000                564          JSR     (A1,D3)
0000169C  43F9 00001B88            565          LEA     _AR_POST2,A1
000016A2  4EB9 0000196A            566          JSR     WRITE_ASCII
000016A8  4E75                     567          RTS
000016AA                           568       
000016AA                           569      
000016AA                           570  EA100:
000016AA  43F9 00001B8B            571          LEA     _AR_PRE1,A1 
000016B0  4EB9 0000196A            572          JSR     WRITE_ASCII
000016B6  43F9 000016D4            573          LEA     EA_REG,A1
000016BC  4EB1 3000                574          JSR     (A1,D3)
000016C0  43F9 00001B8F            575          LEA     _AR_PRE2,A1
000016C6  4EB9 0000196A            576          JSR     WRITE_ASCII
000016CC  4E75                     577          RTS   
000016CE                           578  
000016CE  4E75                     579  EA101:  RTS
000016D0                           580  
000016D0  4E75                     581  EA110:  RTS 
000016D2                           582  
000016D2  4E75                     583  EA111:  RTS 
000016D4                           584      
000016D4                           585  
000016D4                           586  ********* JUMP TABLE FOR REGISTERS ******
000016D4                           587  EA_REG:
000016D4  4EF9 00001704            588          JMP     REG000
000016DA  4EF9 00001712            589          JMP     REG001
000016E0  4EF9 00001720            590          JMP     REG010
000016E6  4EF9 0000172E            591          JMP     REG011
000016EC  4EF9 0000173C            592          JMP     REG100
000016F2  4EF9 0000174A            593          JMP     REG101
000016F8  4EF9 00001758            594          JMP     REG110
000016FE  4EF9 00001766            595          JMP     REG111
00001704                           596  
00001704                           597  REG000:
00001704  43F9 00001B95            598          LEA     _ZERO,A1 
0000170A  4EB9 0000196A            599          JSR     WRITE_ASCII
00001710  4E75                     600          RTS   
00001712                           601  REG001:
00001712  43F9 00001B97            602          LEA     _ONE,A1 
00001718  4EB9 0000196A            603          JSR     WRITE_ASCII
0000171E  4E75                     604          RTS   
00001720                           605  REG010:
00001720  43F9 00001B99            606          LEA     _TWO,A1 
00001726  4EB9 0000196A            607          JSR     WRITE_ASCII
0000172C  4E75                     608          RTS   
0000172E                           609  REG011:
0000172E  43F9 00001B9B            610          LEA     _THREE,A1 
00001734  4EB9 0000196A            611          JSR     WRITE_ASCII
0000173A  4E75                     612          RTS   
0000173C                           613  REG100:
0000173C  43F9 00001B9D            614          LEA     _FOUR,A1 
00001742  4EB9 0000196A            615          JSR     WRITE_ASCII
00001748  4E75                     616          RTS   
0000174A                           617  REG101:
0000174A  43F9 00001B9F            618          LEA     _FIVE,A1 
00001750  4EB9 0000196A            619          JSR     WRITE_ASCII
00001756  4E75                     620          RTS   
00001758                           621  REG110:
00001758  43F9 00001BA1            622          LEA     _SIX,A1 
0000175E  4EB9 0000196A            623          JSR     WRITE_ASCII
00001764  4E75                     624          RTS   
00001766                           625  REG111:
00001766  43F9 00001BA3            626          LEA     _SEVEN,A1 
0000176C  4EB9 0000196A            627          JSR     WRITE_ASCII
00001772  4E75                     628          RTS   
00001774                           629    
00001774                           630   
00001774                           631  ***       UTILS     ****
00001774                           632  * prompts user for choice
00001774                           633  * sets d6 to valid choice
00001774                           634  GET_CHOICE: 
00001774  48E7 C040                635          MOVEM.L   D0/D1/A1,-(SP)
00001778                           636  HC_INT_LP:
00001778  4EB9 000019D8            637          JSR     RESET_BUF_PTR   * move a4 to start of string buffer
0000177E  43F9 00001C35            638          LEA     CHOICE_PROMPT,A1
00001784  4EB9 0000196A            639          JSR     WRITE_ASCII
0000178A  4EB9 000019B0            640          JSR     TERM_PNT_RST_BUF
00001790  103C 0004                641          MOVE.B  #4,D0   * read a number from keyboard into d1
00001794  4E4F                     642          TRAP    #15
00001796                           643  CHOICE_1:
00001796  0C41 0001                644          CMPI    #DISSASEMBLE ,D1
0000179A  6700 0024                645          BEQ     CHOICE_DNE    
0000179E                           646  CHOICE_2:
0000179E  0C41 0002                647          CMPI    #QUIT_PROG,D1
000017A2  6700 001C                648          BEQ     CHOICE_DNE    
000017A6                           649  CHOICE_ERR:
000017A6  43F9 00001C8A            650          LEA     INV_CHOICE,A1
000017AC  4EB9 0000196A            651          JSR     WRITE_ASCII
000017B2  4EB9 000019B0            652          JSR     TERM_PNT_RST_BUF
000017B8  4EB9 000017C8            653          JSR     WAIT_USR_INPUT
000017BE  60B8                     654          BRA     HC_INT_LP
000017C0                           655          
000017C0                           656  CHOICE_DNE:
000017C0  1C01                     657          MOVE.B  D1,D6
000017C2  4CDF 0203                658          MOVEM.L   (SP)+,D0/D1/A1
000017C6  4E75                     659          RTS               
000017C8                           660  
000017C8                           661  * prompt user to press enter to continue
000017C8                           662  WAIT_USR_INPUT:            
000017C8  48E7 C040                663          MOVEM.L   D0/D1/A1,-(SP)
000017CC  43F9 00001CA5            664          LEA     ENT_TO_CONT,A1  * load and print prompt
000017D2  4EB9 00001908            665          JSR     PRINT_A1
000017D8  7005                     666          MOVEQ.L #5,D0   * read in a char from keyboard
000017DA  4E4F                     667          TRAP    #15
000017DC  4CDF 0203                668          MOVEM.L   (SP)+,D0/D1/A1
000017E0  4E75                     669          RTS
000017E2                           670  
000017E2                           671  LOAD_DATA_STR_INTO_BUF: * expects address to be in a5
000017E2  48E7 4000                672          MOVEM.L   D1,-(SP)
000017E6  4EB9 000019D8            673          JSR     RESET_BUF_PTR
000017EC  220D                     674          MOVE.L  A5,D1
000017EE  7A20                     675          MOVEQ   #32,D5   * set hex length to long for address
000017F0  4EB9 00001918            676          JSR     WRITE_HEX_TO_ASCII * write memory address to buffer
000017F6  4EB9 00001994            677          JSR     WRITE_TAB_A4    * wrtie a tab
000017FC  43F9 00001E5A            678          LEA     DATA_MSG,A1     * Load template for data
00001802  4EB9 0000196A            679          JSR     WRITE_ASCII     * write 'DATA    $' to buffer
00001808  3215                     680          MOVE.W  (A5),D1   * load address contents of memory to d1 for printing
0000180A  7A00                     681          MOVEQ   #0,D5   * set hex length to word for memory contents
0000180C  4EB9 00001918            682          JSR     WRITE_HEX_TO_ASCII * save to buffer
00001812  4CDF 0002                683          MOVEM.L   (SP)+,D1
00001816  4E75                     684          RTS
00001818                           685  
00001818  103C 0009                686  DONE    MOVE.B  #9,D0       * Trap task 9 halt simulator
0000181C  4E4F                     687          TRAP    #15
0000181E                           688          
0000181E                           689  * Converts ASCII string containing chars 0-9 and A-F uppercase to hexidecimal number
0000181E                           690  * returns result in D6
0000181E                           691  TO_HEX
0000181E  48E7 E060                692          MOVEM.L   D0-D2/A1-A2,-(SP)   * save state of registers to be changed
00001822  4282                     693          CLR.L   D2      * clear to hold digit magnitude
00001824  4286                     694          CLR.L   D6      * clear to hold result
00001826  5341                     695          SUBI    #1,D1    * subtract 1
00001828  C2FC 0004                696          MULU    #4,D1   * multiply length by four to get length in binary
0000182C                           697          
0000182C                           698  TO_HEX_INTERNAL:
0000182C  1019                     699          MOVE.B  (A1)+,D0     * Load char at A1 into D0
0000182E  6700 001A                700          BEQ     END_H       * GOTO end if byte is zero (null terminated)
00001832  0C40 0039                701          CMPI    #$39,D0     * compare char value to 39
00001836  6F00 0004                702          BLE     _0_9        * GOTO 0_9 if <= 39
0000183A  5F00                     703  A_F     SUBI.B  #$7,D0      * Subtract 7 from D0) for ASCII A-F
0000183C  0200 000F                704  _0_9    ANDI.B  #$0F,D0     * AND with 00001111 to isolate left most 4 bits, converts to hex
00001840  2400                     705          MOVE.L  D0,D2        * put hex digit in D2
00001842  E3AA                     706          LSL.L   D1,D2       * shift hex digit final postion    
00001844  DC82                     707          ADD.L   D2,D6       * add to hex result
00001846  5981                     708          SUBI.L    #4,D1       * subract one hex digit of bits from remaining length 
00001848  60E2                     709          BRA     TO_HEX_INTERNAL   * convert next byte
0000184A  4CDF 0607                710  END_H   MOVEM.L (SP)+,D0-D2/A1-A2
0000184E  4E75                     711          RTS
00001850                           712  
00001850                           713  
00001850                           714  *   input address to hexadecimal saves output at A1
00001850                           715  IN_ADDR_TO_HEX:
00001850  48E7 0200                716          MOVEM.L   D6,-(SP)
00001854  4EB8 181E                717          JSR     TO_HEX          * else convert to hex
00001858  2286                     718          MOVE.L  D6,(A1)
0000185A  4CDF 0040                719          MOVEM.L   (SP)+,D6
0000185E  4E75                     720          RTS
00001860                           721  
00001860                           722  * check start and end addresses for errors
00001860                           723  CHK_ST_E_ADRS: * sets D5 to 1 if an error has ocurred
00001860  48E7 4800                724          MOVEM.L   D1/D4,-(SP)
00001864  7A00                     725          MOVEQ   #0,D5       * clear error flag
00001866  2439 000019DE            726          MOVE.L  ST_ADDR,D2  * load start address
0000186C  2639 000019EA            727          MOVE.L  E_ADDR,D3   * load end address
00001872                           728          
00001872                           729  LEN_CHK:                    * check address length
00001872  1239 000019F6            730          MOVE.B  ST_LEN,D1   * load start and end address lengths
00001878  1839 000019F7            731          MOVE.B  E_LEN,D4
0000187E                           732          
0000187E  0C01 0008                733          CMPI.B  #8,D1       * check if start addr length is less than or equal to 8
00001882  6F00 000E                734          BLE     E_LEN_CHK   * check end address if no length error
00001886  4EB9 000018C6            735          JSR     PLEN_ERR    * print length error message
0000188C  7A01                     736          MOVEQ   #1,D5       * set error flag
0000188E  6000 0012                737          BRA     ODD_CHK     * skip end length check if start failed
00001892                           738  E_LEN_CHK:
00001892  0C04 0008                739          CMPI.B  #8,D4
00001896  6F00 000A                740          BLE     ODD_CHK     * if no error skip to odd checking
0000189A  4EB9 000018C6            741          JSR     PLEN_ERR    * print length error message
000018A0  7A01                     742          MOVEQ   #1,D5       * set error flag
000018A2                           743  
000018A2                           744  ODD_CHK:                    * check if start address is odd
000018A2  0802 0000                745          BTST.L  #0,D2       * test start addres LSB to see if even
000018A6  6700 000A                746          BEQ     S_GT_E
000018AA  4EB9 000018DC            747          JSR     PODD_ERR    * print odd start address error
000018B0  7A01                     748          MOVEQ   #1,D5       * set error flag
000018B2                           749          
000018B2                           750  S_GT_E:                     * start address greater than or less than end
000018B2  B881                     751          CMP.L   D1,D4       * check if end is greater than or equal to start
000018B4  6C00 000A                752          BGE     CHK_SEA_DONE   * skip to end if no error
000018B8  4EB9 000018F2            753          JSR     PS_GT_ERR   * print start greater than end error
000018BE  7A01                     754          MOVEQ   #1,D5       * set error flag
000018C0                           755        
000018C0                           756  CHK_SEA_DONE:
000018C0  4CDF 0012                757          MOVEM.L   (SP)+,D1/D4
000018C4  4E75                     758          RTS             
000018C6                           759          
000018C6                           760  *   print address length input error
000018C6                           761  PLEN_ERR:
000018C6  48E7 0040                762          MOVEM.L   A1,-(SP) 
000018CA  43F9 00001D57            763          LEA     ADR_LEN_ERR,A1   * load address input error message 
000018D0  4EB9 00001908            764          JSR     PRINT_A1
000018D6  4CDF 0200                765          MOVEM.L   (SP)+,A1
000018DA  4E75                     766          RTS         
000018DC                           767  
000018DC                           768  PODD_ERR: * print start address odd error
000018DC  48E7 0040                769          MOVEM.L   A1,-(SP) 
000018E0  43F9 00001D9C            770          LEA     ADR_ODD_ERR,A1
000018E6  4EB9 00001908            771          JSR     PRINT_A1
000018EC  4CDF 0200                772          MOVEM.L   (SP)+,A1
000018F0  4E75                     773          RTS
000018F2                           774  
000018F2                           775  PS_GT_ERR: * print start address greater than end address error
000018F2  48E7 0040                776          MOVEM.L   A1,-(SP) 
000018F6  43F9 00001DD2            777          LEA     ADR_S_GT_E,A1
000018FC  4EB9 00001908            778          JSR     PRINT_A1
00001902  4CDF 0200                779          MOVEM.L   (SP)+,A1
00001906  4E75                     780          RTS
00001908                           781  
00001908                           782   
00001908                           783  PRINT_A1:
00001908  48E7 8000                784          MOVEM.L   D0,-(SP) * save register state
0000190C  103C 000E                785          MOVE.B  #14,D0   * print A1
00001910  4E4F                     786          TRAP    #15
00001912  4CDF 0001                787          MOVEM.L   (SP)+,D0  *  restore register state
00001916  4E75                     788          RTS
00001918                           789  
00001918                           790  ****************************************************
00001918                           791  * Subroutines for printing and writing to and from
00001918                           792  * the string buffer at A4
00001918                           793  ****************************************************        
00001918                           794  
00001918                           795  * d5 is a flag for hex value length d5==32 long is used
00001918                           796  * any other value short is used        
00001918                           797  WRITE_HEX_TO_ASCII: * write hex in d1 to a4 as ascii
00001918                           798          * may need to add case to handle sign extended shorts
00001918  48E7 3800                799          MOVEM.L   D2-D4,-(SP)
0000191C  2401                     800          MOVE.L  D1,D2   * copy input to working temp var
0000191E  0C85 00000020            801          CMPI.L  #32,D5           * if masked value is 0 there is no value in long portion of register for unsigned ints
00001924  6600 000E                802          BNE     h_short         * if not 32 hex value is short else long
00001928                           803          * setup params for long processing
00001928  263C F0000000            804          MOVE.L  #$F0000000,D3   * init mask for isolating first long hex most significand digit
0000192E  781C                     805          MOVE.L  #28,D4          * init shift value for first long hex MSD
00001930  6000 000A                806          BRA     h_a_loop
00001934                           807          
00001934                           808  h_short: * setup params for short processing
00001934  263C 0000F000            809          MOVE.L  #$F000,D3   * init mask for isolating first short hex most significand digit
0000193A  780C                     810          MOVE.L  #12,D4      * init shift value for first short hex MSD
0000193C                           811          
0000193C                           812  h_a_loop:
0000193C  0C84 00000000            813          CMPI.L  #0,D4   * compare shift value to 0
00001942  6D00 0020                814          BLT     h_a_dne * done if less than 0
00001946  2401                     815          MOVE.L  D1,D2   * copy input to working temp var
00001948  C483                     816          AND.L   D3,D2   * isolate digit
0000194A  E8AA                     817          LSR.L   D4,D2   * shift to rightmost position
0000194C                           818          
0000194C  0C82 0000000A            819          CMPI.L  #$A,D2   * compare to A
00001952  6D00 0004                820          BLT     h_a_low  * if less than A 0-9
00001956  5E42                     821          ADDI    #7,D2    * add an additional 7 to A-F     
00001958                           822  h_a_low:
00001958  0642 0030                823          ADDI    #$30,D2  * add $30 to convert to ascii
0000195C  18C2                     824          MOVE.B  D2,(A4)+ * write digit to pointer location
0000195E                           825          
0000195E  E88B                     826          LSR.L   #4,D3   * shift mask to isolate next hex digit
00001960  5984                     827          SUBI.L  #4,D4   * subtract shift for next digit
00001962  60D8                     828          BRA     h_a_loop    * return to loop start
00001964  4CDF 001C                829  h_a_dne MOVEM.L   (SP)+,D2-D4
00001968  4E75                     830          RTS
0000196A                           831  
0000196A                           832  WRITE_ASCII:    * copies null terminated string from A1 to A4 without null
0000196A  48E7 4040                833          MOVEM.L   D1/A1,-(SP)
0000196E                           834  w_a_loop:
0000196E  1219                     835          MOVE.B  (A1)+,D1    * load value at A1
00001970  6700 0006                836          BEQ     w_a_done    * if 0(null) is moved copy is done
00001974  18C1                     837          MOVE.B  D1,(A4)+    * else copy value to A4
00001976  60F6                     838          BRA     w_a_loop
00001978                           839  w_a_done:
00001978  4CDF 0202                840          MOVEM.L   (SP)+,D1/A1
0000197C  4E75                     841          RTS
0000197E                           842  
0000197E                           843  WRITE_NULL_A4: * used to terminate a string in memory 
0000197E  18FC 0000                844          MOVE.B  #0,(A4)+
00001982  4E75                     845          RTS
00001984                           846          
00001984                           847  WRITE_SPC_A4: * writes an ascii space at a4
00001984  18FC 0020                848          MOVE.B  #SPACE,(A4)+
00001988  4E75                     849          RTS 
0000198A                           850  
0000198A                           851  WRITE_NL_A4: * writes a newline at a4
0000198A  18FC 000D                852          MOVE.B  #CR,(A4)+
0000198E  18FC 000A                853          MOVE.B  #LF,(A4)+
00001992  4E75                     854          RTS
00001994                           855          
00001994                           856  WRITE_TAB_A4:
00001994  18FC 0009                857          MOVE.B  #TAB,(A4)+
00001998  4E75                     858          RTS   
0000199A                           859  
0000199A                           860  NL_TERM_PNT_RST_BUF: * write newline, null then print contents then reset bufffer
0000199A  4EB8 198A                861          JSR     WRITE_NL_A4
0000199E  4EB8 197E                862          JSR     WRITE_NULL_A4
000019A2  4EB9 000019C2            863          JSR     PRINT_STR_BUF
000019A8  4EB9 000019D8            864          JSR     RESET_BUF_PTR
000019AE  4E75                     865          RTS
000019B0                           866          
000019B0                           867  TERM_PNT_RST_BUF: * write null then print contents then reset bufffer pointer
000019B0  4EB8 197E                868          JSR     WRITE_NULL_A4
000019B4  4EB9 000019C2            869          JSR     PRINT_STR_BUF
000019BA  4EB9 000019D8            870          JSR     RESET_BUF_PTR
000019C0  4E75                     871          RTS
000019C2                           872          
000019C2                           873  PRINT_STR_BUF: * prints string buffer contents to console
000019C2  48E7 8040                874          MOVEM.L   D0/A1,-(SP)
000019C6  43F9 000019F9            875          LEA     STR_BUF,A1  * load string buffer
000019CC  303C 000E                876          MOVE    #14,D0       * print contents
000019D0  4E4F                     877          TRAP    #15
000019D2  4CDF 0201                878          MOVEM.L   (SP)+,D0/A1
000019D6  4E75                     879          RTS
000019D8                           880  
000019D8                           881  RESET_BUF_PTR:  * sets a4 to start of string buffer
000019D8  387C 19F9                882          MOVEA   #STR_BUF,A4
000019DC  4E75                     883          RTS        
000019DE                           884  
000019DE                           885  ****    VARS    ****
000019DE                           886  ST_ADDR DS.L    3   * allocate 3 longs for address ascii input needs 9 bytes to get 8 chars 
000019EA                           887  E_ADDR  DS.L    3   * and null terminator, allocating 12 bytes to account for this
000019F6= 00                       888  ST_LEN  DCB.B   1,0 * var to track start address length
000019F7= 01 00                    889  E_LEN   DC.B    1,0 * var to track end address length
000019F9= 00 00 00 00 00 00 ...    890  STR_BUF DCB.B   241,0  * buffer to hold 240 chars + null terminator. 3 80 char lines
00001AEA                           891           
00001AEA                           892  ****    CONST   ****
00001AEA  =0000000D                893  CR          EQU     $0D     * carraige return          
00001AEA  =0000000A                894  LF          EQU     $0A     * line feed
00001AEA  =00000020                895  SPACE       EQU     $20     * ascii space
00001AEA  =00000009                896  TAB         EQU     $09     * ascii tab character
00001AEA  =00000001                897  DISSASEMBLE EQU     $01     * dissasemble choice number
00001AEA  =00000002                898  QUIT_PROG   EQU     $02     * quit choice number
00001AEA                           899  
00001AEA                           900  * masks for isolating nibbles with and 0 being least significant nibble
00001AEA  =0000F000                901  Nib3Mask    EQU     $F000 
00001AEA  =00000F00                902  Nib2Mask    EQU     $0F00
00001AEA  =000000F0                903  Nib1Mask    EQU     $00F0
00001AEA  =0000000F                904  Nib0Mask    EQU     $000F
00001AEA                           905  
00001AEA  =00000E00                906  Bit0Mask    EQU     $0E00
00001AEA  =000001C0                907  Bit1Mask    EQU     $01C0
00001AEA  =00000038                908  Bit2Mask    EQU     $0038
00001AEA  =00000007                909  Bit3Mask    EQU     $0007
00001AEA                           910  
00001AEA  =000000FF                911  Byte0Mask   EQU     $00FF
00001AEA  =0000FF00                912  Byte1Mask   EQU     $FF00
00001AEA                           913  
00001AEA                           914  ****    Instructions    ****
00001AEA= 4E 4F 54 00              915  _NOT    DC.B    'NOT',0
00001AEE= 4E 4F 50 00              916  _NOP    DC.B    'NOP',0
00001AF2= 52 54 53 00              917  _RTS    DC.B    'RTS',0
00001AF6                           918  
00001AF6= 4D 4F 56 45 4D 2E ...    919  _MOVEM_W DC.B   'MOVEM.W',0
00001AFE= 4D 4F 56 45 4D 2E ...    920  _MOVEM_L DC.B   'MOVEM.L',0
00001B06                           921  
00001B06= 4D 4F 56 45 2E 42 00     922  _MOVE_B DC.B    'MOVE.B',0
00001B0D= 4D 4F 56 45 2E 4C 00     923  _MOVE_L DC.B    'MOVE.L',0
00001B14= 4D 4F 56 45 2E 57 00     924  _MOVE_W DC.B    'MOVE.W',0
00001B1B= 4D 4F 56 45 41 2E ...    925  _MOVEA_L DC.B   'MOVEA.L',0
00001B23= 4D 4F 56 45 41 2E ...    926  _MOVEA_W DC.B   'MOVEA.W',0
00001B2B= 4A 53 52 00              927  _JSR    DC.B    'JSR',0
00001B2F= 4C 45 41 00              928  _LEA    DC.B    'LEA',0
00001B33= 41 44 44 51 00           929  _ADDQ   DC.B    'ADDQ',0
00001B38= 42 52 41 00              930  _BRA    DC.B    'BRA',0
00001B3C= 42 45 51 00              931  _BEQ    DC.B    'BEQ',0
00001B40= 42 47 54 00              932  _BGT    DC.B    'BGT',0
00001B44= 42 4C 45 00              933  _BLE    DC.B    'BLE',0
00001B48= 4D 4F 56 45 51 00        934  _MOVEQ  DC.B    'MOVEQ',0
00001B4E= 44 49 56 55 00           935  _DIVU   DC.B    'DIVU',0
00001B53= 4F 52 00                 936  _OR     DC.B    'OR',0
00001B56= 53 55 42 00              937  _SUB    DC.B    'SUB',0
00001B5A= 4D 55 4C 53 00           938  _MULS   DC.B    'MULS',0
00001B5F= 41 4E 44 00              939  _AND    DC.B    'AND',0
00001B63= 41 44 44 00              940  _ADD    DC.B    'ADD',0
00001B67= 41 44 44 41 00           941  _ADDA   DC.B    'ADDA',0
00001B6C= 41 53 4C 00              942  _ASL    DC.B    'ASL',0
00001B70= 41 53 52 00              943  _ASR    DC.B    'ASR',0
00001B74= 4C 53 4C 00              944  _LSL    DC.B    'LSL',0
00001B78= 4C 53 52 00              945  _LSR    DC.B    'LSR',0
00001B7C                           946  
00001B7C                           947  ****    Modes    ****
00001B7C= 44 00                    948  _DR             DC.B   'D',0
00001B7E= 41 00                    949  _AR             DC.B   'A',0
00001B80= 28 41 00                 950  _IND_AR1        DC.B   '(A',0
00001B83= 29 00                    951  _IND_AR2        DC.B   ')',0
00001B85= 28 41 00                 952  _AR_POST1       DC.B   '(A',0
00001B88= 29 2B 00                 953  _AR_POST2       DC.B   ')+',0
00001B8B= 2D 28 41 00              954  _AR_PRE1        DC.B   '-(A',0
00001B8F= 29 00                    955  _AR_PRE2        DC.B   ')',0
00001B91= 24 00                    956  _ABS            DC.B    '$',0
00001B93= 23 00                    957  _IMD            DC.B    '#',0
00001B95                           958  
00001B95                           959  ****    Numbers    ****
00001B95= 30 00                    960  _ZERO   DC.B    '0',0
00001B97= 31 00                    961  _ONE    DC.B    '1',0
00001B99= 32 00                    962  _TWO    DC.B    '2',0
00001B9B= 33 00                    963  _THREE  DC.B    '3',0
00001B9D= 34 00                    964  _FOUR   DC.B    '4',0
00001B9F= 35 00                    965  _FIVE   DC.B    '5',0
00001BA1= 36 00                    966  _SIX    DC.B    '6',0
00001BA3= 37 00                    967  _SEVEN  DC.B    '7',0
00001BA5= 2C 00                    968  _COMMA  DC.B    ',',0
00001BA7                           969  
00001BA7                           970  ****    MODE CMP VALUES    ****
00001BA7  =00000000                971  cDR             EQU     $0000
00001BA7  =00000040                972  cAR             EQU     $0040
00001BA7  =00000080                973  cIND_AR         EQU     $0080
00001BA7  =000000C0                974  cAR_POST        EQU     $00C0
00001BA7  =00000100                975  cAR_PRE         EQU     $0100
00001BA7  =000001C0                976  cABS            EQU     $01C0
00001BA7                           977  
00001BA7                           978  ****    MESSAGES    ****
00001BA7                           979  
00001BA7= 2A 2A 2A 2A 2A 2A ...    980  WELCOME     DC.B    '*********************************************',CR,LF
00001BD6= 2A 20 57 65 6C 63 ...    981              DC.B    '* Welcome to EASY 68K Disasembler by Nibble *',CR,LF
00001C05= 2A 2A 2A 2A 2A 2A ...    982              DC.B    '*********************************************',CR,LF,0
00001C35                           983              
00001C35                           984  CHOICE_PROMPT:
00001C35= 45 6E 74 65 72 20 ...    985              DC.B    'Enter a number to make a choice:',CR,LF
00001C57= 31 3A 20 44 69 73 ...    986              DC.B    '1: Dissasemble an Address Range',CR,LF
00001C78= 32 3A 20 45 78 69 ...    987              DC.B    '2: Exit Program',CR,LF,0
00001C8A                           988         
00001C8A= 45 52 52 4F 52 3A ...    989  INV_CHOICE  DC.B    'ERROR: INVALID selection',CR,LF,0
00001CA5                           990  
00001CA5= 0D 0A 50 72 65 73 ...    991  ENT_TO_CONT DC.B    CR,LF,'Press enter to continue...',CR,LF,0
00001CC4                           992  
00001CC4= 0D 0A 45 6E 74 65 ...    993  ST_A_MSG    DC.B    CR,LF,'Enter an address range in hexidecimal to be dissasembled',CR,LF * start address message
00001D00= 56 61 6C 69 64 20 ...    994              DC.B    'Valid address chars: 0-1 A-F case insensitive',CR,LF  
00001D2F= 45 6E 74 65 72 20 ...    995              DC.B    'Enter start address:',0    
00001D44                           996              
00001D44= 45 6E 74 65 72 20 ...    997  E_A_MSG     DC.B    'Enter end address:',0    * end address message
00001D57                           998  
00001D57= 0D 0A 45 52 52 4F ...    999  ADR_LEN_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-8 hexidecimal digits long',CR,LF,0    * address input error message
00001D9C                          1000  
00001D9C= 0D 0A 45 52 52 4F ...   1001  ADR_ODD_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must be even',CR,LF,0  * odd input address error message
00001DD2                          1002              
00001DD2= 0D 0A 45 52 52 4F ...   1003  ADR_S_GT_E  DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must come before end address',CR,LF,0 * start greater than end address error msg
00001E18                          1004  
00001E18= 0D 0A 45 52 52 4F ...   1005  HEX_ERR     DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-1 A-F case insensitive',CR,LF,0
00001E5A                          1006    
00001E5A= 44 41 54 41 20 20 ...   1007  DATA_MSG    DC.B    'DATA   $',0
00001E63                          1008  
00001E63= 43 4F 4E 56 45 52 ...   1009  TEST_MSG    DC.B    'CONVERTED ADDRESS IS: ',0  * test message for printing start and end addresses
00001E7A                          1010              
00001E7A                          1011              END     INIT        * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADR_LEN_ERR         1D57
ADR_ODD_ERR         1D9C
ADR_S_GT_E          1DD2
ASL_ASR_MEM         1468
ASL_ASR_REG         14FA
A_F                 183A
BIT0MASK            E00
BIT1MASK            1C0
BIT2MASK            38
BIT3MASK            7
BYTE0MASK           FF
BYTE1MASK           FF00
CABS                1C0
CAR                 40
CAR_POST            C0
CAR_PRE             100
CDR                 0
CHK_LFT_NIB         1122
CHK_SEA_DONE        18C0
CHK_ST_E_ADRS       1860
CHOICE_1            1796
CHOICE_2            179E
CHOICE_DNE          17C0
CHOICE_ERR          17A6
CHOICE_PROMPT       1C35
CIND_AR             80
CR                  D
DATA_MSG            1E5A
DECODE_DONE         118E
DISSASEMBLE         1
DONE                1818
EA000               1632
EA001               164A
EA010               1662
EA011               1686
EA100               16AA
EA101               16CE
EA110               16D0
EA111               16D2
EA_MODE             1602
EA_REG              16D4
END_H               184A
ENT_TO_CONT         1CA5
E_ADDR              19EA
E_A_MSG             1D44
E_LEN               19F7
E_LEN_CHK           1892
GET_CHOICE          1774
HC_INT_LP           1778
HEX_ERR             1E18
H_A_DNE             1964
H_A_LOOP            193C
H_A_LOW             1958
H_SHORT             1934
INIT                1000
INPUT_START         1028
INV_CHOICE          1C8A
IN_ADDR_TO_HEX      1850
LEN_CHK             1872
LF                  A
LOAD_ADD            142A
LOAD_ADDA           141A
LOAD_ADDQ           12FE
LOAD_AND            13F0
LOAD_ASL_MEM        148E
LOAD_ASL_REG        1542
LOAD_ASR_MEM        147E
LOAD_ASR_REG        1532
LOAD_BEQ            1344
LOAD_BGT            1354
LOAD_BLE            1364
LOAD_BRA            1334
LOAD_DATA_STR_INTO_BUF  17E2
LOAD_DIVU           139A
LOAD_JSR            12CE
LOAD_LEA            12BE
LOAD_LSL_MEM        14C4
LOAD_LSL_REG        159A
LOAD_LSR_MEM        14B4
LOAD_LSR_REG        158A
LOAD_MOVEA_L        11CA
LOAD_MOVEA_W        1202
LOAD_MOVEM_L        12EE
LOAD_MOVEM_W        12DE
LOAD_MOVEQ          1374
LOAD_MOVE_B         119E
LOAD_MOVE_L         11D8
LOAD_MOVE_W         1212
LOAD_MULS           13E0
LOAD_NOP            129E
LOAD_NOT            1266
LOAD_OR             13AA
LOAD_RTS            12AE
LOAD_SUB            13BA
LSL_LSR_MEM         149E
LSL_LSR_REG         1552
MEMORY_SHIFT        1452
MOVE_EA             15AA
NIB0MASK            F
NIB1MASK            F0
NIB2MASK            F00
NIB3MASK            F000
NL_TERM_PNT_RST_BUF  199A
NOP_RTS_JSR         1276
ODD_CHK             18A2
OP_2                11B4
OP_3                11EC
OP_4                1228
OP_6                130E
OP_8                1384
OP_C                13CA
OP_CODES            10FE
OP_D                1400
OP_DONE             119C
OP_E                143A
OP_ERR              1188
OP_START            1110
PLEN_ERR            18C6
PODD_ERR            18DC
PRINT_A1            1908
PRINT_STR_BUF       19C2
PS_GT_ERR           18F2
QUIT                10F8
QUIT_PROG           2
REG000              1704
REG001              1712
REG010              1720
REG011              172E
REG100              173C
REG101              174A
REG110              1758
REG111              1766
REG_SHIFT           14D4
RESET_BUF_PTR       19D8
SPACE               20
START               101A
STR_BUF             19F9
ST_ADDR             19DE
ST_A_MSG            1CC4
ST_DIS              1096
ST_LEN              19F6
S_GT_E              18B2
TAB                 9
TERM_PNT_RST_BUF    19B0
TEST_MSG            1E63
TO_HEX              181E
TO_HEX_INTERNAL     182C
WAIT_USR_INPUT      17C8
WELCOME             1BA7
WRITE_ASCII         196A
WRITE_HEX_TO_ASCII  1918
WRITE_NL_A4         198A
WRITE_NULL_A4       197E
WRITE_SPC_A4        1984
WRITE_TAB_A4        1994
W_A_DONE            1978
W_A_LOOP            196E
_0_9                183C
_ABS                1B91
_ADD                1B63
_ADDA               1B67
_ADDQ               1B33
_AND                1B5F
_AR                 1B7E
_AR_POST1           1B85
_AR_POST2           1B88
_AR_PRE1            1B8B
_AR_PRE2            1B8F
_ASL                1B6C
_ASR                1B70
_BEQ                1B3C
_BGT                1B40
_BLE                1B44
_BRA                1B38
_COMMA              1BA5
_DIVU               1B4E
_DR                 1B7C
_FIVE               1B9F
_FOUR               1B9D
_IMD                1B93
_IND_AR1            1B80
_IND_AR2            1B83
_JSR                1B2B
_LEA                1B2F
_LSL                1B74
_LSR                1B78
_MOVEA_L            1B1B
_MOVEA_W            1B23
_MOVEM_L            1AFE
_MOVEM_W            1AF6
_MOVEQ              1B48
_MOVE_B             1B06
_MOVE_L             1B0D
_MOVE_W             1B14
_MULS               1B5A
_NOP                1AEE
_NOT                1AEA
_ONE                1B97
_OR                 1B53
_RTS                1AF2
_SEVEN              1BA3
_SIX                1BA1
_SUB                1B56
_THREE              1B9B
_TWO                1B99
_ZERO               1B95
