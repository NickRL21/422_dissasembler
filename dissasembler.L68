00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/4/2019 5:04:54 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Dissasembler
00000000                             3  * Written by :  Nick, Shelby, and Zoe
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7          ORG     $1000
00001000                             8          
00001000                             9  ****    MAIN LOOP   ****
00001000  4E71                      10  INIT:   NOP     * line for testing
00001002  4EB9 000021F4             11          JSR     RESET_BUF_PTR
00001008  43F9 0000246F             12          LEA     WELCOME,A1      * print welcome message
0000100E  4EB9 0000217E             13          JSR     WRITE_ASCII
00001014  4EB9 000021CC             14          JSR     TERM_PNT_RST_BUF
0000101A                            15          
0000101A                            16  START:  
0000101A  4EB9 00001F88             17          JSR     GET_CHOICE      * get choice from user to dissasemble or quit
00001020  0C46 0002                 18          CMPI    #QUIT_PROG,D6
00001024  6700 0080                 19          BEQ     QUIT
00001028                            20          
00001028                            21  
00001028                            22  INPUT_START:
00001028  43F9 0000258C             23          LEA     ST_A_MSG,A1     * load start address prompt message
0000102E  4EB9 0000217E             24          JSR     WRITE_ASCII     * write to string buffer
00001034  4EB9 000021CC             25          JSR     TERM_PNT_RST_BUF * terminate string buffer and print reseting pointer at A4
0000103A                            26          
0000103A  43F9 000021FA             27          LEA     ST_ADDR,A1 * load start address
00001040  4291                      28          CLR.L   (A1)    * clear long at a1
00001042  103C 0002                 29          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001046  4E4F                      30          TRAP    #15
00001048  13C1 0000221A             31          MOVE.B  D1,ST_LEN    * save start length to memory 
0000104E                            32          
0000104E  4EB9 00002064             33          JSR     IN_ADDR_TO_HEX  * convert start address to hex
00001054                            34               
00001054  43F9 0000260C             35          LEA     E_A_MSG,A1      * load end address prompt message
0000105A  4EB9 0000217E             36          JSR     WRITE_ASCII     * print message
00001060  4EB9 000021CC             37          JSR     TERM_PNT_RST_BUF  * print and reset buffer no newline
00001066                            38          
00001066  43F9 00002206             39          LEA     E_ADDR,A1  * load end address
0000106C  4291                      40          CLR.L   (A1)    * clear long at end address
0000106E  103C 0002                 41          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001072  4E4F                      42          TRAP    #15
00001074  13C1 0000221B             43          MOVE.B  D1,E_LEN    * save end length to memory
0000107A                            44          
0000107A  4EB9 00002064             45          JSR     IN_ADDR_TO_HEX  * convert end address to hex
00001080                            46          
00001080  4EB9 00002074             47          JSR     CHK_ST_E_ADRS   * check addresses for errors
00001086  0C05 0001                 48          CMPI.B  #1,D5           * if an error occured return to start
0000108A  6600 000A                 49          BNE     ST_DIS          * branch to dissasembly if no errors
0000108E  4EB9 00001FDC             50          JSR     WAIT_USR_INPUT    
00001094  6092                      51          BRA     INPUT_START     * return to start
00001096                            52          
00001096                            53          * print converted addresses for testing purposes
00001096                            54          
00001096  4EB9 000010AC             55  ST_DIS  JSR     OP_CODES
0000109C                            56          
0000109C  4EB9 000021B6             57          JSR     NL_TERM_PNT_RST_BUF * print newline after op codes
000010A2                            58           
000010A2  6000 FF76                 59          BRA     START 
000010A6                            60  
000010A6                            61  
000010A6  103C 0009                 62  QUIT    MOVE.B  #9,D0
000010AA  4E4F                      63          TRAP    #15 * stop sim
000010AC                            64  
000010AC                            65  
000010AC                            66  ****    OP-CODES    ****
000010AC                            67  OP_CODES:
000010AC  4EB9 000021F4             68          JSR     RESET_BUF_PTR   * reset string buffer pointer
000010B2  2A79 000021FA             69          MOVE.L  ST_ADDR,A5  * load starting address into a5
000010B8  2C79 00002206             70          MOVE.L  E_ADDR,A6   * load ending address into a6
000010BE                            71          
000010BE                            72  OP_START:          
000010BE                            73          * write address and a tab to str buffer
000010BE  220D                      74          MOVE.L  A5,D1   * load address from A5 into D1
000010C0  23C1 00002216             75          MOVE.L  D1,CURRENT_ADDR * save backup of opcode word address
000010C6  7A20                      76          MOVEQ   #32,D5   * set hex length to long for address printing
000010C8  4EB9 0000212C             77          JSR     WRITE_HEX_TO_ASCII
000010CE  4EB9 000021A8             78          JSR     WRITE_TAB_A4
000010D4                            79          
000010D4  3415                      80          MOVE.W (A5),D2 * load word of memory into D1
000010D6                            81  
000010D6                            82          * clear ea mode and register values
000010D6  13FC 0000 00002312        83          MOVE.B #0,SRC_REG
000010DE  13FC 0000 00002310        84          MOVE.B #0,DEST_REG
000010E6  13FC 0000 00002311        85          MOVE.B #0,SRC_MODE
000010EE  13FC 0000 0000230F        86          MOVE.B #0,DEST_MODE
000010F6  23FC 00000000 00002212    87          MOVE.L  #0,END_OP_CODE_PTR * clear end of op-code str buffer pointer
00001100  13FC 0000 00002313        88          MOVE.B  #0,EA_ERR_FLAG * clear ea error flag
00001108                            89          
00001108                            90  CHK_LFT_NIB:
00001108  2602                      91          MOVE.L  D2,D3   * copy to d2
0000110A                            92          
0000110A  0243 F000                 93          ANDI.W  #Nib3Mask,D3 * clear all but left four bits
0000110E  0C43 1000                 94          CMPI.W  #$1000,D3   * if nibble3 == 1, branch to move byte (1)
00001112  6700 0082                 95          BEQ     load_MOVE_B
00001116  0C43 2000                 96          CMPI.W  #$2000,D3   * if nibble3 == 2, branch to that set (move.l, movea.l)
0000111A  6700 00AA                 97          BEQ     OP_2
0000111E  0C43 3000                 98          CMPI.W  #$3000,D3   * if nibble3 == 3, branch to that set (move.w, movea.w)
00001122  6700 0112                 99          BEQ     OP_3              
00001126  0C43 4000                100          CMPI.W  #$4000,D3   * if nibble3 == 4 branch to that set (not/nop/rts/jsr/movem/lea)
0000112A  6700 017A                101          BEQ     OP_4 
0000112E  0C43 5000                102          CMPI.W  #$5000,D3   * if nibble3 == 5, branch to ADDQ (5)
00001132  6700 0320                103          BEQ     ADDQ_
00001136  0C43 6000                104          CMPI.W  #$6000,D3   * if nibble3 == 6, branch to that set (bra, bcc)
0000113A  6700 03A2                105          BEQ     OP_6
0000113E  0C43 7000                106          CMPI.W  #$7000,D3   * if nibble3 == 7, branch to MOVEQ
00001142  6700 041E                107          BEQ     load_MOVEQ
00001146  0C43 8000                108          CMPI.W  #$8000,D3   * if nibble3 == 8, branch to that set (divu, or)
0000114A  6700 042C                109          BEQ     OP_8
0000114E  0C43 9000                110          CMPI.W  #$9000,D3   * if nibble3 == 9, branch to SUB
00001152  6700 047E                111          BEQ     load_SUB
00001156  0C43 C000                112          CMPI.W  #$C000,D3   * if nibble3 == C, branch to that set (muls, and)
0000115A  6700 0498                113          BEQ     OP_C
0000115E  0C43 D000                114          CMPI.W  #$D000,D3   * if nibble3 == D, branch to that set (add, adda)
00001162  6700 04E4                115          BEQ     OP_D
00001166  0C43 E000                116          CMPI.W  #$E000,D3   * if nibble3 == E, branch to that set (asl, asr, lsl, lsr)
0000116A  6700 053A                117          BEQ     OP_E
0000116E                           118                         
0000116E  4EB9 00001FF6            119  OP_ERR  JSR     LOAD_DATA_STR_INTO_BUF   
00001174                           120  
00001174                           121  DECODE_DONE:    * print newline then check if op-code loop is done
00001174  4EB9 000021B6            122          JSR     NL_TERM_PNT_RST_BUF * write newline then print
0000117A  0C39 00FF 00002313       123          CMP.B   #-1,EA_ERR_FLAG
00001182  6600 0008                124          BNE     NO_EA_ERROR
00001186  2A79 00002216            125          MOVEA.L CURRENT_ADDR,A5 * reset curent address if ea error occurred
0000118C                           126   NO_EA_ERROR:
0000118C  548D                     127          ADD.L   #2,A5   * increment current address pointer by 2 bytes 
0000118E  BBCE                     128          CMP.L   A6,A5  * loop if start is less than or equal to end
00001190  6F00 FF2C                129          BLE     OP_START
00001194  4E75                     130  OP_DONE RTS
00001196                           131  
00001196                           132  load_MOVE_B:    * load and print MOVE.B neumonic return to op loop
00001196  43F9 00002345            133          LEA     _MOVE_B,A1
0000119C  4EB9 0000217E            134          JSR     WRITE_ASCII
000011A2  4EB9 000021AE            135          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011A8  13FC 0001 0000230E       136          MOVE.B  #BYTE,INST_SZ   * save instruction size
000011B0  4243                     137          CLR     D3
000011B2  4EB9 0000196E            138          JSR     MOVE_EA
000011B8                           139          **** EA CODE GOES HERE ****
000011B8                           140          * must set unused mode/reg vars to 0
000011B8  4EB9 00001E0E            141          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000011BE  4EB9 00001ED2            142          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000011C4  60AE                     143          BRA     DECODE_DONE
000011C6                           144         
000011C6                           145  OP_2:   * could be MOVE.L or MOVEA.L
000011C6  2602                     146          MOVE.L  D2,D3   * copy instruction word
000011C8  0243 01C0                147          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000011CC  0C43 0040                148          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.L
000011D0  6700 000A                149          BEQ     load_MOVEA_L
000011D4  0C43 0040                150          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.L
000011D8  6600 002C                151          BNE     load_MOVE_L
000011DC                           152          
000011DC                           153  load_MOVEA_L:   * load and print MOVEA.L neumonic return to op loop
000011DC  43F9 0000235D            154          LEA     _MOVEA_L,A1
000011E2  4EB9 0000217E            155          JSR     WRITE_ASCII
000011E8  4EB9 000021AE            156          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011EE  13FC 0002 0000230E       157          MOVE.B  #LONG,INST_SZ   * save instruction size
000011F6                           158           **** EA CODE GOES HERE ****
000011F6  4EB9 0000196E            159          JSR     MOVE_EA
000011FC                           160          * must set unused mode/reg vars to 0
000011FC  4EB9 00001E0E            161          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001202  6000 FF70                162          BRA     DECODE_DONE
00001206                           163  
00001206                           164  load_MOVE_L:    * load and print MOVE.L neumonic return to op loop
00001206  43F9 0000234D            165          LEA     _MOVE_L,A1
0000120C  4EB9 0000217E            166          JSR     WRITE_ASCII
00001212  4EB9 000021AE            167          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001218  13FC 0002 0000230E       168          MOVE.B  #LONG,INST_SZ   * save instruction size
00001220  4EB9 0000196E            169          JSR     MOVE_EA
00001226  4EB9 00001E0E            170          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000122C  4EB9 00001ED2            171          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001232  6000 FF40                172          BRA     DECODE_DONE
00001236                           173          
00001236                           174  OP_3:   * could be MOVE.W or MOVEA.W
00001236  2602                     175          MOVE.L  D2,D3   * copy instruction word
00001238  0243 01C0                176          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
0000123C  0C43 0040                177          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.W
00001240  6700 000A                178          BEQ     load_MOVEA_W
00001244  0C43 0040                179          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.W
00001248  6600 002C                180          BNE     load_MOVE_W
0000124C                           181          
0000124C                           182  load_MOVEA_W:   * load and print MOVEA.W neumonic return to op loop
0000124C  43F9 00002366            183          LEA     _MOVEA_W,A1
00001252  4EB9 0000217E            184          JSR     WRITE_ASCII
00001258  4EB9 000021AE            185          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000125E  13FC 0003 0000230E       186          MOVE.B  #WORD,INST_SZ   * save instruction size
00001266                           187           **** EA CODE GOES HERE ****
00001266  4EB9 0000196E            188          JSR     MOVE_EA
0000126C                           189          * must set unused mode/reg vars to 0
0000126C  4EB9 00001E0E            190          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001272  6000 FF00                191          BRA     DECODE_DONE
00001276                           192  
00001276                           193  load_MOVE_W:    * load and print MOVE.W neumonic return to op loop
00001276  43F9 00002355            194          LEA     _MOVE_W,A1
0000127C  4EB9 0000217E            195          JSR     WRITE_ASCII
00001282  4EB9 000021AE            196          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001288  13FC 0003 0000230E       197          MOVE.B  #WORD,INST_SZ   * save instruction size
00001290  4EB9 0000196E            198          JSR     MOVE_EA
00001296  4EB9 00001E0E            199          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000129C  4EB9 00001ED2            200          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000012A2  6000 FED0                201          BRA     DECODE_DONE
000012A6                           202  
000012A6                           203  OP_4:   * could be not, nop, rts, jsr, MOVEM.L, lea
000012A6  2602                     204          MOVE.L  D2,D3   * copy instruction word
000012A8  0243 0F00                205          ANDI.W  #Nib2Mask,D3
000012AC  0C43 0600                206          CMPI.W  #$0600,D3   * if nibble 2 is 6, instruction is NOT
000012B0  6700 0032                207          BEQ     NOT_
000012B4                           208  
000012B4  0C43 0E00                209          CMPI.W  #$0E00,D3  * if nibble 2 is E could be nop or rts or jsr
000012B8  6700 00C6                210          BEQ     NOP_RTS_JSR
000012BC                           211          
000012BC                           212          * try for LEA
000012BC  2602                     213          MOVE.L  D2,D3
000012BE  0243 01C0                214          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012C2  0C43 01C0                215          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LEA
000012C6  6700 010C                216          BEQ     load_LEA
000012CA                           217          
000012CA                           218          * try for MOVEM.W or MOVEM.L
000012CA  2602                     219          MOVE.L  D2,D3
000012CC  0243 01C0                220          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 for size
000012D0  0C43 0080                221          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is MOVEM.W
000012D4  6700 0136                222          BEQ     load_MOVEM_W
000012D8  0C43 00C0                223          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is MOVEM.L
000012DC  6700 0152                224          BEQ     load_MOVEM_L
000012E0                           225  
000012E0                           226          
000012E0  6000 FE8C                227          BRA     OP_ERR  * return to error decoding
000012E4                           228          
000012E4                           229  NOT_:   * instruction is not, determine size
000012E4  2602                     230          MOVE.L  D2,D3
000012E6  0243 01C0                231          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012EA  0C43 0000                232          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is NOT.B
000012EE  6700 0012                233          BEQ     load_NOT_B
000012F2  0C43 0040                234          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is NOT.W
000012F6  6700 0034                235          BEQ     load_NOT_W
000012FA  0C43 0080                236          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is NOT.L
000012FE  6700 0056                237          BEQ     load_NOT_L
00001302                           238           
00001302                           239         
00001302                           240  load_NOT_B:   * load and print NOT.B neumonic return to op loop
00001302  43F9 00002314            241          LEA     _NOT_B,A1
00001308  4EB9 0000217E            242          JSR     WRITE_ASCII
0000130E  4EB9 000021AE            243          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001314  13FC 0001 0000230E       244          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000131C                           245           **** EA CODE GOES HERE ****
0000131C                           246          * must set unused mode/reg vars to 0
0000131C  4EB9 00001E0E            247          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001322  4EB9 00001ED2            248          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001328  6000 FE4A                249          BRA     DECODE_DONE
0000132C                           250          
0000132C                           251  load_NOT_W:   * load and print NOT.W neumonic return to op loop
0000132C  43F9 0000231B            252          LEA     _NOT_W,A1
00001332  4EB9 0000217E            253          JSR     WRITE_ASCII
00001338  4EB9 000021AE            254          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000133E  13FC 0003 0000230E       255          MOVE.B  #WORD,INST_SZ   * save instruction size
00001346                           256           **** EA CODE GOES HERE ****
00001346                           257          * must set unused mode/reg vars to 0
00001346  4EB9 00001E0E            258          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000134C  4EB9 00001ED2            259          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001352  6000 FE20                260          BRA     DECODE_DONE
00001356                           261          
00001356                           262  load_NOT_L:   * load and print NOT.L neumonic return to op loop
00001356  43F9 00002322            263          LEA     _NOT_L,A1
0000135C  4EB9 0000217E            264          JSR     WRITE_ASCII
00001362  4EB9 000021AE            265          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001368  13FC 0002 0000230E       266          MOVE.B  #LONG,INST_SZ   * save instruction size
00001370                           267           **** EA CODE GOES HERE ****
00001370                           268          * must set unused mode/reg vars to 0
00001370  4EB9 00001E0E            269          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001376  4EB9 00001ED2            270          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
0000137C  6000 FDF6                271          BRA     DECODE_DONE
00001380                           272  
00001380                           273  NOP_RTS_JSR: * could be NOP or RTS or JSR
00001380  2602                     274          MOVE.L  D2,D3
00001382  0243 01C0                275          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001386  0C43 0080                276          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is JSR
0000138A  6700 006A                277          BEQ     load_JSR
0000138E                           278      
0000138E  2602                     279          MOVE.L  D2,D3       *copy instruction word
00001390  0243 00FF                280          ANDI.W  #Byte0Mask,D3 * isolate right most byte
00001394                           281          
00001394  0C03 0071                282          CMPI.B  #$71,D3     * test for NOP
00001398  6700 000E                283          BEQ     load_NOP
0000139C  0C03 0075                284          CMPI.B  #$75, D3    * test for RTS
000013A0  6700 001C                285          BEQ     load_RTS
000013A4                           286              
000013A4  6000 FDC8                287          BRA     OP_ERR  * return to error decoding
000013A8                           288  
000013A8                           289  load_NOP:   * load and print NOP neumonic return to op loop
000013A8  43F9 00002329            290          LEA     _NOP,A1
000013AE  4EB9 0000217E            291          JSR     WRITE_ASCII
000013B4  4EB9 000021AE            292          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013BA  6000 FDB8                293          BRA     DECODE_DONE
000013BE                           294          
000013BE                           295  load_RTS:   * load and print RTS neumonic return to op loop
000013BE  43F9 0000232E            296          LEA     _RTS,A1
000013C4  4EB9 0000217E            297          JSR     WRITE_ASCII
000013CA  4EB9 000021AE            298          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013D0  6000 FDA2                299          BRA     DECODE_DONE
000013D4                           300          
000013D4                           301  load_LEA:   * load and print LEA neumonic return to op loop
000013D4  43F9 00002374            302          LEA     _LEA,A1
000013DA  4EB9 0000217E            303          JSR     WRITE_ASCII
000013E0  4EB9 000021AE            304          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013E6                           305           **** EA CODE GOES HERE ****
000013E6  4EB9 000019DE            306           JSR    LEA_EA
000013EC                           307          * must set unused mode/reg vars to 0
000013EC  4EB9 00001E0E            308          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000013F2  6000 FD80                309          BRA     DECODE_DONE
000013F6                           310          
000013F6                           311  load_JSR:   * load and print JSR neumonic return to op loop
000013F6  43F9 0000236F            312          LEA     _JSR,A1
000013FC  4EB9 0000217E            313          JSR     WRITE_ASCII
00001402  4EB9 000021AE            314          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001408  6000 FD6A                315          BRA     DECODE_DONE
0000140C                           316          
0000140C                           317  load_MOVEM_W:   * load and print MOVEM.W neumonic return to op loop
0000140C  43F9 00002333            318          LEA     _MOVEM_W,A1
00001412  4EB9 0000217E            319          JSR     WRITE_ASCII
00001418  4EB9 000021AE            320          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000141E  13FC 0003 0000230E       321      MOVE.B  #WORD,INST_SZ   * save instruction size
00001426                           322           **** EA CODE GOES HERE ****
00001426                           323          * must set unused mode/reg vars to 0
00001426  4EB9 00001E0E            324          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000142C  6000 FD46                325          BRA     DECODE_DONE
00001430                           326          
00001430                           327  load_MOVEM_L:   * load and print MOVEM.L neumonic return to op loop
00001430  43F9 0000233C            328          LEA     _MOVEM_L,A1
00001436  4EB9 0000217E            329          JSR     WRITE_ASCII
0000143C  4EB9 000021AE            330          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001442  13FC 0002 0000230E       331          MOVE.B  #LONG,INST_SZ   * save instruction size
0000144A                           332           **** EA CODE GOES HERE ****
0000144A                           333          * must set unused mode/reg vars to 0
0000144A  4EB9 00001E0E            334          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001450  6000 FD22                335          BRA     DECODE_DONE
00001454                           336  
00001454                           337  ADDQ_:  * instruction is addq, determine size
00001454  2602                     338          MOVE.L  D2,D3
00001456  0243 01C0                339          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
0000145A  0C43 0000                340          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ADDQ.B
0000145E  6700 0012                341          BEQ     load_ADDQ_B
00001462  0C43 0040                342          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ADDQ.W
00001466  6700 002E                343          BEQ     load_ADDQ_W
0000146A  0C43 0080                344          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ADDQ.L
0000146E  6700 004A                345          BEQ     load_ADDQ_L           
00001472                           346  
00001472                           347  load_ADDQ_B:  * load and print ADDQ.B neumonic return to op loop
00001472  43F9 00002379            348          LEA     _ADDQ_B,A1
00001478  4EB9 0000217E            349          JSR     WRITE_ASCII
0000147E  4EB9 000021AE            350          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001484  13FC 0001 0000230E       351          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000148C                           352           **** EA CODE GOES HERE ****
0000148C                           353          * must set unused mode/reg vars to 0
0000148C  4EB9 00001E0E            354          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001492  6000 FCE0                355          BRA     DECODE_DONE
00001496                           356        
00001496                           357  load_ADDQ_W:  * load and print ADDQ.W neumonic return to op loop
00001496  43F9 00002381            358          LEA     _ADDQ_W,A1
0000149C  4EB9 0000217E            359          JSR     WRITE_ASCII
000014A2  4EB9 000021AE            360          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014A8  13FC 0003 0000230E       361          MOVE.B  #WORD,INST_SZ   * save instruction size
000014B0                           362           **** EA CODE GOES HERE ****
000014B0                           363          * must set unused mode/reg vars to 0
000014B0  4EB9 00001E0E            364          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014B6  6000 FCBC                365          BRA     DECODE_DONE
000014BA                           366          
000014BA                           367  load_ADDQ_L:  * load and print ADDQ.L neumonic return to op loop
000014BA  43F9 00002389            368          LEA     _ADDQ_L,A1
000014C0  4EB9 0000217E            369          JSR     WRITE_ASCII
000014C6  4EB9 000021AE            370          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014CC  13FC 0002 0000230E       371          MOVE.B  #LONG,INST_SZ
000014D4                           372           **** EA CODE GOES HERE ****
000014D4                           373          * must set unused mode/reg vars to 0
000014D4  4EB9 00001E0E            374          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014DA  6000 FC98                375          BRA     DECODE_DONE
000014DE                           376          
000014DE                           377  OP_6:   * could be BRA, BEQ, BGT, BLE
000014DE  2602                     378          MOVE.L  D2,D3   * copy instruction word
000014E0  0243 0F00                379          ANDI.W  #Nib2Mask,D3
000014E4  0C43 0000                380          CMPI.W  #$0000,D3   * if nibble 2 is 0, instruction is BRA
000014E8  6700 001A                381          BEQ     load_BRA
000014EC  0C43 0700                382          CMPI.W  #$0700,D3   * if nibble 2 is 7, instruction is BEQ
000014F0  6700 0028                383          BEQ     load_BEQ
000014F4  0C43 0E00                384          CMPI.W  #$0E00,D3   * if nibble 2 is E, instruction is BGT
000014F8  6700 003C                385          BEQ     load_BGT
000014FC  0C43 0F00                386          CMPI.W  #$0F00,D3   * if nibble 2 is F, instruction is BLE
00001500  6700 004A                387          BEQ     load_BLE
00001504                           388          
00001504                           389  load_BRA:   * load and print BRA neumonic return to op loop
00001504  43F9 00002391            390          LEA     _BRA,A1
0000150A  4EB9 0000217E            391          JSR     WRITE_ASCII
00001510  4EB9 000021AE            392          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001516  6000 FC5C                393          BRA     DECODE_DONE
0000151A                           394          
0000151A                           395  load_BEQ:   * load and print BEQ neumonic return to op loop
0000151A  43F9 00002396            396          LEA     _BEQ,A1
00001520  4EB9 0000217E            397          JSR     WRITE_ASCII
00001526  4EB9 00001F5A            398          JSR     NEXT_MEM_WORD_TO_BUF
0000152C  4EB9 000021AE            399          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001532  6000 FC40                400          BRA     DECODE_DONE
00001536                           401  
00001536                           402  load_BGT:   * load and print BGT neumonic return to op loop
00001536  43F9 0000239B            403          LEA     _BGT,A1
0000153C  4EB9 0000217E            404          JSR     WRITE_ASCII
00001542  4EB9 000021AE            405          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001548  6000 FC2A                406          BRA     DECODE_DONE
0000154C                           407          
0000154C                           408  load_BLE:   * load and print BLE neumonic return to op loop
0000154C  43F9 000023A0            409          LEA     _BLE,A1
00001552  4EB9 0000217E            410          JSR     WRITE_ASCII
00001558  4EB9 000021AE            411          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000155E  6000 FC14                412          BRA     DECODE_DONE
00001562                           413          
00001562                           414  load_MOVEQ: * load and print MOVEQ neumonic return to op loop
00001562  43F9 000023A5            415          LEA     _MOVEQ,A1
00001568  4EB9 0000217E            416          JSR     WRITE_ASCII
0000156E  4EB9 000021AE            417          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001574  6000 FBFE                418          BRA     DECODE_DONE
00001578                           419          
00001578                           420  OP_8:       * could be DIVU or OR
00001578  2602                     421          MOVE.L  D2,D3       * copy instruction word
0000157A  0243 01C0                422          ANDI.W  #Bit1Mask,D3   * mask, isolate distinguishing bits 8-6
0000157E  0C43 00C0                423          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is DIVU
00001582  6700 000A                424          BEQ     load_DIVU
00001586  0C43 00C0                425          CMPI.W  #$00C0,D3       * if bits 8-6 are NOT 011, instruction is OR
0000158A  6600 0024                426          BNE     load_OR
0000158E                           427  
0000158E                           428  load_DIVU:  * load and print DIVU neumonic return to op loop
0000158E  43F9 000023AC            429          LEA     _DIVU,A1
00001594  4EB9 0000217E            430          JSR     WRITE_ASCII
0000159A  4EB9 000021AE            431          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015A0                           432           **** EA CODE GOES HERE ****
000015A0  4EB9 00001A44            433          JSR     DIVU_EA
000015A6                           434          * must set unused mode/reg vars to 0
000015A6  4EB9 00001E0E            435          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015AC  6000 FBC6                436          BRA     DECODE_DONE
000015B0                           437          
000015B0                           438  load_OR:    * load and print DIVU neuomnic return to op loop
000015B0  43F9 000023B2            439          LEA     _OR,A1
000015B6  4EB9 0000217E            440          JSR     WRITE_ASCII
000015BC  4EB9 000021AE            441          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015C2                           442           **** EA CODE GOES HERE ****
000015C2  4EB9 00001AAE            443          JSR     OPMODE_EA
000015C8                           444          * must set unused mode/reg vars to 0
000015C8  4EB9 00001E0E            445          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015CE  6000 FBA4                446          BRA     DECODE_DONE
000015D2                           447  
000015D2                           448  load_SUB:   * load and print SUB neumonic return to op loop
000015D2  43F9 000023C1            449          LEA     _SUB,A1
000015D8  4EB9 0000217E            450          JSR     WRITE_ASCII
000015DE  4EB9 000021AE            451          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015E4                           452           **** EA CODE GOES HERE ****
000015E4  4EB9 00001AAE            453          JSR     OPMODE_EA
000015EA                           454  
000015EA                           455          * must set unused mode/reg vars to 0
000015EA  4EB9 00001E0E            456          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015F0  6000 FB82                457          BRA     DECODE_DONE
000015F4                           458  
000015F4                           459  OP_C:       * could be MULS or AND
000015F4  2602                     460          MOVE.L  D2,D3       * copy instruction word
000015F6  0243 01C0                461          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000015FA  0C43 01C0                462          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is MULS
000015FE  6700 000A                463          BEQ     load_MULS
00001602  0C43 01C0                464          CMPI.W  #$01C0,D3       * if bits 8-6 are NOT 111, instruction is AND
00001606  6600 001E                465          BNE     load_AND
0000160A                           466          
0000160A                           467  load_MULS:  * load and print MULS neumonic return to op loop
0000160A  43F9 000023C6            468          LEA     _MULS,A1
00001610  4EB9 0000217E            469          JSR     WRITE_ASCII
00001616  4EB9 000021AE            470          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000161C                           471           **** EA CODE GOES HERE ****
0000161C                           472          * must set unused mode/reg vars to 0
0000161C  4EB9 00001E0E            473          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001622  6000 FB50                474          BRA     DECODE_DONE
00001626                           475          
00001626                           476  load_AND:   * load and print AND neumonic return to op loop
00001626  43F9 000023CC            477          LEA     _AND,A1
0000162C  4EB9 0000217E            478          JSR     WRITE_ASCII
00001632  4EB9 000021AE            479          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001638                           480           **** EA CODE GOES HERE ****
00001638  4EB9 00001AAE            481          JSR     OPMODE_EA
0000163E                           482          * must set unused mode/reg vars to 0
0000163E  4EB9 00001E0E            483          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001644  6000 FB2E                484          BRA     DECODE_DONE
00001648                           485  
00001648                           486  OP_D:       * could be ADD or ADDA
00001648  2602                     487          MOVE.L  D2,D3       * copy instruction word
0000164A  0243 01C0                488          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 (opmode but distinguishes instr.)
0000164E  0C43 00C0                489          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ADDA
00001652  6700 000E                490          BEQ     load_ADDA
00001656  0C43 01C0                491          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is also ADDA
0000165A  6700 0006                492          BEQ     load_ADDA
0000165E  6600 0024                493          BNE     load_ADD        * if bits 8-6 are not either, instruction is ADD
00001662                           494          
00001662                           495  load_ADDA:  * load and print ADDA neumonic return to op loop
00001662  43F9 000023D6            496          LEA     _ADDA,A1
00001668  4EB9 0000217E            497          JSR     WRITE_ASCII
0000166E  4EB9 000021AE            498          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001674                           499           **** EA CODE GOES HERE ****
00001674  4EB9 00001AAE            500          JSR     OPMODE_EA
0000167A                           501          * must set unused mode/reg vars to 0
0000167A  4EB9 00001E0E            502          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001680  6000 FAF2                503          BRA     DECODE_DONE
00001684                           504  
00001684                           505  load_ADD:   * load and print ADD neumonic return to op loop
00001684  43F9 000023D1            506          LEA     _ADD,A1
0000168A  4EB9 0000217E            507          JSR     WRITE_ASCII
00001690  4EB9 000021AE            508          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001696                           509           **** EA CODE GOES HERE ****
00001696  4EB9 00001AAE            510          JSR     OPMODE_EA
0000169C                           511          * must set unused mode/reg vars to 0
0000169C  4EB9 00001E0E            512          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000016A2  6000 FAD0                513          BRA     DECODE_DONE
000016A6                           514  
000016A6                           515  OP_E:       * could be ASL, ASR, LSL, LSR (memory or register)
000016A6  2602                     516          MOVE.L  D2,D3       * copy instruction word
000016A8  0283 FFFF00FF            517          ANDI.L  #$FFFF00FF,D3   * mask, isolate bits 7-6
000016AE  0C43 00C0                518          CMPI.W  #$00C0,D3       * if bits 7-6 are 11, instruction is MEMORY shift
000016B2  6700 000A                519          BEQ     MEMORY_shift
000016B6  0C43 00C0                520          CMPI.W  #$00C0,D3       * if bits 7-6 are NOT 11, instruction is REG shift
000016BA  6600 00B4                521          BNE     REG_shift
000016BE                           522          
000016BE                           523  MEMORY_shift:   * could be ASL, ASR, LSL, LSR (memory)
000016BE  2602                     524          MOVE.L  D2,D3       * copy instruction word
000016C0  0243 0E00                525          ANDI.W  #Bit0Mask,D3    * mask, isolate bits 11-9
000016C4  0C43 0000                526          CMPI.W  #$0000,D3       * if bits 11-9 are 000, instruction is ASL or ASR (memory)
000016C8  6700 000A                527          BEQ     ASL_ASR_MEM
000016CC  0C43 0200                528          CMPI.W  #$0200,D3       * if bits 11-9 are 001, instruction is LSL or LSR (memory)
000016D0  6700 0050                529          BEQ     LSL_LSR_MEM
000016D4                           530          
000016D4                           531  ASL_ASR_MEM:    * could be ASL or ASR (memory)
000016D4  2602                     532          MOVE.L  D2,D3       * copy instruction word
000016D6  0243 01C0                533          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000016DA  0C43 00C0                534          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ASR memory
000016DE  6700 000A                535          BEQ     load_ASR_MEM
000016E2  0C43 01C0                536          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is ASL memory
000016E6  6700 001E                537          BEQ     load_ASL_MEM
000016EA                           538          
000016EA                           539  load_ASR_MEM:   * load and print ASR neumonic return to op loop
000016EA  43F9 000023E1            540          LEA     _ASR,A1
000016F0  4EB9 0000217E            541          JSR     WRITE_ASCII
000016F6  4EB9 000021AE            542          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000016FC                           543           **** EA CODE GOES HERE ****
000016FC                           544          * must set unused mode/reg vars to 0
000016FC  4EB9 00001E0E            545          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001702  6000 FA70                546          BRA     DECODE_DONE
00001706                           547          
00001706                           548  load_ASL_MEM:   * load and print ASL neumonic return to op loop
00001706  43F9 000023DC            549          LEA     _ASL,A1
0000170C  4EB9 0000217E            550          JSR     WRITE_ASCII
00001712  4EB9 000021AE            551          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001718                           552           **** EA CODE GOES HERE ****
00001718                           553          * must set unused mode/reg vars to 0
00001718  4EB9 00001E0E            554          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000171E  6000 FA54                555          BRA     DECODE_DONE
00001722                           556  
00001722                           557  LSL_LSR_MEM:    * could be LSL or LSR (memory)
00001722  2602                     558          MOVE.L  D2,D3       * copy instruction word
00001724  0243 01C0                559          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001728  0C43 00C0                560          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is LSR memory
0000172C  6700 000A                561          BEQ     load_LSR_MEM
00001730  0C43 01C0                562          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LSL memory
00001734  6700 001E                563          BEQ     load_LSL_MEM 
00001738                           564          
00001738                           565  load_LSR_MEM:   * load and print LSR neumonic return to op loop
00001738  43F9 000023EB            566          LEA     _LSR,A1
0000173E  4EB9 0000217E            567          JSR     WRITE_ASCII
00001744  4EB9 000021AE            568          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000174A                           569           **** EA CODE GOES HERE ****
0000174A                           570          * must set unused mode/reg vars to 0
0000174A  4EB9 00001E0E            571          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001750  6000 FA22                572          BRA     DECODE_DONE
00001754                           573          
00001754                           574  load_LSL_MEM:   * load and print LSL neumonic return to op loop
00001754  43F9 000023E6            575          LEA     _LSL,A1
0000175A  4EB9 0000217E            576          JSR     WRITE_ASCII
00001760  4EB9 000021AE            577          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001766                           578           **** EA CODE GOES HERE ****
00001766                           579          * must set unused mode/reg vars to 0
00001766  4EB9 00001E0E            580          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000176C  6000 FA06                581          BRA     DECODE_DONE
00001770                           582  
00001770                           583  REG_shift:      * could be ASL, ASR, LSL, LSR (register)
00001770  2602                     584          MOVE.L  D2,D3       * copy instruction word
00001772  0243 0038                585          ANDI.W  #Bit2Mask,D3    * mask, isolate bits 5-3
00001776  0C43 0000                586          CMPI.W  #$0000,D3        * if bits 5-3 are 000, instruction is ASL or ASR (reg)
0000177A  6700 001A                587          BEQ     ASL_ASR_REG
0000177E  0C43 0020                588          CMPI.W  #$0020,D3       * if bits 5-3 are 100, instruction is ASL or ASR (reg)
00001782  6700 0012                589          BEQ     ASL_ASR_REG
00001786  0C43 0008                590          CMPI.W  #$0008,D3       * if bits 5-3 are 001, instruction is LSL or LSR (reg)
0000178A  6700 00F6                591          BEQ     LSL_LSR_REG
0000178E  0C43 0028                592          CMPI.W  #$0028,D3       * if bits 5-3 are 101, instruction is LSL or LSR (reg)
00001792  6700 00EE                593          BEQ     LSL_LSR_REG
00001796                           594          
00001796                           595  ASL_ASR_REG:    * could be ASL or ASR (register)
00001796  2602                     596          MOVE.L  D2,D3       * copy instruction word
00001798  0283 000001C0            597          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
0000179E                           598          
0000179E  0C43 0000                599          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ASR.B register
000017A2  6700 002A                600          BEQ     load_ASR_B_REG
000017A6  0C43 0040                601          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ASR.W register
000017AA  6700 0040                602          BEQ     load_ASR_W_REG
000017AE  0C43 0080                603          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ASR.L register
000017B2  6700 0056                604          BEQ     load_ASR_L_REG
000017B6                           605          
000017B6  0C43 0100                606          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is ASL.B register
000017BA  6700 006C                607          BEQ     load_ASL_B_REG
000017BE  0C43 0140                608          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is ASL.W register
000017C2  6700 0082                609          BEQ     load_ASL_W_REG
000017C6  0C43 0180                610          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is ASL.L register
000017CA  6700 0098                611          BEQ     load_ASL_L_REG
000017CE                           612  
000017CE                           613  load_ASR_B_REG:   * load and print ASR.B neumonic return to op loop
000017CE  43F9 00002405            614          LEA     _ASR_B,A1
000017D4  4EB9 0000217E            615          JSR     WRITE_ASCII
000017DA  4EB9 000021AE            616          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000017E0  13FC 0001 0000230E       617          MOVE.B  #BYTE,INST_SZ   * save instruction size
000017E8  6000 F98A                618          BRA     DECODE_DONE
000017EC                           619          
000017EC                           620  load_ASR_W_REG:   * load and print ASR.W neumonic return to op loop
000017EC  43F9 0000240C            621          LEA     _ASR_W,A1
000017F2  4EB9 0000217E            622          JSR     WRITE_ASCII
000017F8  4EB9 000021AE            623          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000017FE  13FC 0003 0000230E       624          MOVE.B  #WORD,INST_SZ   * save instruction size
00001806  6000 F96C                625          BRA     DECODE_DONE
0000180A                           626          
0000180A                           627  load_ASR_L_REG:   * load and print ASR.L neumonic return to op loop
0000180A  43F9 00002413            628          LEA     _ASR_L,A1
00001810  4EB9 0000217E            629          JSR     WRITE_ASCII
00001816  4EB9 000021AE            630          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000181C  13FC 0002 0000230E       631          MOVE.B  #LONG,INST_SZ   * save instruction size
00001824  6000 F94E                632          BRA     DECODE_DONE
00001828                           633          
00001828                           634  load_ASL_B_REG:   * load and print ASL.B neumonic return to op loop
00001828  43F9 000023F0            635          LEA     _ASL_B,A1
0000182E  4EB9 0000217E            636          JSR     WRITE_ASCII
00001834  4EB9 000021AE            637          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000183A  13FC 0001 0000230E       638          MOVE.B  #BYTE,INST_SZ   * save instruction size
00001842  6000 F930                639          BRA     DECODE_DONE
00001846                           640          
00001846                           641  load_ASL_W_REG:   * load and print ASL.W neumonic return to op loop
00001846  43F9 000023F7            642          LEA     _ASL_W,A1
0000184C  4EB9 0000217E            643          JSR     WRITE_ASCII
00001852  4EB9 000021AE            644          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001858  13FC 0003 0000230E       645          MOVE.B  #WORD,INST_SZ   * save instruction size
00001860  6000 F912                646          BRA     DECODE_DONE
00001864                           647          
00001864                           648  load_ASL_L_REG:   * load and print ASL.L neumonic return to op loop
00001864  43F9 000023FE            649          LEA     _ASL_L,A1
0000186A  4EB9 0000217E            650          JSR     WRITE_ASCII
00001870  4EB9 000021AE            651          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001876  13FC 0002 0000230E       652          MOVE.B  #LONG,INST_SZ   * save instruction size
0000187E  6000 F8F4                653          BRA     DECODE_DONE
00001882                           654  
00001882                           655  LSL_LSR_REG:    * could be LSL or LSR (register)
00001882  2602                     656          MOVE.L  D2,D3       * copy instruction word
00001884  0283 000001C0            657          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
0000188A                           658          
0000188A  0C43 0000                659          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is LSR.B register
0000188E  6700 002A                660          BEQ     load_LSR_B_REG
00001892  0C43 0040                661          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is LSR.W register
00001896  6700 0040                662          BEQ     load_LSR_W_REG
0000189A  0C43 0080                663          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is LSR.L register
0000189E  6700 0056                664          BEQ     load_LSR_L_REG
000018A2                           665          
000018A2  0C43 0100                666          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is LSL.B register
000018A6  6700 006C                667          BEQ     load_LSL_B_REG
000018AA  0C43 0140                668          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is LSL.W register
000018AE  6700 0082                669          BEQ     load_LSL_W_REG
000018B2  0C43 0180                670          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is LSL.L register
000018B6  6700 0098                671          BEQ     load_LSL_L_REG
000018BA                           672  
000018BA                           673  load_LSR_B_REG:   * load and print LSR.B neumonic return to op loop
000018BA  43F9 0000242F            674          LEA     _LSR_B,A1
000018C0  4EB9 0000217E            675          JSR     WRITE_ASCII
000018C6  4EB9 000021AE            676          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018CC  13FC 0001 0000230E       677          MOVE.B  #BYTE,INST_SZ   * save instruction size
000018D4  6000 F89E                678          BRA     DECODE_DONE
000018D8                           679          
000018D8                           680  load_LSR_W_REG:   * load and print LSR.W neumonic return to op loop
000018D8  43F9 00002436            681          LEA     _LSR_W,A1
000018DE  4EB9 0000217E            682          JSR     WRITE_ASCII
000018E4  4EB9 000021AE            683          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018EA  13FC 0003 0000230E       684          MOVE.B  #WORD,INST_SZ   * save instruction size
000018F2  6000 F880                685          BRA     DECODE_DONE
000018F6                           686          
000018F6                           687  load_LSR_L_REG:   * load and print LSR.L neumonic return to op loop
000018F6  43F9 0000243D            688          LEA     _LSR_L,A1
000018FC  4EB9 0000217E            689          JSR     WRITE_ASCII
00001902  4EB9 000021AE            690          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001908  13FC 0002 0000230E       691          MOVE.B  #LONG,INST_SZ   * save instruction size
00001910  6000 F862                692          BRA     DECODE_DONE
00001914                           693          
00001914                           694  load_LSL_B_REG:   * load and print LSL.B neumonic return to op loop
00001914  43F9 0000241A            695          LEA     _LSL_B,A1
0000191A  4EB9 0000217E            696          JSR     WRITE_ASCII
00001920  4EB9 000021AE            697          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001926  13FC 0001 0000230E       698          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000192E  6000 F844                699          BRA     DECODE_DONE
00001932                           700          
00001932                           701  load_LSL_W_REG:   * load and print LSL.W neumonic return to op loop
00001932  43F9 00002421            702          LEA     _LSL_W,A1
00001938  4EB9 0000217E            703          JSR     WRITE_ASCII
0000193E  4EB9 000021AE            704          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001944  13FC 0003 0000230E       705          MOVE.B  #WORD,INST_SZ   * save instruction size
0000194C  6000 F826                706          BRA     DECODE_DONE
00001950                           707          
00001950                           708  load_LSL_L_REG:   * load and print LSL.L neumonic return to op loop
00001950  43F9 00002428            709          LEA     _LSL_L,A1
00001956  4EB9 0000217E            710          JSR     WRITE_ASCII
0000195C  4EB9 000021AE            711          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001962  13FC 0002 0000230E       712          MOVE.B  #LONG,INST_SZ   * save instruction size
0000196A  6000 F808                713          BRA     DECODE_DONE
0000196E                           714  
0000196E                           715  ****       EA       ****
0000196E                           716  
0000196E                           717  **** MOVE_EA FIRST EA COMMAND *********
0000196E                           718  MOVE_EA:
0000196E  2602                     719          MOVE.L  D2,D3           *copy instruction to D3 for register
00001970  2802                     720          MOVE.L  D2,D4           *copy instruction to D4 for mode
00001972  0244 0038                721          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001976  0243 0007                722          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
0000197A  E68C                     723          LSR.L   #3,D4
0000197C  13C4 00002311            724          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001982  13C3 00002312            725          MOVE.B  D3,SRC_REG      * save source register to memory
00001988  C8FC 0006                726          MULU    #6,D4
0000198C  C6FC 0006                727          MULU    #6,D3
00001990  43F9 00001C52            728          LEA     EA_MODE,A1
00001996  4EB1 4000                729          JSR     (A1,D4)
0000199A  43F9 0000246D            730          LEA     _COMMA,A1
000019A0  4EB9 0000217E            731          JSR     WRITE_ASCII
000019A6                           732  
000019A6  4243                     733          CLR     D3
000019A8  4244                     734          CLR     D4 
000019AA                           735  ******* MOVE_EA SECOND EA COMMAND **********
000019AA  2602                     736          MOVE.L  D2,D3           *copy instruction to D3 for register
000019AC  2802                     737          MOVE.L  D2,D4           *copy instruction to D4 for modE
000019AE  0243 0E00                738          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
000019B2  0244 01C0                739          ANDI.W  #Bit1Mask,D4    *mask to isolate 3-bit mode
000019B6  1A3C 0009                740          MOVE.B  #9, D5
000019BA  EA6B                     741          LSR     D5,D3 
000019BC  EC8C                     742          LSR.L   #6,D4
000019BE  13C4 0000230F            743          MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
000019C4  13C3 00002310            744          MOVE.B  D3,DEST_REG      * save destination register to memory 
000019CA  C8FC 0006                745          MULU   #6,D4
000019CE  C6FC 0006                746          MULU   #6,D3
000019D2                           747         
000019D2  43F9 00001C52            748          LEA     EA_MODE,A1 
000019D8  4EB1 4000                749          JSR     (A1,D4)
000019DC  4E75                     750          RTS
000019DE                           751  
000019DE                           752  ********** LEA_EA ***********
000019DE                           753  LEA_EA:
000019DE  2602                     754          MOVE.L  D2,D3 
000019E0  2802                     755          MOVE.L  D2,D4
000019E2  0244 0038                756          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
000019E6  0243 0007                757          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
000019EA  E68C                     758          LSR.L   #3,D4
000019EC  13C4 00002311            759          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
000019F2  13C3 00002312            760          MOVE.B  D3,SRC_REG      * save source register to memory
000019F8  C8FC 0006                761          MULU    #6,D4
000019FC  C6FC 0006                762          MULU    #6,D3
00001A00                           763  
00001A00  43F9 00001C52            764          LEA     EA_MODE,A1
00001A06  4EB1 4000                765          JSR     (A1,D4)
00001A0A  43F9 0000246D            766          LEA     _COMMA,A1
00001A10  4EB9 0000217E            767          JSR     WRITE_ASCII
00001A16                           768  
00001A16  4243                     769          CLR     D3
00001A18  4244                     770          CLR     D4 
00001A1A                           771  
00001A1A                           772  
00001A1A  2602                     773          MOVE.L  D2,D3 
00001A1C  0243 0E00                774          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001A20  1A3C 0009                775          MOVE.B  #9, D5
00001A24  EA6B                     776          LSR     D5,D3 
00001A26  13C3 00002310            777          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001A2C  C6FC 0006                778          MULU   #6,D3
00001A30  383C 0001                779          MOVE.W  #$0001,D4       *set mode to address register
00001A34  C8FC 0006                780          MULU    #6,D4
00001A38                           781  
00001A38                           782  
00001A38  43F9 00001C52            783          LEA     EA_MODE,A1 
00001A3E  4EB1 4000                784          JSR     (A1,D4)
00001A42  4E75                     785          RTS
00001A44                           786  
00001A44                           787  ********* DIVU_EA ************
00001A44                           788  DIVU_EA:
00001A44  2602                     789          MOVE.L  D2,D3 
00001A46  2802                     790          MOVE.L  D2,D4
00001A48  0244 0038                791          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001A4C  0243 0007                792          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001A50  E68C                     793          LSR.L   #3,D4
00001A52  13C4 00002311            794          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001A58  13C3 00002312            795          MOVE.B  D3,SRC_REG      * save source register to memory
00001A5E  C8FC 0006                796          MULU    #6,D4
00001A62  C6FC 0006                797          MULU    #6,D3
00001A66                           798  
00001A66  43F9 00001C52            799          LEA     EA_MODE,A1
00001A6C  4EB1 4000                800          JSR     (A1,D4)
00001A70  43F9 0000246D            801          LEA     _COMMA,A1
00001A76  4EB9 0000217E            802          JSR     WRITE_ASCII
00001A7C                           803  
00001A7C  4243                     804          CLR     D3
00001A7E  4244                     805          CLR     D4 
00001A80                           806  
00001A80  2602                     807          MOVE.L  D2,D3 
00001A82  0243 0E00                808          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001A86  1A3C 0009                809          MOVE.B  #9, D5
00001A8A  EA6B                     810          LSR     D5,D3 
00001A8C  13C3 00002310            811          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001A92  C6FC 0006                812          MULU   #6,D3
00001A96  43F9 00002444            813          LEA     _DR,A1 
00001A9C  4EB9 0000217E            814          JSR WRITE_ASCII
00001AA2                           815  
00001AA2                           816  
00001AA2  43F9 00001D6E            817          LEA     EA_REG,A1 
00001AA8  4EB1 3000                818          JSR     (A1,D3)
00001AAC  4E75                     819          RTS 
00001AAE                           820  
00001AAE                           821  ****** 0PMODE_EA ************
00001AAE                           822  OPMODE_EA:
00001AAE  2802                     823          MOVE.L  D2,D4
00001AB0  0244 01C0                824          ANDI.W  #Bit1Mask,D4            *FIND OPMODE
00001AB4  EC8C                     825          LSR.L   #6,D4
00001AB6  13C4 0000230F            826          MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
00001ABC  C8FC 0006                827          MULU    #6,D4 
00001AC0                           828  
00001AC0  43F9 00001BB8            829          LEA     OPMODE,A1               *LOAD OPMODE TABLE
00001AC6  4EB1 4000                830          JSR     (A1,D4)                 *JMP TO OPMODE TABLE
00001ACA                           831  
00001ACA                           832  
00001ACA  BA3C 0001                833          CMP.B   #%1,D5                  *if flag == 1, <ea> V Dn - Dn
00001ACE  6700 007A                834          BEQ     D_TO_EA
00001AD2  BA3C 0001                835          CMP.B   #%1,D5                  *else, Dn V <ea> - <ea>
00001AD6  6600 0004                836          BNE     EA_TO_D
00001ADA  4E75                     837          RTS
00001ADC                           838  EA_TO_D:
00001ADC  4243                     839          CLR     D3
00001ADE  4244                     840          CLR     D4
00001AE0                           841  
00001AE0  2602                     842          MOVE.L  D2,D3 
00001AE2  2802                     843          MOVE.L  D2,D4
00001AE4  0244 0038                844          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001AE8  0243 0007                845          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001AEC  E68C                     846          LSR.L   #3,D4
00001AEE  13C4 00002311            847          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001AF4  13C3 00002312            848          MOVE.B  D3,SRC_REG      * save source register to memory
00001AFA  C8FC 0006                849          MULU    #6,D4
00001AFE  C6FC 0006                850          MULU    #6,D3
00001B02                           851  
00001B02  43F9 00001C52            852          LEA     EA_MODE,A1
00001B08  4EB1 4000                853          JSR     (A1,D4)
00001B0C  43F9 0000246D            854          LEA     _COMMA,A1
00001B12  4EB9 0000217E            855          JSR     WRITE_ASCII
00001B18                           856  
00001B18  4243                     857          CLR     D3
00001B1A  4244                     858          CLR     D4 
00001B1C                           859  
00001B1C  2602                     860          MOVE.L  D2,D3 
00001B1E  0243 0E00                861          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001B22  1A3C 0009                862          MOVE.B  #9, D5
00001B26  EA6B                     863          LSR     D5,D3 
00001B28  13C3 00002310            864          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001B2E  C6FC 0006                865          MULU   #6,D3
00001B32  43F9 00002444            866          LEA     _DR,A1 
00001B38  4EB9 0000217E            867          JSR WRITE_ASCII
00001B3E                           868  
00001B3E                           869  
00001B3E  43F9 00001D6E            870          LEA     EA_REG,A1 
00001B44  4EB1 3000                871          JSR     (A1,D3)
00001B48  4E75                     872          RTS
00001B4A                           873  
00001B4A                           874  D_TO_EA:
00001B4A                           875  
00001B4A  4243                     876          CLR     D3
00001B4C  4244                     877          CLR     D4 
00001B4E                           878  
00001B4E  2602                     879          MOVE.L  D2,D3 
00001B50  0243 0E00                880          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001B54  1A3C 0009                881          MOVE.B  #9, D5
00001B58  EA6B                     882          LSR     D5,D3 
00001B5A  13C3 00002310            883          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001B60  C6FC 0006                884          MULU   #6,D3
00001B64  43F9 00002444            885          LEA     _DR,A1 
00001B6A  4EB9 0000217E            886          JSR WRITE_ASCII
00001B70                           887  
00001B70                           888  
00001B70  43F9 00001D6E            889          LEA     EA_REG,A1 
00001B76  4EB1 3000                890          JSR     (A1,D3)
00001B7A  43F9 0000246D            891          LEA     _COMMA,A1
00001B80  4EB9 0000217E            892          JSR     WRITE_ASCII
00001B86                           893  
00001B86  4243                     894          CLR     D3
00001B88  4244                     895          CLR     D4
00001B8A                           896  
00001B8A  2602                     897          MOVE.L  D2,D3 
00001B8C  2802                     898          MOVE.L  D2,D4
00001B8E  0244 0038                899          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001B92  0243 0007                900          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001B96  E68C                     901          LSR.L   #3,D4
00001B98  13C4 00002311            902          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001B9E  13C3 00002312            903          MOVE.B  D3,SRC_REG      * save source register to memory
00001BA4  C8FC 0006                904          MULU    #6,D4
00001BA8  C6FC 0006                905          MULU    #6,D3
00001BAC                           906  
00001BAC  43F9 00001C52            907          LEA     EA_MODE,A1
00001BB2  4EB1 4000                908          JSR     (A1,D4)
00001BB6  4E75                     909          RTS
00001BB8                           910  
00001BB8                           911  ******* OPMODE **********
00001BB8                           912  OPMODE:
00001BB8  4EF9 00001BE8            913          JMP     OM000
00001BBE  4EF9 00001BF8            914          JMP     OM001
00001BC4  4EF9 00001C08            915          JMP     OM010
00001BCA  4EF9 00001C18            916          JMP     OM011
00001BD0  4EF9 00001C1A            917          JMP     OM100
00001BD6  4EF9 00001C2C            918          JMP     OM101
00001BDC  4EF9 00001C3E            919          JMP     OM110
00001BE2  4EF9 00001C50            920          JMP     OM111
00001BE8                           921  
00001BE8                           922  OM000:
00001BE8  43F9 000023B5            923          LEA     _B,A1
00001BEE  4EB9 0000217E            924          JSR     WRITE_ASCII
00001BF4  4245                     925          CLR     D5
00001BF6  4E75                     926          RTS   
00001BF8                           927  OM001:
00001BF8  43F9 000023B9            928          LEA     _W,A1
00001BFE  4EB9 0000217E            929          JSR     WRITE_ASCII
00001C04  4245                     930          CLR     D5
00001C06                           931  
00001C06  4E75                     932          RTS   
00001C08                           933  OM010:
00001C08  43F9 000023BD            934          LEA     _L,A1
00001C0E  4EB9 0000217E            935          JSR     WRITE_ASCII
00001C14  4245                     936          CLR     D5
00001C16                           937  
00001C16  4E75                     938          RTS   
00001C18                           939  OM011:
00001C18  4E75                     940          RTS   
00001C1A                           941  OM100:
00001C1A  43F9 000023B5            942          LEA     _B,A1
00001C20  4EB9 0000217E            943          JSR     WRITE_ASCII
00001C26  1A3C 0001                944          MOVE.B  #%1,D5
00001C2A                           945  
00001C2A  4E75                     946          RTS   
00001C2C                           947  OM101:
00001C2C  43F9 000023B9            948          LEA     _W,A1
00001C32  4EB9 0000217E            949          JSR     WRITE_ASCII
00001C38  1A3C 0001                950          MOVE.B  #%1,D5
00001C3C                           951  
00001C3C  4E75                     952          RTS   
00001C3E                           953  OM110:
00001C3E  43F9 000023BD            954          LEA     _L,A1
00001C44  4EB9 0000217E            955          JSR     WRITE_ASCII
00001C4A  1A3C 0001                956          MOVE.B  #%1,D5
00001C4E                           957  
00001C4E  4E75                     958          RTS   
00001C50                           959  OM111:
00001C50  4E75                     960          RTS   
00001C52                           961   
00001C52                           962          
00001C52                           963  
00001C52                           964  
00001C52                           965  ******** JUMP TABLE FOR EA MODES *********
00001C52                           966  EA_MODE:
00001C52  4EF9 00001C82            967          JMP     EA000
00001C58  4EF9 00001C9A            968          JMP     EA001
00001C5E  4EF9 00001CB2            969          JMP     EA010
00001C64  4EF9 00001CD6            970          JMP     EA011
00001C6A  4EF9 00001CFA            971          JMP     EA100
00001C70  4EF9 00001D1E            972          JMP     EA101
00001C76  4EF9 00001D20            973          JMP     EA110
00001C7C  4EF9 00001D22            974          JMP     EA111
00001C82                           975  
00001C82                           976  EA000:
00001C82  43F9 00002444            977          LEA     _DR,A1 
00001C88  4EB9 0000217E            978          JSR     WRITE_ASCII
00001C8E  43F9 00001D6E            979          LEA     EA_REG,A1
00001C94  4EB1 3000                980          JSR     (A1,D3)
00001C98  4E75                     981          RTS     
00001C9A                           982  EA001:
00001C9A  43F9 00002446            983          LEA     _AR,A1 
00001CA0  4EB9 0000217E            984          JSR     WRITE_ASCII
00001CA6  43F9 00001D6E            985          LEA     EA_REG,A1
00001CAC  4EB1 3000                986          JSR     (A1,D3)
00001CB0  4E75                     987          RTS     
00001CB2                           988  EA010:
00001CB2  43F9 00002448            989          LEA     _IND_AR1,A1 
00001CB8  4EB9 0000217E            990          JSR     WRITE_ASCII
00001CBE  43F9 00001D6E            991          LEA     EA_REG,A1
00001CC4  4EB1 3000                992          JSR     (A1,D3)
00001CC8  43F9 0000244B            993          LEA     _IND_AR2,A1
00001CCE  4EB9 0000217E            994          JSR     WRITE_ASCII
00001CD4  4E75                     995          RTS     
00001CD6                           996      
00001CD6                           997  EA011:
00001CD6  43F9 0000244D            998          LEA     _AR_POST1,A1 
00001CDC  4EB9 0000217E            999          JSR     WRITE_ASCII
00001CE2  43F9 00001D6E           1000          LEA     EA_REG,A1
00001CE8  4EB1 3000               1001          JSR     (A1,D3)
00001CEC  43F9 00002450           1002          LEA     _AR_POST2,A1
00001CF2  4EB9 0000217E           1003          JSR     WRITE_ASCII
00001CF8  4E75                    1004          RTS
00001CFA                          1005       
00001CFA                          1006      
00001CFA                          1007  EA100:
00001CFA  43F9 00002453           1008          LEA     _AR_PRE1,A1 
00001D00  4EB9 0000217E           1009          JSR     WRITE_ASCII
00001D06  43F9 00001D6E           1010          LEA     EA_REG,A1
00001D0C  4EB1 3000               1011          JSR     (A1,D3)
00001D10  43F9 00002457           1012          LEA     _AR_PRE2,A1
00001D16  4EB9 0000217E           1013          JSR     WRITE_ASCII
00001D1C  4E75                    1014          RTS   
00001D1E                          1015  
00001D1E  4E75                    1016  EA101:  RTS
00001D20                          1017  
00001D20  4E75                    1018  EA110:  RTS
00001D22                          1019  
00001D22                          1020  EA111:      
00001D22  86FC 0006               1021          DIVU    #6,D3   * divide register num by 6 to undo jmp table multiplication
00001D26                          1022          
00001D26  B67C 0000               1023          CMP #0,D3   * if reg 0 load word from mem
00001D2A  6600 0016               1024          BNE EA111_R1
00001D2E  43F9 00002459           1025          LEA _ABS,A1
00001D34  4EB9 0000217E           1026          JSR WRITE_ASCII     * write $ to buffer
00001D3A  4EB9 00001F5A           1027          JSR NEXT_MEM_WORD_TO_BUF
00001D40  4E75                    1028          RTS
00001D42                          1029  EA111_R1:
00001D42  B67C 0001               1030          CMP #1,D3   * if reg 1 load long from mem
00001D46  6600 0016               1031          BNE EA111_R4
00001D4A  43F9 00002459           1032          LEA _ABS,A1
00001D50  4EB9 0000217E           1033          JSR WRITE_ASCII     * write $ to buffer
00001D56  4EB9 00001F70           1034          JSR NEXT_MEM_LONG_TO_BUF
00001D5C  4E75                    1035          RTS
00001D5E                          1036  EA111_R4:       
00001D5E  B67C 0004               1037          CMP #%100,D3  * if reg 4 load immediate value
00001D62                          1038          * will need to know instruction size to propperly grab this
00001D62  6600 0008               1039          BNE EA_MODE_DONE    * EA error if not equal to one of the valid modes
00001D66  4EB9 00001F0C           1040          JSR ADD_IMMEDIATE_TO_BUF
00001D6C                          1041  EA_MODE_DONE:
00001D6C  4E75                    1042          RTS
00001D6E                          1043          
00001D6E                          1044  
00001D6E                          1045  ********* JUMP TABLE FOR REGISTERS ******
00001D6E                          1046  EA_REG:
00001D6E  4EF9 00001D9E           1047          JMP     REG000
00001D74  4EF9 00001DAC           1048          JMP     REG001
00001D7A  4EF9 00001DBA           1049          JMP     REG010
00001D80  4EF9 00001DC8           1050          JMP     REG011
00001D86  4EF9 00001DD6           1051          JMP     REG100
00001D8C  4EF9 00001DE4           1052          JMP     REG101
00001D92  4EF9 00001DF2           1053          JMP     REG110
00001D98  4EF9 00001E00           1054          JMP     REG111
00001D9E                          1055  
00001D9E                          1056  REG000:
00001D9E  43F9 0000245D           1057          LEA     _ZERO,A1 
00001DA4  4EB9 0000217E           1058          JSR     WRITE_ASCII
00001DAA  4E75                    1059          RTS   
00001DAC                          1060  REG001:
00001DAC  43F9 0000245F           1061          LEA     _ONE,A1 
00001DB2  4EB9 0000217E           1062          JSR     WRITE_ASCII
00001DB8  4E75                    1063          RTS   
00001DBA                          1064  REG010:
00001DBA  43F9 00002461           1065          LEA     _TWO,A1 
00001DC0  4EB9 0000217E           1066          JSR     WRITE_ASCII
00001DC6  4E75                    1067          RTS   
00001DC8                          1068  REG011:
00001DC8  43F9 00002463           1069          LEA     _THREE,A1 
00001DCE  4EB9 0000217E           1070          JSR     WRITE_ASCII
00001DD4  4E75                    1071          RTS   
00001DD6                          1072  REG100:
00001DD6  43F9 00002465           1073          LEA     _FOUR,A1 
00001DDC  4EB9 0000217E           1074          JSR     WRITE_ASCII
00001DE2  4E75                    1075          RTS   
00001DE4                          1076  REG101:
00001DE4  43F9 00002467           1077          LEA     _FIVE,A1 
00001DEA  4EB9 0000217E           1078          JSR     WRITE_ASCII
00001DF0  4E75                    1079          RTS   
00001DF2                          1080  REG110:
00001DF2  43F9 00002469           1081          LEA     _SIX,A1 
00001DF8  4EB9 0000217E           1082          JSR     WRITE_ASCII
00001DFE  4E75                    1083          RTS   
00001E00                          1084  REG111:
00001E00  43F9 0000246B           1085          LEA     _SEVEN,A1 
00001E06  4EB9 0000217E           1086          JSR     WRITE_ASCII
00001E0C  4E75                    1087          RTS   
00001E0E                          1088    
00001E0E                          1089   
00001E0E                          1090  ***      EA ERRORS      ***
00001E0E                          1091  
00001E0E                          1092  * invalid codes for all instructions
00001E0E                          1093  BASE_EA_ERR_CHK:
00001E0E  48E7 C080               1094          MOVEM.L D0-D1/A0,-(SP)
00001E12                          1095          * load source modes and registers
00001E12  1039 00002311           1096          MOVE.B  SRC_MODE,D0
00001E18  1239 00002312           1097          MOVE.B  SRC_REG,D1
00001E1E  0C00 0008               1098          CMPI.B  #8,D0
00001E22  6C00 0068               1099          BGE     EA_ERR
00001E26  C0FC 0006               1100          MULU   #6,D0       
00001E2A  41F9 00001E5C           1101          LEA     BASE_EA_ERR_MODES,A0 
00001E30  4EB0 0000               1102          JSR     (A0,D0)
00001E34                          1103  
00001E34                          1104          * load destination modes and registers
00001E34  1039 0000230F           1105          MOVE.B  DEST_MODE,D0
00001E3A  1239 00002310           1106          MOVE.B  DEST_REG,D1
00001E40  0C00 0008               1107          CMPI.B  #8,D0
00001E44  6C00 0046               1108          BGE     EA_ERR
00001E48  C0FC 0006               1109          MULU   #6,D0
00001E4C  41F9 00001E5C           1110          LEA     BASE_EA_ERR_MODES,A0 
00001E52  4EB0 0000               1111          JSR     (A0,D0)
00001E56                          1112  
00001E56  4CDF 0103               1113          MOVEM.L (SP)+,D0-D1/A0
00001E5A  4E75                    1114          RTS
00001E5C                          1115  * jmp table to handle base ea errors        
00001E5C                          1116  BASE_EA_ERR_MODES:
00001E5C                          1117          * NOP slide to catch good modes and direct to rts
00001E5C  4E71                    1118          NOP
00001E5E  4E71                    1119          NOP
00001E60  4E71                    1120          NOP
00001E62  4E71                    1121          NOP
00001E64  4E71                    1122          NOP
00001E66  4E71                    1123          NOP
00001E68  4E71                    1124          NOP
00001E6A  4E71                    1125          NOP
00001E6C  4E71                    1126          NOP
00001E6E  4E71                    1127          NOP
00001E70  4E71                    1128          NOP
00001E72  4E71                    1129          NOP
00001E74  4E75                    1130          RTS * return on good modes
00001E76  4E71                    1131          NOP * 2 extra words needed for ofset to jmps
00001E78  4E71                    1132          NOP
00001E7A  4EF9 00001E8C           1133          JMP EA_ERR      * mode (d16,An)      
00001E80  4EF9 00001E8C           1134          JMP EA_ERR      * mode (d8,An,Xn)
00001E86  4EF9 00001EBC           1135          JMP MODE_7_CHK
00001E8C                          1136  
00001E8C                          1137          
00001E8C                          1138  * write error to string buffer and move on to next instruction
00001E8C                          1139  EA_ERR:
00001E8C  48E7 8040               1140          MOVEM.L D0/A1,-(SP)
00001E90  2039 00002212           1141          MOVE.L  END_OP_CODE_PTR,D0      * load end of opcode pointer
00001E96  0C80 00000000           1142          CMPI.L  #0,D0                   * if ptr is 0 use existing str buf value
00001E9C  6700 0004               1143          BEQ     LOAD_EA_ERR_MSG
00001EA0  2840                    1144          MOVEA.L D0,A4                   * reset string buffer pointer to end of opcode neumonic 
00001EA2                          1145          * load error message to buffer
00001EA2                          1146  LOAD_EA_ERR_MSG:
00001EA2  43F9 00002722           1147          LEA     EA_ERR_MSG,A1
00001EA8  4EB9 0000217E           1148          JSR     WRITE_ASCII
00001EAE  13FC 00FF 00002313      1149          MOVE.B  #-1,EA_ERR_FLAG
00001EB6  4CDF 0201               1150          MOVEM.L (SP)+,D0/A1
00001EBA  4E75                    1151          RTS
00001EBC                          1152  
00001EBC                          1153  * check mode 7 for invalid reg values
00001EBC                          1154  MODE_7_CHK:
00001EBC  48E7 4000               1155          MOVEM.L D1,-(SP)
00001EC0  B23C 0002               1156          CMP.B #%010,D1 * check for (d16,PC) 
00001EC4  67C6                    1157          BEQ   EA_ERR
00001EC6  B23C 0003               1158          CMP.B #%011,D1 * check for (d8,PC,Xn)
00001ECA  67C0                    1159          BEQ   EA_ERR
00001ECC  4CDF 0002               1160          MOVEM.L (SP)+,D1
00001ED0  4E75                    1161          RTS   
00001ED2                          1162  
00001ED2                          1163  * destination adress register and imediate mode are invalid eas
00001ED2                          1164  DEST_AN_IM_INVALID:
00001ED2  48E7 C000               1165          MOVEM.L D0-D1,-(SP)
00001ED6                          1166          * load source modes and registers
00001ED6                          1167    * load destination modes and registers
00001ED6  1039 0000230F           1168          MOVE.B  DEST_MODE,D0
00001EDC  1239 00002310           1169          MOVE.B  DEST_REG,D1
00001EE2  B03C 0001               1170          CMP.B   #1,D0   * if address register mode error
00001EE6  6600 000A               1171          BNE     AN_IM_01
00001EEA  4EB8 1E8C               1172          JSR     EA_ERR
00001EEE  6000 0016               1173          BRA     AN_IM_02
00001EF2                          1174  AN_IM_01:
00001EF2  B03C 0007               1175          CMP.B   #7,D0    * if immediate data error
00001EF6  6600 000E               1176          BNE     AN_IM_02
00001EFA  B23C 0004               1177          CMP.B   #4,D1
00001EFE  6600 0006               1178          BNE     AN_IM_02
00001F02  4EB8 1E8C               1179          JSR     EA_ERR     
00001F06                          1180  AN_IM_02: 
00001F06  4CDF 0003               1181          MOVEM.L (SP)+,D0-D1
00001F0A  4E75                    1182          RTS
00001F0C                          1183  
00001F0C                          1184  ***       UTILS     ****
00001F0C                          1185  
00001F0C                          1186  ADD_IMMEDIATE_TO_BUF:
00001F0C  48E7 4040               1187          MOVEM.L D1/A1,-(SP)
00001F10  1239 0000230E           1188          MOVE.B  INST_SZ,D1  * load instruction size
00001F16  0C01 0001               1189          CMPI.B  #BYTE,D1
00001F1A  6700 000A               1190          BEQ IN_IM_W     * if byte goto word since behavior is the same
00001F1E  0C01 0003               1191                  CMPI.B  #WORD,D1
00001F22  6600 001A               1192          BNE CMP_IM_L    * if not equal to word branch compare to long
00001F26                          1193  IN_IM_W:
00001F26  43F9 0000245B           1194          LEA _IMD,A1     * print next mem word as imediate data to buffer
00001F2C  4EB9 0000217E           1195          JSR WRITE_ASCII
00001F32  4EB9 00001F5A           1196          JSR NEXT_MEM_WORD_TO_BUF
00001F38  4CDF 0202               1197          MOVEM.L (SP)+,D1/A1
00001F3C  4E75                    1198          RTS
00001F3E                          1199  CMP_IM_L:
00001F3E  0C01 0002               1200          CMPI.B  #LONG,D1
00001F42                          1201  *       TODO BNE        EA ERROR
00001F42  43F9 0000245B           1202          LEA _IMD,A1      * print next mem long as imediate data to buffer
00001F48  4EB9 0000217E           1203          JSR WRITE_ASCII
00001F4E  4EB9 00001F70           1204          JSR     NEXT_MEM_LONG_TO_BUF
00001F54  4CDF 0202               1205          MOVEM.L (SP)+,D1/A1
00001F58  4E75                    1206          RTS
00001F5A                          1207  
00001F5A                          1208  * read next word of memory to str_buffer advancing current pointer
00001F5A                          1209  NEXT_MEM_WORD_TO_BUF:
00001F5A  48E7 4400               1210          MOVEM.L D1/D5,-(SP)
00001F5E  548D                    1211          ADDA.L  #2,A5   * advance pointer
00001F60  3215                    1212          MOVE.W  (A5),D1 * load next word of memory
00001F62  7A00                    1213          MOVEQ.L #0,D5   * set hex length to word
00001F64  4EB9 0000212C           1214          JSR     WRITE_HEX_TO_ASCII
00001F6A  4CDF 0022               1215          MOVEM.L (SP)+,D1/D5
00001F6E  4E75                    1216          RTS
00001F70                          1217          
00001F70                          1218  * read next Long of memory to str_buffer advancing current pointer
00001F70                          1219  NEXT_MEM_LONG_TO_BUF:
00001F70  48E7 4400               1220          MOVEM.L D1/D5,-(SP)
00001F74  548D                    1221          ADDA.L  #2,A5 * advance pointer
00001F76  2215                    1222          MOVE.L  (A5),D1
00001F78  548D                    1223          ADDA.L  #2,A5 * advance pointer again to account for long
00001F7A  7A20                    1224          MOVEQ.L #32,D5  * set hex length to long
00001F7C  4EB9 0000212C           1225          JSR     WRITE_HEX_TO_ASCII
00001F82  4CDF 0022               1226          MOVEM.L (SP)+,D1/D5
00001F86  4E75                    1227          RTS
00001F88                          1228  
00001F88                          1229  * prompts user for choice
00001F88                          1230  * sets d6 to valid choice
00001F88                          1231  GET_CHOICE: 
00001F88  48E7 C040               1232          MOVEM.L   D0/D1/A1,-(SP)
00001F8C                          1233  HC_INT_LP:
00001F8C  4EB9 000021F4           1234          JSR     RESET_BUF_PTR   * move a4 to start of string buffer
00001F92  43F9 000024FD           1235          LEA     CHOICE_PROMPT,A1
00001F98  4EB9 0000217E           1236          JSR     WRITE_ASCII
00001F9E  4EB9 000021CC           1237          JSR     TERM_PNT_RST_BUF
00001FA4  103C 0004               1238          MOVE.B  #4,D0   * read a number from keyboard into d1
00001FA8  4E4F                    1239          TRAP    #15
00001FAA                          1240  CHOICE_1:
00001FAA  0C41 0001               1241          CMPI    #DISSASEMBLE ,D1
00001FAE  6700 0024               1242          BEQ     CHOICE_DNE    
00001FB2                          1243  CHOICE_2:
00001FB2  0C41 0002               1244          CMPI    #QUIT_PROG,D1
00001FB6  6700 001C               1245          BEQ     CHOICE_DNE    
00001FBA                          1246  CHOICE_ERR:
00001FBA  43F9 00002552           1247          LEA     INV_CHOICE,A1
00001FC0  4EB9 0000217E           1248          JSR     WRITE_ASCII
00001FC6  4EB9 000021CC           1249          JSR     TERM_PNT_RST_BUF
00001FCC  4EB9 00001FDC           1250          JSR     WAIT_USR_INPUT
00001FD2  60B8                    1251          BRA     HC_INT_LP
00001FD4                          1252          
00001FD4                          1253  CHOICE_DNE:
00001FD4  1C01                    1254          MOVE.B  D1,D6
00001FD6  4CDF 0203               1255          MOVEM.L   (SP)+,D0/D1/A1
00001FDA  4E75                    1256          RTS               
00001FDC                          1257  
00001FDC                          1258  * prompt user to press enter to continue
00001FDC                          1259  WAIT_USR_INPUT:            
00001FDC  48E7 C040               1260          MOVEM.L   D0/D1/A1,-(SP)
00001FE0  43F9 0000256D           1261          LEA     ENT_TO_CONT,A1  * load and print prompt
00001FE6  4EB9 0000211C           1262          JSR     PRINT_A1
00001FEC  7005                    1263          MOVEQ.L #5,D0   * read in a char from keyboard
00001FEE  4E4F                    1264          TRAP    #15
00001FF0  4CDF 0203               1265          MOVEM.L   (SP)+,D0/D1/A1
00001FF4  4E75                    1266          RTS
00001FF6                          1267  
00001FF6                          1268  LOAD_DATA_STR_INTO_BUF: * expects address to be in a5
00001FF6  48E7 4000               1269          MOVEM.L   D1,-(SP)
00001FFA  4EB9 000021F4           1270          JSR     RESET_BUF_PTR
00002000  220D                    1271          MOVE.L  A5,D1
00002002  7A20                    1272          MOVEQ   #32,D5   * set hex length to long for address
00002004  4EB9 0000212C           1273          JSR     WRITE_HEX_TO_ASCII * write memory address to buffer
0000200A  4EB9 000021A8           1274          JSR     WRITE_TAB_A4    * wrtie a tab
00002010  43F9 00002743           1275          LEA     DATA_MSG,A1     * Load template for data
00002016  4EB9 0000217E           1276          JSR     WRITE_ASCII     * write 'DATA    $' to buffer
0000201C  3215                    1277          MOVE.W  (A5),D1   * load address contents of memory to d1 for printing
0000201E  7A00                    1278          MOVEQ   #0,D5   * set hex length to word for memory contents
00002020  4EB9 0000212C           1279          JSR     WRITE_HEX_TO_ASCII * save to buffer
00002026  4CDF 0002               1280          MOVEM.L   (SP)+,D1
0000202A  4E75                    1281          RTS
0000202C                          1282  
0000202C  103C 0009               1283  DONE    MOVE.B  #9,D0       * Trap task 9 halt simulator
00002030  4E4F                    1284          TRAP    #15
00002032                          1285          
00002032                          1286  * Converts ASCII string containing chars 0-9 and A-F uppercase to hexidecimal number
00002032                          1287  * returns result in D6
00002032                          1288  TO_HEX
00002032  48E7 E060               1289          MOVEM.L   D0-D2/A1-A2,-(SP)   * save state of registers to be changed
00002036  4282                    1290          CLR.L   D2      * clear to hold digit magnitude
00002038  4286                    1291          CLR.L   D6      * clear to hold result
0000203A  5341                    1292          SUBI    #1,D1    * subtract 1
0000203C  C2FC 0004               1293          MULU    #4,D1   * multiply length by four to get length in binary
00002040                          1294          
00002040                          1295  TO_HEX_INTERNAL:
00002040  1019                    1296          MOVE.B  (A1)+,D0     * Load char at A1 into D0
00002042  6700 001A               1297          BEQ     END_H       * GOTO end if byte is zero (null terminated)
00002046  0C40 0039               1298          CMPI    #$39,D0     * compare char value to 39
0000204A  6F00 0004               1299          BLE     _0_9        * GOTO 0_9 if <= 39
0000204E  5F00                    1300  A_F     SUBI.B  #$7,D0      * Subtract 7 from D0) for ASCII A-F
00002050  0200 000F               1301  _0_9    ANDI.B  #$0F,D0     * AND with 00001111 to isolate left most 4 bits, converts to hex
00002054  2400                    1302          MOVE.L  D0,D2        * put hex digit in D2
00002056  E3AA                    1303          LSL.L   D1,D2       * shift hex digit final postion    
00002058  DC82                    1304          ADD.L   D2,D6       * add to hex result
0000205A  5981                    1305          SUBI.L    #4,D1       * subract one hex digit of bits from remaining length 
0000205C  60E2                    1306          BRA     TO_HEX_INTERNAL   * convert next byte
0000205E  4CDF 0607               1307  END_H   MOVEM.L (SP)+,D0-D2/A1-A2
00002062  4E75                    1308          RTS
00002064                          1309  
00002064                          1310  
00002064                          1311  *   input address to hexadecimal saves output at A1
00002064                          1312  IN_ADDR_TO_HEX:
00002064  48E7 0200               1313          MOVEM.L   D6,-(SP)
00002068  4EB8 2032               1314          JSR     TO_HEX          * else convert to hex
0000206C  2286                    1315          MOVE.L  D6,(A1)
0000206E  4CDF 0040               1316          MOVEM.L   (SP)+,D6
00002072  4E75                    1317          RTS
00002074                          1318  
00002074                          1319  * check start and end addresses for errors
00002074                          1320  CHK_ST_E_ADRS: * sets D5 to 1 if an error has ocurred
00002074  48E7 4800               1321          MOVEM.L   D1/D4,-(SP)
00002078  7A00                    1322          MOVEQ   #0,D5       * clear error flag
0000207A  2439 000021FA           1323          MOVE.L  ST_ADDR,D2  * load start address
00002080  2639 00002206           1324          MOVE.L  E_ADDR,D3   * load end address
00002086                          1325          
00002086                          1326  LEN_CHK:                    * check address length
00002086  1239 0000221A           1327          MOVE.B  ST_LEN,D1   * load start and end address lengths
0000208C  1839 0000221B           1328          MOVE.B  E_LEN,D4
00002092                          1329          
00002092  0C01 0008               1330          CMPI.B  #8,D1       * check if start addr length is less than or equal to 8
00002096  6F00 000E               1331          BLE     E_LEN_CHK   * check end address if no length error
0000209A  4EB9 000020DA           1332          JSR     PLEN_ERR    * print length error message
000020A0  7A01                    1333          MOVEQ   #1,D5       * set error flag
000020A2  6000 0012               1334          BRA     ODD_CHK     * skip end length check if start failed
000020A6                          1335  E_LEN_CHK:
000020A6  0C04 0008               1336          CMPI.B  #8,D4
000020AA  6F00 000A               1337          BLE     ODD_CHK     * if no error skip to odd checking
000020AE  4EB9 000020DA           1338          JSR     PLEN_ERR    * print length error message
000020B4  7A01                    1339          MOVEQ   #1,D5       * set error flag
000020B6                          1340  
000020B6                          1341  ODD_CHK:                    * check if start address is odd
000020B6  0802 0000               1342          BTST.L  #0,D2       * test start addres LSB to see if even
000020BA  6700 000A               1343          BEQ     S_GT_E
000020BE  4EB9 000020F0           1344          JSR     PODD_ERR    * print odd start address error
000020C4  7A01                    1345          MOVEQ   #1,D5       * set error flag
000020C6                          1346          
000020C6                          1347  S_GT_E:                     * start address greater than or less than end
000020C6  B483                    1348          CMP.L   D3,D2      * check if end is greater than or equal to start
000020C8  6F00 000A               1349          BLE     CHK_SEA_DONE   * skip to end if no error
000020CC  4EB9 00002106           1350          JSR     PS_GT_ERR   * print start greater than end error
000020D2  7A01                    1351          MOVEQ   #1,D5       * set error flag
000020D4                          1352        
000020D4                          1353  CHK_SEA_DONE:
000020D4  4CDF 0012               1354          MOVEM.L   (SP)+,D1/D4
000020D8  4E75                    1355          RTS             
000020DA                          1356          
000020DA                          1357  *   print address length input error
000020DA                          1358  PLEN_ERR:
000020DA  48E7 0040               1359          MOVEM.L   A1,-(SP) 
000020DE  43F9 0000261F           1360          LEA     ADR_LEN_ERR,A1   * load address input error message 
000020E4  4EB9 0000211C           1361          JSR     PRINT_A1
000020EA  4CDF 0200               1362          MOVEM.L   (SP)+,A1
000020EE  4E75                    1363          RTS         
000020F0                          1364  
000020F0                          1365  PODD_ERR: * print start address odd error
000020F0  48E7 0040               1366          MOVEM.L   A1,-(SP) 
000020F4  43F9 00002664           1367          LEA     ADR_ODD_ERR,A1
000020FA  4EB9 0000211C           1368          JSR     PRINT_A1
00002100  4CDF 0200               1369          MOVEM.L   (SP)+,A1
00002104  4E75                    1370          RTS
00002106                          1371  
00002106                          1372  PS_GT_ERR: * print start address greater than end address error
00002106  48E7 0040               1373          MOVEM.L   A1,-(SP) 
0000210A  43F9 0000269A           1374          LEA     ADR_S_GT_E,A1
00002110  4EB9 0000211C           1375          JSR     PRINT_A1
00002116  4CDF 0200               1376          MOVEM.L   (SP)+,A1
0000211A  4E75                    1377          RTS
0000211C                          1378  
0000211C                          1379   
0000211C                          1380  PRINT_A1:
0000211C  48E7 8000               1381          MOVEM.L   D0,-(SP) * save register state
00002120  103C 000E               1382          MOVE.B  #14,D0   * print A1
00002124  4E4F                    1383          TRAP    #15
00002126  4CDF 0001               1384          MOVEM.L   (SP)+,D0  *  restore register state
0000212A  4E75                    1385          RTS
0000212C                          1386  
0000212C                          1387  ****************************************************
0000212C                          1388  * Subroutines for printing and writing to and from
0000212C                          1389  * the string buffer at A4
0000212C                          1390  ****************************************************        
0000212C                          1391  
0000212C                          1392  * d5 is a flag for hex value length d5==32 long is used
0000212C                          1393  * any other value short is used        
0000212C                          1394  WRITE_HEX_TO_ASCII: * write hex in d1 to a4 as ascii
0000212C                          1395          * may need to add case to handle sign extended shorts
0000212C  48E7 3800               1396          MOVEM.L   D2-D4,-(SP)
00002130  2401                    1397          MOVE.L  D1,D2   * copy input to working temp var
00002132  0C85 00000020           1398          CMPI.L  #32,D5           * if masked value is 0 there is no value in long portion of register for unsigned ints
00002138  6600 000E               1399          BNE     h_short         * if not 32 hex value is short else long
0000213C                          1400          * setup params for long processing
0000213C  263C F0000000           1401          MOVE.L  #$F0000000,D3   * init mask for isolating first long hex most significand digit
00002142  781C                    1402          MOVE.L  #28,D4          * init shift value for first long hex MSD
00002144  6000 000A               1403          BRA     h_a_loop
00002148                          1404          
00002148                          1405  h_short: * setup params for short processing
00002148  263C 0000F000           1406          MOVE.L  #$F000,D3   * init mask for isolating first short hex most significand digit
0000214E  780C                    1407          MOVE.L  #12,D4      * init shift value for first short hex MSD
00002150                          1408          
00002150                          1409  h_a_loop:
00002150  0C84 00000000           1410          CMPI.L  #0,D4   * compare shift value to 0
00002156  6D00 0020               1411          BLT     h_a_dne * done if less than 0
0000215A  2401                    1412          MOVE.L  D1,D2   * copy input to working temp var
0000215C  C483                    1413          AND.L   D3,D2   * isolate digit
0000215E  E8AA                    1414          LSR.L   D4,D2   * shift to rightmost position
00002160                          1415          
00002160  0C82 0000000A           1416          CMPI.L  #$A,D2   * compare to A
00002166  6D00 0004               1417          BLT     h_a_low  * if less than A 0-9
0000216A  5E42                    1418          ADDI    #7,D2    * add an additional 7 to A-F     
0000216C                          1419  h_a_low:
0000216C  0642 0030               1420          ADDI    #$30,D2  * add $30 to convert to ascii
00002170  18C2                    1421          MOVE.B  D2,(A4)+ * write digit to pointer location
00002172                          1422          
00002172  E88B                    1423          LSR.L   #4,D3   * shift mask to isolate next hex digit
00002174  5984                    1424          SUBI.L  #4,D4   * subtract shift for next digit
00002176  60D8                    1425          BRA     h_a_loop    * return to loop start
00002178  4CDF 001C               1426  h_a_dne MOVEM.L   (SP)+,D2-D4
0000217C  4E75                    1427          RTS
0000217E                          1428  
0000217E                          1429  WRITE_ASCII:    * copies null terminated string from A1 to A4 without null
0000217E  48E7 4040               1430          MOVEM.L   D1/A1,-(SP)
00002182                          1431  w_a_loop:
00002182  1219                    1432          MOVE.B  (A1)+,D1    * load value at A1
00002184  6700 0006               1433          BEQ     w_a_done    * if 0(null) is moved copy is done
00002188  18C1                    1434          MOVE.B  D1,(A4)+    * else copy value to A4
0000218A  60F6                    1435          BRA     w_a_loop
0000218C                          1436  w_a_done:
0000218C  4CDF 0202               1437          MOVEM.L   (SP)+,D1/A1
00002190  4E75                    1438          RTS
00002192                          1439  
00002192                          1440  WRITE_NULL_A4: * used to terminate a string in memory 
00002192  18FC 0000               1441          MOVE.B  #0,(A4)+
00002196  4E75                    1442          RTS
00002198                          1443          
00002198                          1444  WRITE_SPC_A4: * writes an ascii space at a4
00002198  18FC 0020               1445          MOVE.B  #SPACE,(A4)+
0000219C  4E75                    1446          RTS 
0000219E                          1447  
0000219E                          1448  WRITE_NL_A4: * writes a newline at a4
0000219E  18FC 000D               1449          MOVE.B  #CR,(A4)+
000021A2  18FC 000A               1450          MOVE.B  #LF,(A4)+
000021A6  4E75                    1451          RTS
000021A8                          1452          
000021A8                          1453  WRITE_TAB_A4:
000021A8  18FC 0009               1454          MOVE.B  #TAB,(A4)+
000021AC  4E75                    1455          RTS   
000021AE                          1456  
000021AE                          1457  * writes current string buffer pointer address to end_op_code_ptr
000021AE                          1458  SET_END_OP_CODE_PTR:
000021AE  23CC 00002212           1459          MOVE.L  A4,END_OP_CODE_PTR
000021B4  4E75                    1460          RTS
000021B6                          1461  
000021B6                          1462  NL_TERM_PNT_RST_BUF: * write newline, null then print contents then reset bufffer
000021B6  4EB8 219E               1463          JSR     WRITE_NL_A4
000021BA  4EB8 2192               1464          JSR     WRITE_NULL_A4
000021BE  4EB9 000021DE           1465          JSR     PRINT_STR_BUF
000021C4  4EB9 000021F4           1466          JSR     RESET_BUF_PTR
000021CA  4E75                    1467          RTS
000021CC                          1468          
000021CC                          1469  TERM_PNT_RST_BUF: * write null then print contents then reset bufffer pointer
000021CC  4EB8 2192               1470          JSR     WRITE_NULL_A4
000021D0  4EB9 000021DE           1471          JSR     PRINT_STR_BUF
000021D6  4EB9 000021F4           1472          JSR     RESET_BUF_PTR
000021DC  4E75                    1473          RTS
000021DE                          1474          
000021DE                          1475  PRINT_STR_BUF: * prints string buffer contents to console
000021DE  48E7 8040               1476          MOVEM.L   D0/A1,-(SP)
000021E2  43F9 0000221D           1477          LEA     STR_BUF,A1  * load string buffer
000021E8  303C 000E               1478          MOVE    #14,D0       * print contents
000021EC  4E4F                    1479          TRAP    #15
000021EE  4CDF 0201               1480          MOVEM.L   (SP)+,D0/A1
000021F2  4E75                    1481          RTS
000021F4                          1482  
000021F4                          1483  RESET_BUF_PTR:  * sets a4 to start of string buffer
000021F4  387C 221D               1484          MOVEA   #STR_BUF,A4
000021F8  4E75                    1485          RTS        
000021FA                          1486  
000021FA                          1487  ****    VARS    ****
000021FA                          1488  ST_ADDR DS.L    3   * allocate 3 longs for address ascii input needs 9 bytes to get 8 chars 
00002206                          1489  E_ADDR  DS.L    3   * and null terminator, allocating 12 bytes to account for this
00002212                          1490  
00002212                          1491  END_OP_CODE_PTR:
00002212= 00000000                1492          DCB.L   1,0 * pointer to end of opcode neumonic in the string buffer, used for ea errors
00002216                          1493  
00002216                          1494  CURRENT_ADDR:
00002216= 00000000                1495          DCB.L   1,0 * BACKUP FOR CURRENT ADDRESS POINTER
0000221A                          1496  
0000221A= 00                      1497  ST_LEN  DCB.B   1,0 * var to track start address length
0000221B= 01 00                   1498  E_LEN   DC.B    1,0 * var to track end address length
0000221D= 00 00 00 00 00 00 ...   1499  STR_BUF DCB.B   241,0  * buffer to hold 240 chars + null terminator. 3 80 char lines
0000230E= 00                      1500  INST_SZ DCB.B   1,0     * used to store instuction size
0000230F                          1501  DEST_MODE:
0000230F= 00                      1502          DCB.B   1,0     * var for destination ea mode
00002310                          1503  DEST_REG:
00002310= 00                      1504          DCB.B   1,0     * var to save destination register in
00002311                          1505  SRC_MODE:
00002311= 00                      1506          DCB.B   1,0     * var for source ea mode
00002312                          1507  SRC_REG: 
00002312= 00                      1508          DCB.B   1,0     * var to save source register in  
00002313                          1509  EA_ERR_FLAG:
00002313= 00                      1510          DCB.B   1,0     * var for ea error status
00002314                          1511           
00002314                          1512  ****    CONST   ****
00002314  =0000000D               1513  CR          EQU     $0D     * carraige return          
00002314  =0000000A               1514  LF          EQU     $0A     * line feed
00002314  =00000020               1515  SPACE       EQU     $20     * ascii space
00002314  =00000009               1516  TAB         EQU     $09     * ascii tab character
00002314  =00000001               1517  DISSASEMBLE EQU     $01     * dissasemble choice number
00002314  =00000002               1518  QUIT_PROG   EQU     $02     * quit choice number
00002314  =00000001               1519  BYTE        EQU     %01
00002314  =00000003               1520  WORD        EQU     %11
00002314  =00000002               1521  LONG        EQU     %10
00002314                          1522  
00002314                          1523  * masks for isolating nibbles with and 0 being least significant nibble
00002314  =0000F000               1524  Nib3Mask    EQU     $F000 
00002314  =00000F00               1525  Nib2Mask    EQU     $0F00
00002314  =000000F0               1526  Nib1Mask    EQU     $00F0
00002314  =0000000F               1527  Nib0Mask    EQU     $000F
00002314                          1528  
00002314  =00000E00               1529  Bit0Mask    EQU     $0E00
00002314  =000001C0               1530  Bit1Mask    EQU     $01C0
00002314  =00000038               1531  Bit2Mask    EQU     $0038
00002314  =00000007               1532  Bit3Mask    EQU     $0007
00002314                          1533  
00002314  =000000FF               1534  Byte0Mask   EQU     $00FF
00002314  =0000FF00               1535  Byte1Mask   EQU     $FF00
00002314                          1536  
00002314                          1537  ****    Instructions    ****
00002314= 4E 4F 54 2E 42 20 00    1538  _NOT_B  DC.B    'NOT.B ',0
0000231B= 4E 4F 54 2E 57 20 00    1539  _NOT_W  DC.B    'NOT.W ',0
00002322= 4E 4F 54 2E 4C 20 00    1540  _NOT_L  DC.B    'NOT.L ',0
00002329= 4E 4F 50 20 00          1541  _NOP    DC.B    'NOP ',0
0000232E= 52 54 53 20 00          1542  _RTS    DC.B    'RTS ',0
00002333= 4D 4F 56 45 4D 2E ...   1543  _MOVEM_W DC.B   'MOVEM.W ',0
0000233C= 4D 4F 56 45 4D 2E ...   1544  _MOVEM_L DC.B   'MOVEM.L ',0
00002345= 4D 4F 56 45 2E 42 ...   1545  _MOVE_B DC.B    'MOVE.B ',0
0000234D= 4D 4F 56 45 2E 4C ...   1546  _MOVE_L DC.B    'MOVE.L ',0
00002355= 4D 4F 56 45 2E 57 ...   1547  _MOVE_W DC.B    'MOVE.W ',0
0000235D= 4D 4F 56 45 41 2E ...   1548  _MOVEA_L DC.B   'MOVEA.L ',0
00002366= 4D 4F 56 45 41 2E ...   1549  _MOVEA_W DC.B   'MOVEA.W ',0
0000236F= 4A 53 52 20 00          1550  _JSR    DC.B    'JSR ',0
00002374= 4C 45 41 20 00          1551  _LEA    DC.B    'LEA ',0
00002379= 41 44 44 51 2E 42 ...   1552  _ADDQ_B DC.B    'ADDQ.B ',0
00002381= 41 44 44 51 2E 57 ...   1553  _ADDQ_W DC.B    'ADDQ.W ',0
00002389= 41 44 44 51 2E 4C ...   1554  _ADDQ_L DC.B    'ADDQ.L ',0
00002391= 42 52 41 20 00          1555  _BRA    DC.B    'BRA ',0
00002396= 42 45 51 20 00          1556  _BEQ    DC.B    'BEQ ',0
0000239B= 42 47 54 20 00          1557  _BGT    DC.B    'BGT ',0
000023A0= 42 4C 45 20 00          1558  _BLE    DC.B    'BLE ',0
000023A5= 4D 4F 56 45 51 20 00    1559  _MOVEQ  DC.B    'MOVEQ ',0
000023AC= 44 49 56 55 20 00       1560  _DIVU   DC.B    'DIVU ',0
000023B2= 4F 52 00                1561  _OR     DC.B    'OR',0
000023B5= 2E 42 20 00             1562  _B   DC.B    '.B ',0
000023B9= 2E 57 20 00             1563  _W   DC.B    '.W ',0
000023BD= 2E 4C 20 00             1564  _L   DC.B    '.L ',0
000023C1= 53 55 42 20 00          1565  _SUB    DC.B    'SUB ',0
000023C6= 4D 55 4C 53 20 00       1566  _MULS   DC.B    'MULS ',0
000023CC= 41 4E 44 20 00          1567  _AND    DC.B    'AND ',0
000023D1= 41 44 44 20 00          1568  _ADD    DC.B    'ADD ',0
000023D6= 41 44 44 41 20 00       1569  _ADDA   DC.B    'ADDA ',0
000023DC= 41 53 4C 20 00          1570  _ASL    DC.B    'ASL ',0
000023E1= 41 53 52 20 00          1571  _ASR    DC.B    'ASR ',0
000023E6= 4C 53 4C 20 00          1572  _LSL    DC.B    'LSL ',0
000023EB= 4C 53 52 20 00          1573  _LSR    DC.B    'LSR ',0
000023F0= 41 53 4C 2E 42 20 00    1574  _ASL_B  DC.B    'ASL.B ',0
000023F7= 41 53 4C 2E 57 20 00    1575  _ASL_W  DC.B    'ASL.W ',0
000023FE= 41 53 4C 2E 4C 20 00    1576  _ASL_L  DC.B    'ASL.L ',0
00002405= 41 53 52 2E 42 20 00    1577  _ASR_B  DC.B    'ASR.B ',0
0000240C= 41 53 52 2E 57 20 00    1578  _ASR_W  DC.B    'ASR.W ',0
00002413= 41 53 52 2E 4C 20 00    1579  _ASR_L  DC.B    'ASR.L ',0
0000241A= 4C 53 4C 2E 42 20 00    1580  _LSL_B  DC.B    'LSL.B ',0
00002421= 4C 53 4C 2E 57 20 00    1581  _LSL_W  DC.B    'LSL.W ',0
00002428= 4C 53 4C 2E 4C 20 00    1582  _LSL_L  DC.B    'LSL.L ',0
0000242F= 4C 53 52 2E 42 20 00    1583  _LSR_B  DC.B    'LSR.B ',0
00002436= 4C 53 52 2E 57 20 00    1584  _LSR_W  DC.B    'LSR.W ',0
0000243D= 4C 53 52 2E 4C 20 00    1585  _LSR_L  DC.B    'LSR.L ',0
00002444                          1586  
00002444                          1587  ****    Modes    ****
00002444= 44 00                   1588  _DR             DC.B   'D',0
00002446= 41 00                   1589  _AR             DC.B   'A',0
00002448= 28 41 00                1590  _IND_AR1        DC.B   '(A',0
0000244B= 29 00                   1591  _IND_AR2        DC.B   ')',0
0000244D= 28 41 00                1592  _AR_POST1       DC.B   '(A',0
00002450= 29 2B 00                1593  _AR_POST2       DC.B   ')+',0
00002453= 2D 28 41 00             1594  _AR_PRE1        DC.B   '-(A',0
00002457= 29 00                   1595  _AR_PRE2        DC.B   ')',0
00002459= 24 00                   1596  _ABS            DC.B    '$',0
0000245B= 23 00                   1597  _IMD            DC.B    '#',0
0000245D                          1598  
0000245D                          1599  ****    Numbers    ****
0000245D= 30 00                   1600  _ZERO   DC.B    '0',0
0000245F= 31 00                   1601  _ONE    DC.B    '1',0
00002461= 32 00                   1602  _TWO    DC.B    '2',0
00002463= 33 00                   1603  _THREE  DC.B    '3',0
00002465= 34 00                   1604  _FOUR   DC.B    '4',0
00002467= 35 00                   1605  _FIVE   DC.B    '5',0
00002469= 36 00                   1606  _SIX    DC.B    '6',0
0000246B= 37 00                   1607  _SEVEN  DC.B    '7',0
0000246D= 2C 00                   1608  _COMMA  DC.B    ',',0
0000246F                          1609  
0000246F                          1610  ****    MODE CMP VALUES    ****
0000246F  =00000000               1611  cDR             EQU     $0000
0000246F  =00000040               1612  cAR             EQU     $0040
0000246F  =00000080               1613  cIND_AR         EQU     $0080
0000246F  =000000C0               1614  cAR_POST        EQU     $00C0
0000246F  =00000100               1615  cAR_PRE         EQU     $0100
0000246F  =000001C0               1616  cABS            EQU     $01C0
0000246F                          1617  
0000246F                          1618  ****    MESSAGES    ****
0000246F                          1619  
0000246F= 2A 2A 2A 2A 2A 2A ...   1620  WELCOME     DC.B    '*********************************************',CR,LF
0000249E= 2A 20 57 65 6C 63 ...   1621              DC.B    '* Welcome to EASY 68K Disasembler by Nibble *',CR,LF
000024CD= 2A 2A 2A 2A 2A 2A ...   1622              DC.B    '*********************************************',CR,LF,0
000024FD                          1623              
000024FD                          1624  CHOICE_PROMPT:
000024FD= 45 6E 74 65 72 20 ...   1625              DC.B    'Enter a number to make a choice:',CR,LF
0000251F= 31 3A 20 44 69 73 ...   1626              DC.B    '1: Dissasemble an Address Range',CR,LF
00002540= 32 3A 20 45 78 69 ...   1627              DC.B    '2: Exit Program',CR,LF,0
00002552                          1628         
00002552= 45 52 52 4F 52 3A ...   1629  INV_CHOICE  DC.B    'ERROR: INVALID selection',CR,LF,0
0000256D                          1630  
0000256D= 0D 0A 50 72 65 73 ...   1631  ENT_TO_CONT DC.B    CR,LF,'Press enter to continue...',CR,LF,0
0000258C                          1632  
0000258C= 0D 0A 45 6E 74 65 ...   1633  ST_A_MSG    DC.B    CR,LF,'Enter an address range in hexidecimal to be dissasembled',CR,LF * start address message
000025C8= 56 61 6C 69 64 20 ...   1634              DC.B    'Valid address chars: 0-1 A-F case insensitive',CR,LF  
000025F7= 45 6E 74 65 72 20 ...   1635              DC.B    'Enter start address:',0    
0000260C                          1636              
0000260C= 45 6E 74 65 72 20 ...   1637  E_A_MSG     DC.B    'Enter end address:',0    * end address message
0000261F                          1638  
0000261F= 0D 0A 45 52 52 4F ...   1639  ADR_LEN_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-8 hexidecimal digits long',CR,LF,0    * address input error message
00002664                          1640  
00002664= 0D 0A 45 52 52 4F ...   1641  ADR_ODD_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must be even',CR,LF,0  * odd input address error message
0000269A                          1642              
0000269A= 0D 0A 45 52 52 4F ...   1643  ADR_S_GT_E  DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must come before end address',CR,LF,0 * start greater than end address error msg
000026E0                          1644  
000026E0= 0D 0A 45 52 52 4F ...   1645  HEX_ERR     DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-1 A-F case insensitive',CR,LF,0
00002722                          1646  
00002722= 45 52 52 4F 52 3A ...   1647  EA_ERR_MSG  DC.B    'ERROR: INVALID EFFECTIVE ADDRESS',0      * error message for invalid eas
00002743                          1648  
00002743= 44 41 54 41 20 20 ...   1649  DATA_MSG    DC.B    'DATA   $',0
0000274C                          1650  
0000274C= 43 4F 4E 56 45 52 ...   1651  TEST_MSG    DC.B    'CONVERTED ADDRESS IS: ',0  * test message for printing start and end addresses
00002763                          1652              
00002763                          1653              END     INIT        * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDQ_               1454
ADD_IMMEDIATE_TO_BUF  1F0C
ADR_LEN_ERR         261F
ADR_ODD_ERR         2664
ADR_S_GT_E          269A
AN_IM_01            1EF2
AN_IM_02            1F06
ASL_ASR_MEM         16D4
ASL_ASR_REG         1796
A_F                 204E
BASE_EA_ERR_CHK     1E0E
BASE_EA_ERR_MODES   1E5C
BIT0MASK            E00
BIT1MASK            1C0
BIT2MASK            38
BIT3MASK            7
BYTE                1
BYTE0MASK           FF
BYTE1MASK           FF00
CABS                1C0
CAR                 40
CAR_POST            C0
CAR_PRE             100
CDR                 0
CHK_LFT_NIB         1108
CHK_SEA_DONE        20D4
CHK_ST_E_ADRS       2074
CHOICE_1            1FAA
CHOICE_2            1FB2
CHOICE_DNE          1FD4
CHOICE_ERR          1FBA
CHOICE_PROMPT       24FD
CIND_AR             80
CMP_IM_L            1F3E
CR                  D
CURRENT_ADDR        2216
DATA_MSG            2743
DECODE_DONE         1174
DEST_AN_IM_INVALID  1ED2
DEST_MODE           230F
DEST_REG            2310
DISSASEMBLE         1
DIVU_EA             1A44
DONE                202C
D_TO_EA             1B4A
EA000               1C82
EA001               1C9A
EA010               1CB2
EA011               1CD6
EA100               1CFA
EA101               1D1E
EA110               1D20
EA111               1D22
EA111_R1            1D42
EA111_R4            1D5E
EA_ERR              1E8C
EA_ERR_FLAG         2313
EA_ERR_MSG          2722
EA_MODE             1C52
EA_MODE_DONE        1D6C
EA_REG              1D6E
EA_TO_D             1ADC
END_H               205E
END_OP_CODE_PTR     2212
ENT_TO_CONT         256D
E_ADDR              2206
E_A_MSG             260C
E_LEN               221B
E_LEN_CHK           20A6
GET_CHOICE          1F88
HC_INT_LP           1F8C
HEX_ERR             26E0
H_A_DNE             2178
H_A_LOOP            2150
H_A_LOW             216C
H_SHORT             2148
INIT                1000
INPUT_START         1028
INST_SZ             230E
INV_CHOICE          2552
IN_ADDR_TO_HEX      2064
IN_IM_W             1F26
LEA_EA              19DE
LEN_CHK             2086
LF                  A
LOAD_ADD            1684
LOAD_ADDA           1662
LOAD_ADDQ_B         1472
LOAD_ADDQ_L         14BA
LOAD_ADDQ_W         1496
LOAD_AND            1626
LOAD_ASL_B_REG      1828
LOAD_ASL_L_REG      1864
LOAD_ASL_MEM        1706
LOAD_ASL_W_REG      1846
LOAD_ASR_B_REG      17CE
LOAD_ASR_L_REG      180A
LOAD_ASR_MEM        16EA
LOAD_ASR_W_REG      17EC
LOAD_BEQ            151A
LOAD_BGT            1536
LOAD_BLE            154C
LOAD_BRA            1504
LOAD_DATA_STR_INTO_BUF  1FF6
LOAD_DIVU           158E
LOAD_EA_ERR_MSG     1EA2
LOAD_JSR            13F6
LOAD_LEA            13D4
LOAD_LSL_B_REG      1914
LOAD_LSL_L_REG      1950
LOAD_LSL_MEM        1754
LOAD_LSL_W_REG      1932
LOAD_LSR_B_REG      18BA
LOAD_LSR_L_REG      18F6
LOAD_LSR_MEM        1738
LOAD_LSR_W_REG      18D8
LOAD_MOVEA_L        11DC
LOAD_MOVEA_W        124C
LOAD_MOVEM_L        1430
LOAD_MOVEM_W        140C
LOAD_MOVEQ          1562
LOAD_MOVE_B         1196
LOAD_MOVE_L         1206
LOAD_MOVE_W         1276
LOAD_MULS           160A
LOAD_NOP            13A8
LOAD_NOT_B          1302
LOAD_NOT_L          1356
LOAD_NOT_W          132C
LOAD_OR             15B0
LOAD_RTS            13BE
LOAD_SUB            15D2
LONG                2
LSL_LSR_MEM         1722
LSL_LSR_REG         1882
MEMORY_SHIFT        16BE
MODE_7_CHK          1EBC
MOVE_EA             196E
NEXT_MEM_LONG_TO_BUF  1F70
NEXT_MEM_WORD_TO_BUF  1F5A
NIB0MASK            F
NIB1MASK            F0
NIB2MASK            F00
NIB3MASK            F000
NL_TERM_PNT_RST_BUF  21B6
NOP_RTS_JSR         1380
NOT_                12E4
NO_EA_ERROR         118C
ODD_CHK             20B6
OM000               1BE8
OM001               1BF8
OM010               1C08
OM011               1C18
OM100               1C1A
OM101               1C2C
OM110               1C3E
OM111               1C50
OPMODE              1BB8
OPMODE_EA           1AAE
OP_2                11C6
OP_3                1236
OP_4                12A6
OP_6                14DE
OP_8                1578
OP_C                15F4
OP_CODES            10AC
OP_D                1648
OP_DONE             1194
OP_E                16A6
OP_ERR              116E
OP_START            10BE
PLEN_ERR            20DA
PODD_ERR            20F0
PRINT_A1            211C
PRINT_STR_BUF       21DE
PS_GT_ERR           2106
QUIT                10A6
QUIT_PROG           2
REG000              1D9E
REG001              1DAC
REG010              1DBA
REG011              1DC8
REG100              1DD6
REG101              1DE4
REG110              1DF2
REG111              1E00
REG_SHIFT           1770
RESET_BUF_PTR       21F4
SET_END_OP_CODE_PTR  21AE
SPACE               20
SRC_MODE            2311
SRC_REG             2312
START               101A
STR_BUF             221D
ST_ADDR             21FA
ST_A_MSG            258C
ST_DIS              1096
ST_LEN              221A
S_GT_E              20C6
TAB                 9
TERM_PNT_RST_BUF    21CC
TEST_MSG            274C
TO_HEX              2032
TO_HEX_INTERNAL     2040
WAIT_USR_INPUT      1FDC
WELCOME             246F
WORD                3
WRITE_ASCII         217E
WRITE_HEX_TO_ASCII  212C
WRITE_NL_A4         219E
WRITE_NULL_A4       2192
WRITE_SPC_A4        2198
WRITE_TAB_A4        21A8
W_A_DONE            218C
W_A_LOOP            2182
_0_9                2050
_ABS                2459
_ADD                23D1
_ADDA               23D6
_ADDQ_B             2379
_ADDQ_L             2389
_ADDQ_W             2381
_AND                23CC
_AR                 2446
_AR_POST1           244D
_AR_POST2           2450
_AR_PRE1            2453
_AR_PRE2            2457
_ASL                23DC
_ASL_B              23F0
_ASL_L              23FE
_ASL_W              23F7
_ASR                23E1
_ASR_B              2405
_ASR_L              2413
_ASR_W              240C
_B                  23B5
_BEQ                2396
_BGT                239B
_BLE                23A0
_BRA                2391
_COMMA              246D
_DIVU               23AC
_DR                 2444
_FIVE               2467
_FOUR               2465
_IMD                245B
_IND_AR1            2448
_IND_AR2            244B
_JSR                236F
_L                  23BD
_LEA                2374
_LSL                23E6
_LSL_B              241A
_LSL_L              2428
_LSL_W              2421
_LSR                23EB
_LSR_B              242F
_LSR_L              243D
_LSR_W              2436
_MOVEA_L            235D
_MOVEA_W            2366
_MOVEM_L            233C
_MOVEM_W            2333
_MOVEQ              23A5
_MOVE_B             2345
_MOVE_L             234D
_MOVE_W             2355
_MULS               23C6
_NOP                2329
_NOT_B              2314
_NOT_L              2322
_NOT_W              231B
_ONE                245F
_OR                 23B2
_RTS                232E
_SEVEN              246B
_SIX                2469
_SUB                23C1
_THREE              2463
_TWO                2461
_W                  23B9
_ZERO               245D
