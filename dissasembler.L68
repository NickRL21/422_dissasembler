00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/4/2019 10:41:03 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Dissasembler
00000000                             3  * Written by :  Nick, Shelby, and Zoe
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7          ORG     $1000
00001000                             8          
00001000                             9  ****    MAIN LOOP   ****
00001000  4E71                      10  INIT:   NOP     * line for testing
00001002  4EB9 000022DE             11          JSR     RESET_BUF_PTR
00001008  43F9 00002559             12          LEA     WELCOME,A1      * print welcome message
0000100E  4EB9 00002268             13          JSR     WRITE_ASCII
00001014  4EB9 000022B6             14          JSR     TERM_PNT_RST_BUF
0000101A                            15          
0000101A                            16  START:  
0000101A  4EB9 00002072             17          JSR     GET_CHOICE      * get choice from user to dissasemble or quit
00001020  0C46 0002                 18          CMPI    #QUIT_PROG,D6
00001024  6700 0080                 19          BEQ     QUIT
00001028                            20          
00001028                            21  
00001028                            22  INPUT_START:
00001028  43F9 00002676             23          LEA     ST_A_MSG,A1     * load start address prompt message
0000102E  4EB9 00002268             24          JSR     WRITE_ASCII     * write to string buffer
00001034  4EB9 000022B6             25          JSR     TERM_PNT_RST_BUF * terminate string buffer and print reseting pointer at A4
0000103A                            26          
0000103A  43F9 000022E4             27          LEA     ST_ADDR,A1 * load start address
00001040  4291                      28          CLR.L   (A1)    * clear long at a1
00001042  103C 0002                 29          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001046  4E4F                      30          TRAP    #15
00001048  13C1 00002304             31          MOVE.B  D1,ST_LEN    * save start length to memory 
0000104E                            32          
0000104E  4EB9 0000214E             33          JSR     IN_ADDR_TO_HEX  * convert start address to hex
00001054                            34               
00001054  43F9 000026F6             35          LEA     E_A_MSG,A1      * load end address prompt message
0000105A  4EB9 00002268             36          JSR     WRITE_ASCII     * print message
00001060  4EB9 000022B6             37          JSR     TERM_PNT_RST_BUF  * print and reset buffer no newline
00001066                            38          
00001066  43F9 000022F0             39          LEA     E_ADDR,A1  * load end address
0000106C  4291                      40          CLR.L   (A1)    * clear long at end address
0000106E  103C 0002                 41          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001072  4E4F                      42          TRAP    #15
00001074  13C1 00002305             43          MOVE.B  D1,E_LEN    * save end length to memory
0000107A                            44          
0000107A  4EB9 0000214E             45          JSR     IN_ADDR_TO_HEX  * convert end address to hex
00001080                            46          
00001080  4EB9 0000215E             47          JSR     CHK_ST_E_ADRS   * check addresses for errors
00001086  0C05 0001                 48          CMPI.B  #1,D5           * if an error occured return to start
0000108A  6600 000A                 49          BNE     ST_DIS          * branch to dissasembly if no errors
0000108E  4EB9 000020C6             50          JSR     WAIT_USR_INPUT    
00001094  6092                      51          BRA     INPUT_START     * return to start
00001096                            52          
00001096                            53          * print converted addresses for testing purposes
00001096                            54          
00001096  4EB9 000010AC             55  ST_DIS  JSR     OP_CODES
0000109C                            56          
0000109C  4EB9 000022A0             57          JSR     NL_TERM_PNT_RST_BUF * print newline after op codes
000010A2                            58           
000010A2  6000 FF76                 59          BRA     START 
000010A6                            60  
000010A6                            61  
000010A6  103C 0009                 62  QUIT    MOVE.B  #9,D0
000010AA  4E4F                      63          TRAP    #15 * stop sim
000010AC                            64  
000010AC                            65  
000010AC                            66  ****    OP-CODES    ****
000010AC                            67  OP_CODES:
000010AC  4EB9 000022DE             68          JSR     RESET_BUF_PTR   * reset string buffer pointer
000010B2  2A79 000022E4             69          MOVE.L  ST_ADDR,A5  * load starting address into a5
000010B8  2C79 000022F0             70          MOVE.L  E_ADDR,A6   * load ending address into a6
000010BE                            71          
000010BE                            72  OP_START:          
000010BE                            73          * write address and a tab to str buffer
000010BE  220D                      74          MOVE.L  A5,D1   * load address from A5 into D1
000010C0  23C1 00002300             75          MOVE.L  D1,CURRENT_ADDR * save backup of opcode word address
000010C6  7A20                      76          MOVEQ   #32,D5   * set hex length to long for address printing
000010C8  4EB9 00002216             77          JSR     WRITE_HEX_TO_ASCII
000010CE  4EB9 00002292             78          JSR     WRITE_TAB_A4
000010D4                            79          
000010D4  3415                      80          MOVE.W (A5),D2 * load word of memory into D1
000010D6                            81  
000010D6                            82          * clear ea mode and register values
000010D6  13FC 0000 000023FC        83          MOVE.B #0,SRC_REG
000010DE  13FC 0000 000023FA        84          MOVE.B #0,DEST_REG
000010E6  13FC 0000 000023FB        85          MOVE.B #0,SRC_MODE
000010EE  13FC 0000 000023F9        86          MOVE.B #0,DEST_MODE
000010F6  23FC 00000000 000022FC    87          MOVE.L  #0,END_OP_CODE_PTR * clear end of op-code str buffer pointer
00001100  13FC 0000 000023FD        88          MOVE.B  #0,EA_ERR_FLAG * clear ea error flag
00001108                            89          
00001108                            90  CHK_LFT_NIB:
00001108  2602                      91          MOVE.L  D2,D3   * copy to d2
0000110A                            92          
0000110A  0243 F000                 93          ANDI.W  #Nib3Mask,D3 * clear all but left four bits
0000110E  0C43 1000                 94          CMPI.W  #$1000,D3   * if nibble3 == 1, branch to move byte (1)
00001112  6700 0082                 95          BEQ     load_MOVE_B
00001116  0C43 2000                 96          CMPI.W  #$2000,D3   * if nibble3 == 2, branch to that set (move.l, movea.l)
0000111A  6700 00AA                 97          BEQ     OP_2
0000111E  0C43 3000                 98          CMPI.W  #$3000,D3   * if nibble3 == 3, branch to that set (move.w, movea.w)
00001122  6700 0112                 99          BEQ     OP_3              
00001126  0C43 4000                100          CMPI.W  #$4000,D3   * if nibble3 == 4 branch to that set (not/nop/rts/jsr/movem/lea)
0000112A  6700 017A                101          BEQ     OP_4 
0000112E  0C43 5000                102          CMPI.W  #$5000,D3   * if nibble3 == 5, branch to ADDQ (5)
00001132  6700 0320                103          BEQ     ADDQ_
00001136  0C43 6000                104          CMPI.W  #$6000,D3   * if nibble3 == 6, branch to that set (bra, bcc)
0000113A  6700 03A2                105          BEQ     OP_6
0000113E  0C43 7000                106          CMPI.W  #$7000,D3   * if nibble3 == 7, branch to MOVEQ
00001142  6700 042A                107          BEQ     load_MOVEQ
00001146  0C43 8000                108          CMPI.W  #$8000,D3   * if nibble3 == 8, branch to that set (divu, or)
0000114A  6700 0438                109          BEQ     OP_8
0000114E  0C43 9000                110          CMPI.W  #$9000,D3   * if nibble3 == 9, branch to SUB
00001152  6700 048A                111          BEQ     load_SUB
00001156  0C43 C000                112          CMPI.W  #$C000,D3   * if nibble3 == C, branch to that set (muls, and)
0000115A  6700 04A4                113          BEQ     OP_C
0000115E  0C43 D000                114          CMPI.W  #$D000,D3   * if nibble3 == D, branch to that set (add, adda)
00001162  6700 04F6                115          BEQ     OP_D
00001166  0C43 E000                116          CMPI.W  #$E000,D3   * if nibble3 == E, branch to that set (asl, asr, lsl, lsr)
0000116A  6700 054C                117          BEQ     OP_E
0000116E                           118                         
0000116E  4EB9 000020E0            119  OP_ERR  JSR     LOAD_DATA_STR_INTO_BUF   
00001174                           120  
00001174                           121  DECODE_DONE:    * print newline then check if op-code loop is done
00001174  4EB9 000022A0            122          JSR     NL_TERM_PNT_RST_BUF * write newline then print
0000117A  0C39 00FF 000023FD       123          CMP.B   #-1,EA_ERR_FLAG
00001182  6600 0008                124          BNE     NO_EA_ERROR
00001186  2A79 00002300            125          MOVEA.L CURRENT_ADDR,A5 * reset curent address if ea error occurred
0000118C                           126   NO_EA_ERROR:
0000118C  548D                     127          ADD.L   #2,A5   * increment current address pointer by 2 bytes 
0000118E  BBCE                     128          CMP.L   A6,A5  * loop if start is less than or equal to end
00001190  6F00 FF2C                129          BLE     OP_START
00001194  4E75                     130  OP_DONE RTS
00001196                           131  
00001196                           132  load_MOVE_B:    * load and print MOVE.B neumonic return to op loop
00001196  43F9 0000242F            133          LEA     _MOVE_B,A1
0000119C  4EB9 00002268            134          JSR     WRITE_ASCII
000011A2  4EB9 00002298            135          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011A8  13FC 0001 000023F8       136          MOVE.B  #BYTE,INST_SZ   * save instruction size
000011B0  4243                     137          CLR     D3
000011B2  4EB9 00001980            138          JSR     MOVE_EA
000011B8                           139          **** EA CODE GOES HERE ****
000011B8                           140          * must set unused mode/reg vars to 0
000011B8  4EB9 00001EF8            141          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000011BE  4EB9 00001FBC            142          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000011C4  60AE                     143          BRA     DECODE_DONE
000011C6                           144         
000011C6                           145  OP_2:   * could be MOVE.L or MOVEA.L
000011C6  2602                     146          MOVE.L  D2,D3   * copy instruction word
000011C8  0243 01C0                147          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000011CC  0C43 0040                148          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.L
000011D0  6700 000A                149          BEQ     load_MOVEA_L
000011D4  0C43 0040                150          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.L
000011D8  6600 002C                151          BNE     load_MOVE_L
000011DC                           152          
000011DC                           153  load_MOVEA_L:   * load and print MOVEA.L neumonic return to op loop
000011DC  43F9 00002447            154          LEA     _MOVEA_L,A1
000011E2  4EB9 00002268            155          JSR     WRITE_ASCII
000011E8  4EB9 00002298            156          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011EE  13FC 0002 000023F8       157          MOVE.B  #LONG,INST_SZ   * save instruction size
000011F6                           158           **** EA CODE GOES HERE ****
000011F6  4EB9 00001980            159          JSR     MOVE_EA
000011FC                           160          * must set unused mode/reg vars to 0
000011FC  4EB9 00001EF8            161          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001202  6000 FF70                162          BRA     DECODE_DONE
00001206                           163  
00001206                           164  load_MOVE_L:    * load and print MOVE.L neumonic return to op loop
00001206  43F9 00002437            165          LEA     _MOVE_L,A1
0000120C  4EB9 00002268            166          JSR     WRITE_ASCII
00001212  4EB9 00002298            167          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001218  13FC 0002 000023F8       168          MOVE.B  #LONG,INST_SZ   * save instruction size
00001220  4EB9 00001980            169          JSR     MOVE_EA
00001226  4EB9 00001EF8            170          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000122C  4EB9 00001FBC            171          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001232  6000 FF40                172          BRA     DECODE_DONE
00001236                           173          
00001236                           174  OP_3:   * could be MOVE.W or MOVEA.W
00001236  2602                     175          MOVE.L  D2,D3   * copy instruction word
00001238  0243 01C0                176          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
0000123C  0C43 0040                177          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.W
00001240  6700 000A                178          BEQ     load_MOVEA_W
00001244  0C43 0040                179          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.W
00001248  6600 002C                180          BNE     load_MOVE_W
0000124C                           181          
0000124C                           182  load_MOVEA_W:   * load and print MOVEA.W neumonic return to op loop
0000124C  43F9 00002450            183          LEA     _MOVEA_W,A1
00001252  4EB9 00002268            184          JSR     WRITE_ASCII
00001258  4EB9 00002298            185          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000125E  13FC 0003 000023F8       186          MOVE.B  #WORD,INST_SZ   * save instruction size
00001266                           187           **** EA CODE GOES HERE ****
00001266  4EB9 00001980            188          JSR     MOVE_EA
0000126C                           189          * must set unused mode/reg vars to 0
0000126C  4EB9 00001EF8            190          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001272  6000 FF00                191          BRA     DECODE_DONE
00001276                           192  
00001276                           193  load_MOVE_W:    * load and print MOVE.W neumonic return to op loop
00001276  43F9 0000243F            194          LEA     _MOVE_W,A1
0000127C  4EB9 00002268            195          JSR     WRITE_ASCII
00001282  4EB9 00002298            196          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001288  13FC 0003 000023F8       197          MOVE.B  #WORD,INST_SZ   * save instruction size
00001290  4EB9 00001980            198          JSR     MOVE_EA
00001296  4EB9 00001EF8            199          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000129C  4EB9 00001FBC            200          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000012A2  6000 FED0                201          BRA     DECODE_DONE
000012A6                           202  
000012A6                           203  OP_4:   * could be not, nop, rts, jsr, MOVEM.L, lea
000012A6  2602                     204          MOVE.L  D2,D3   * copy instruction word
000012A8  0243 0F00                205          ANDI.W  #Nib2Mask,D3
000012AC  0C43 0600                206          CMPI.W  #$0600,D3   * if nibble 2 is 6, instruction is NOT
000012B0  6700 0032                207          BEQ     NOT_
000012B4                           208  
000012B4  0C43 0E00                209          CMPI.W  #$0E00,D3  * if nibble 2 is E could be nop or rts or jsr
000012B8  6700 00C6                210          BEQ     NOP_RTS_JSR
000012BC                           211          
000012BC                           212          * try for LEA
000012BC  2602                     213          MOVE.L  D2,D3
000012BE  0243 01C0                214          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012C2  0C43 01C0                215          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LEA
000012C6  6700 010C                216          BEQ     load_LEA
000012CA                           217          
000012CA                           218          * try for MOVEM.W or MOVEM.L
000012CA  2602                     219          MOVE.L  D2,D3
000012CC  0243 01C0                220          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 for size
000012D0  0C43 0080                221          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is MOVEM.W
000012D4  6700 0136                222          BEQ     load_MOVEM_W
000012D8  0C43 00C0                223          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is MOVEM.L
000012DC  6700 0152                224          BEQ     load_MOVEM_L
000012E0                           225  
000012E0                           226          
000012E0  6000 FE8C                227          BRA     OP_ERR  * return to error decoding
000012E4                           228          
000012E4                           229  NOT_:   * instruction is not, determine size
000012E4  2602                     230          MOVE.L  D2,D3
000012E6  0243 01C0                231          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012EA  0C43 0000                232          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is NOT.B
000012EE  6700 0012                233          BEQ     load_NOT_B
000012F2  0C43 0040                234          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is NOT.W
000012F6  6700 0034                235          BEQ     load_NOT_W
000012FA  0C43 0080                236          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is NOT.L
000012FE  6700 0056                237          BEQ     load_NOT_L
00001302                           238           
00001302                           239         
00001302                           240  load_NOT_B:   * load and print NOT.B neumonic return to op loop
00001302  43F9 000023FE            241          LEA     _NOT_B,A1
00001308  4EB9 00002268            242          JSR     WRITE_ASCII
0000130E  4EB9 00002298            243          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001314  13FC 0001 000023F8       244          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000131C                           245           **** EA CODE GOES HERE ****
0000131C                           246          * must set unused mode/reg vars to 0
0000131C  4EB9 00001EF8            247          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001322  4EB9 00001FBC            248          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001328  6000 FE4A                249          BRA     DECODE_DONE
0000132C                           250          
0000132C                           251  load_NOT_W:   * load and print NOT.W neumonic return to op loop
0000132C  43F9 00002405            252          LEA     _NOT_W,A1
00001332  4EB9 00002268            253          JSR     WRITE_ASCII
00001338  4EB9 00002298            254          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000133E  13FC 0003 000023F8       255          MOVE.B  #WORD,INST_SZ   * save instruction size
00001346                           256           **** EA CODE GOES HERE ****
00001346                           257          * must set unused mode/reg vars to 0
00001346  4EB9 00001EF8            258          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000134C  4EB9 00001FBC            259          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001352  6000 FE20                260          BRA     DECODE_DONE
00001356                           261          
00001356                           262  load_NOT_L:   * load and print NOT.L neumonic return to op loop
00001356  43F9 0000240C            263          LEA     _NOT_L,A1
0000135C  4EB9 00002268            264          JSR     WRITE_ASCII
00001362  4EB9 00002298            265          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001368  13FC 0002 000023F8       266          MOVE.B  #LONG,INST_SZ   * save instruction size
00001370                           267           **** EA CODE GOES HERE ****
00001370                           268          * must set unused mode/reg vars to 0
00001370  4EB9 00001EF8            269          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001376  4EB9 00001FBC            270          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
0000137C  6000 FDF6                271          BRA     DECODE_DONE
00001380                           272  
00001380                           273  NOP_RTS_JSR: * could be NOP or RTS or JSR
00001380  2602                     274          MOVE.L  D2,D3
00001382  0243 01C0                275          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001386  0C43 0080                276          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is JSR
0000138A  6700 006A                277          BEQ     load_JSR
0000138E                           278      
0000138E  2602                     279          MOVE.L  D2,D3       *copy instruction word
00001390  0243 00FF                280          ANDI.W  #Byte0Mask,D3 * isolate right most byte
00001394                           281          
00001394  0C03 0071                282          CMPI.B  #$71,D3     * test for NOP
00001398  6700 000E                283          BEQ     load_NOP
0000139C  0C03 0075                284          CMPI.B  #$75, D3    * test for RTS
000013A0  6700 001C                285          BEQ     load_RTS
000013A4                           286              
000013A4  6000 FDC8                287          BRA     OP_ERR  * return to error decoding
000013A8                           288  
000013A8                           289  load_NOP:   * load and print NOP neumonic return to op loop
000013A8  43F9 00002413            290          LEA     _NOP,A1
000013AE  4EB9 00002268            291          JSR     WRITE_ASCII
000013B4  4EB9 00002298            292          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013BA  6000 FDB8                293          BRA     DECODE_DONE
000013BE                           294          
000013BE                           295  load_RTS:   * load and print RTS neumonic return to op loop
000013BE  43F9 00002418            296          LEA     _RTS,A1
000013C4  4EB9 00002268            297          JSR     WRITE_ASCII
000013CA  4EB9 00002298            298          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013D0  6000 FDA2                299          BRA     DECODE_DONE
000013D4                           300          
000013D4                           301  load_LEA:   * load and print LEA neumonic return to op loop
000013D4  43F9 0000245E            302          LEA     _LEA,A1
000013DA  4EB9 00002268            303          JSR     WRITE_ASCII
000013E0  4EB9 00002298            304          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013E6                           305           **** EA CODE GOES HERE ****
000013E6  4EB9 000019F0            306           JSR    LEA_EA
000013EC                           307          * must set unused mode/reg vars to 0
000013EC  4EB9 00001EF8            308          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000013F2  6000 FD80                309          BRA     DECODE_DONE
000013F6                           310          
000013F6                           311  load_JSR:   * load and print JSR neumonic return to op loop
000013F6  43F9 00002459            312          LEA     _JSR,A1
000013FC  4EB9 00002268            313          JSR     WRITE_ASCII
00001402  4EB9 00002298            314          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001408  6000 FD6A                315          BRA     DECODE_DONE
0000140C                           316          
0000140C                           317  load_MOVEM_W:   * load and print MOVEM.W neumonic return to op loop
0000140C  43F9 0000241D            318          LEA     _MOVEM_W,A1
00001412  4EB9 00002268            319          JSR     WRITE_ASCII
00001418  4EB9 00002298            320          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000141E  13FC 0003 000023F8       321      MOVE.B  #WORD,INST_SZ   * save instruction size
00001426                           322           **** EA CODE GOES HERE ****
00001426                           323          * must set unused mode/reg vars to 0
00001426  4EB9 00001EF8            324          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000142C  6000 FD46                325          BRA     DECODE_DONE
00001430                           326          
00001430                           327  load_MOVEM_L:   * load and print MOVEM.L neumonic return to op loop
00001430  43F9 00002426            328          LEA     _MOVEM_L,A1
00001436  4EB9 00002268            329          JSR     WRITE_ASCII
0000143C  4EB9 00002298            330          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001442  13FC 0002 000023F8       331          MOVE.B  #LONG,INST_SZ   * save instruction size
0000144A                           332           **** EA CODE GOES HERE ****
0000144A                           333          * must set unused mode/reg vars to 0
0000144A  4EB9 00001EF8            334          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001450  6000 FD22                335          BRA     DECODE_DONE
00001454                           336  
00001454                           337  ADDQ_:  * instruction is addq, determine size
00001454  2602                     338          MOVE.L  D2,D3
00001456  0243 01C0                339          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
0000145A  0C43 0000                340          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ADDQ.B
0000145E  6700 0012                341          BEQ     load_ADDQ_B
00001462  0C43 0040                342          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ADDQ.W
00001466  6700 002E                343          BEQ     load_ADDQ_W
0000146A  0C43 0080                344          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ADDQ.L
0000146E  6700 004A                345          BEQ     load_ADDQ_L           
00001472                           346  
00001472                           347  load_ADDQ_B:  * load and print ADDQ.B neumonic return to op loop
00001472  43F9 00002463            348          LEA     _ADDQ_B,A1
00001478  4EB9 00002268            349          JSR     WRITE_ASCII
0000147E  4EB9 00002298            350          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001484  13FC 0001 000023F8       351          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000148C                           352           **** EA CODE GOES HERE ****
0000148C                           353          * must set unused mode/reg vars to 0
0000148C  4EB9 00001EF8            354          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001492  6000 FCE0                355          BRA     DECODE_DONE
00001496                           356        
00001496                           357  load_ADDQ_W:  * load and print ADDQ.W neumonic return to op loop
00001496  43F9 0000246B            358          LEA     _ADDQ_W,A1
0000149C  4EB9 00002268            359          JSR     WRITE_ASCII
000014A2  4EB9 00002298            360          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014A8  13FC 0003 000023F8       361          MOVE.B  #WORD,INST_SZ   * save instruction size
000014B0                           362           **** EA CODE GOES HERE ****
000014B0                           363          * must set unused mode/reg vars to 0
000014B0  4EB9 00001EF8            364          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014B6  6000 FCBC                365          BRA     DECODE_DONE
000014BA                           366          
000014BA                           367  load_ADDQ_L:  * load and print ADDQ.L neumonic return to op loop
000014BA  43F9 00002473            368          LEA     _ADDQ_L,A1
000014C0  4EB9 00002268            369          JSR     WRITE_ASCII
000014C6  4EB9 00002298            370          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014CC  13FC 0002 000023F8       371          MOVE.B  #LONG,INST_SZ
000014D4                           372           **** EA CODE GOES HERE ****
000014D4                           373          * must set unused mode/reg vars to 0
000014D4  4EB9 00001EF8            374          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014DA  6000 FC98                375          BRA     DECODE_DONE
000014DE                           376          
000014DE                           377  OP_6:   * could be BRA, BEQ, BGT, BLE
000014DE  2602                     378          MOVE.L  D2,D3   * copy instruction word
000014E0  0243 0F00                379          ANDI.W  #Nib2Mask,D3
000014E4  0C43 0000                380          CMPI.W  #$0000,D3   * if nibble 2 is 0, instruction is BRA
000014E8  6700 001A                381          BEQ     load_BRA
000014EC  0C43 0700                382          CMPI.W  #$0700,D3   * if nibble 2 is 7, instruction is BEQ
000014F0  6700 0028                383          BEQ     load_BEQ
000014F4  0C43 0E00                384          CMPI.W  #$0E00,D3   * if nibble 2 is E, instruction is BGT
000014F8  6700 003C                385          BEQ     load_BGT
000014FC  0C43 0F00                386          CMPI.W  #$0F00,D3   * if nibble 2 is F, instruction is BLE
00001500  6700 0050                387          BEQ     load_BLE
00001504                           388          
00001504                           389  load_BRA:   * load and print BRA neumonic return to op loop
00001504  43F9 0000247B            390          LEA     _BRA,A1
0000150A  4EB9 00002268            391          JSR     WRITE_ASCII
00001510  4EB9 00002298            392          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001516  6000 FC5C                393          BRA     DECODE_DONE
0000151A                           394          
0000151A                           395  load_BEQ:   * load and print BEQ neumonic return to op loop
0000151A  43F9 00002480            396          LEA     _BEQ,A1
00001520  4EB9 00002268            397          JSR     WRITE_ASCII
00001526  4EB9 00002298            398          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000152C  4EB9 00001A56            399          JSR     BCC_DISP
00001532  6000 FC40                400          BRA     DECODE_DONE
00001536                           401  
00001536                           402  load_BGT:   * load and print BGT neumonic return to op loop
00001536  43F9 00002485            403          LEA     _BGT,A1
0000153C  4EB9 00002268            404          JSR     WRITE_ASCII
00001542  4EB9 00002298            405          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001548  4EB9 00001A56            406          JSR     BCC_DISP
0000154E  6000 FC24                407          BRA     DECODE_DONE
00001552                           408          
00001552                           409  load_BLE:   * load and print BLE neumonic return to op loop
00001552  43F9 0000248A            410          LEA     _BLE,A1
00001558  4EB9 00002268            411          JSR     WRITE_ASCII
0000155E  4EB9 00002298            412          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001564  4EB9 00001A56            413          JSR     BCC_DISP
0000156A  6000 FC08                414          BRA     DECODE_DONE
0000156E                           415          
0000156E                           416  load_MOVEQ: * load and print MOVEQ neumonic return to op loop
0000156E  43F9 0000248F            417          LEA     _MOVEQ,A1
00001574  4EB9 00002268            418          JSR     WRITE_ASCII
0000157A  4EB9 00002298            419          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001580  6000 FBF2                420          BRA     DECODE_DONE
00001584                           421          
00001584                           422  OP_8:       * could be DIVU or OR
00001584  2602                     423          MOVE.L  D2,D3       * copy instruction word
00001586  0243 01C0                424          ANDI.W  #Bit1Mask,D3   * mask, isolate distinguishing bits 8-6
0000158A  0C43 00C0                425          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is DIVU
0000158E  6700 000A                426          BEQ     load_DIVU
00001592  0C43 00C0                427          CMPI.W  #$00C0,D3       * if bits 8-6 are NOT 011, instruction is OR
00001596  6600 0024                428          BNE     load_OR
0000159A                           429  
0000159A                           430  load_DIVU:  * load and print DIVU neumonic return to op loop
0000159A  43F9 00002496            431          LEA     _DIVU,A1
000015A0  4EB9 00002268            432          JSR     WRITE_ASCII
000015A6  4EB9 00002298            433          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015AC                           434           **** EA CODE GOES HERE ****
000015AC  4EB9 00001A98            435          JSR     DM_EA
000015B2                           436          * must set unused mode/reg vars to 0
000015B2  4EB9 00001EF8            437          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015B8  6000 FBBA                438          BRA     DECODE_DONE
000015BC                           439          
000015BC                           440  load_OR:    * load and print DIVU neuomnic return to op loop
000015BC  43F9 0000249C            441          LEA     _OR,A1
000015C2  4EB9 00002268            442          JSR     WRITE_ASCII
000015C8  4EB9 00002298            443          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015CE                           444           **** EA CODE GOES HERE ****
000015CE  4EB9 00001B02            445          JSR     OPMODE_EA
000015D4                           446          * must set unused mode/reg vars to 0
000015D4  4EB9 00001EF8            447          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015DA  6000 FB98                448          BRA     DECODE_DONE
000015DE                           449  
000015DE                           450  load_SUB:   * load and print SUB neumonic return to op loop
000015DE  43F9 000024AB            451          LEA     _SUB,A1
000015E4  4EB9 00002268            452          JSR     WRITE_ASCII
000015EA  4EB9 00002298            453          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015F0                           454           **** EA CODE GOES HERE ****
000015F0  4EB9 00001B02            455          JSR     OPMODE_EA
000015F6                           456  
000015F6                           457          * must set unused mode/reg vars to 0
000015F6  4EB9 00001EF8            458          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015FC  6000 FB76                459          BRA     DECODE_DONE
00001600                           460  
00001600                           461  OP_C:       * could be MULS or AND
00001600  2602                     462          MOVE.L  D2,D3       * copy instruction word
00001602  0243 01C0                463          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
00001606  0C43 01C0                464          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is MULS
0000160A  6700 000A                465          BEQ     load_MULS
0000160E  0C43 01C0                466          CMPI.W  #$01C0,D3       * if bits 8-6 are NOT 111, instruction is AND
00001612  6600 0024                467          BNE     load_AND
00001616                           468          
00001616                           469  load_MULS:  * load and print MULS neumonic return to op loop
00001616  43F9 000024B0            470          LEA     _MULS,A1
0000161C  4EB9 00002268            471          JSR     WRITE_ASCII
00001622  4EB9 00002298            472          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001628                           473           **** EA CODE GOES HERE ****
00001628  4EB9 00001A98            474          JSR     DM_EA
0000162E                           475          * must set unused mode/reg vars to 0
0000162E  4EB9 00001EF8            476          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001634  6000 FB3E                477          BRA     DECODE_DONE
00001638                           478          
00001638                           479  load_AND:   * load and print AND neumonic return to op loop
00001638  43F9 000024B6            480          LEA     _AND,A1
0000163E  4EB9 00002268            481          JSR     WRITE_ASCII
00001644  4EB9 00002298            482          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000164A                           483           **** EA CODE GOES HERE ****
0000164A  4EB9 00001B02            484          JSR     OPMODE_EA
00001650                           485          * must set unused mode/reg vars to 0
00001650  4EB9 00001EF8            486          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001656  6000 FB1C                487          BRA     DECODE_DONE
0000165A                           488  
0000165A                           489  OP_D:       * could be ADD or ADDA
0000165A  2602                     490          MOVE.L  D2,D3       * copy instruction word
0000165C  0243 01C0                491          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 (opmode but distinguishes instr.)
00001660  0C43 00C0                492          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ADDA
00001664  6700 000E                493          BEQ     load_ADDA
00001668  0C43 01C0                494          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is also ADDA
0000166C  6700 0006                495          BEQ     load_ADDA
00001670  6600 0024                496          BNE     load_ADD        * if bits 8-6 are not either, instruction is ADD
00001674                           497          
00001674                           498  load_ADDA:  * load and print ADDA neumonic return to op loop
00001674  43F9 000024C0            499          LEA     _ADDA,A1
0000167A  4EB9 00002268            500          JSR     WRITE_ASCII
00001680  4EB9 00002298            501          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001686                           502           **** EA CODE GOES HERE ****
00001686  4EB9 00001B02            503          JSR     OPMODE_EA
0000168C                           504          * must set unused mode/reg vars to 0
0000168C  4EB9 00001EF8            505          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001692  6000 FAE0                506          BRA     DECODE_DONE
00001696                           507  
00001696                           508  load_ADD:   * load and print ADD neumonic return to op loop
00001696  43F9 000024BB            509          LEA     _ADD,A1
0000169C  4EB9 00002268            510          JSR     WRITE_ASCII
000016A2  4EB9 00002298            511          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000016A8                           512           **** EA CODE GOES HERE ****
000016A8  4EB9 00001B02            513          JSR     OPMODE_EA
000016AE                           514          * must set unused mode/reg vars to 0
000016AE  4EB9 00001EF8            515          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000016B4  6000 FABE                516          BRA     DECODE_DONE
000016B8                           517  
000016B8                           518  OP_E:       * could be ASL, ASR, LSL, LSR (memory or register)
000016B8  2602                     519          MOVE.L  D2,D3       * copy instruction word
000016BA  0283 FFFF00FF            520          ANDI.L  #$FFFF00FF,D3   * mask, isolate bits 7-6
000016C0  0C43 00C0                521          CMPI.W  #$00C0,D3       * if bits 7-6 are 11, instruction is MEMORY shift
000016C4  6700 000A                522          BEQ     MEMORY_shift
000016C8  0C43 00C0                523          CMPI.W  #$00C0,D3       * if bits 7-6 are NOT 11, instruction is REG shift
000016CC  6600 00B4                524          BNE     REG_shift
000016D0                           525          
000016D0                           526  MEMORY_shift:   * could be ASL, ASR, LSL, LSR (memory)
000016D0  2602                     527          MOVE.L  D2,D3       * copy instruction word
000016D2  0243 0E00                528          ANDI.W  #Bit0Mask,D3    * mask, isolate bits 11-9
000016D6  0C43 0000                529          CMPI.W  #$0000,D3       * if bits 11-9 are 000, instruction is ASL or ASR (memory)
000016DA  6700 000A                530          BEQ     ASL_ASR_MEM
000016DE  0C43 0200                531          CMPI.W  #$0200,D3       * if bits 11-9 are 001, instruction is LSL or LSR (memory)
000016E2  6700 0050                532          BEQ     LSL_LSR_MEM
000016E6                           533          
000016E6                           534  ASL_ASR_MEM:    * could be ASL or ASR (memory)
000016E6  2602                     535          MOVE.L  D2,D3       * copy instruction word
000016E8  0243 01C0                536          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000016EC  0C43 00C0                537          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ASR memory
000016F0  6700 000A                538          BEQ     load_ASR_MEM
000016F4  0C43 01C0                539          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is ASL memory
000016F8  6700 001E                540          BEQ     load_ASL_MEM
000016FC                           541          
000016FC                           542  load_ASR_MEM:   * load and print ASR neumonic return to op loop
000016FC  43F9 000024CB            543          LEA     _ASR,A1
00001702  4EB9 00002268            544          JSR     WRITE_ASCII
00001708  4EB9 00002298            545          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000170E                           546           **** EA CODE GOES HERE ****
0000170E                           547          * must set unused mode/reg vars to 0
0000170E  4EB9 00001EF8            548          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001714  6000 FA5E                549          BRA     DECODE_DONE
00001718                           550          
00001718                           551  load_ASL_MEM:   * load and print ASL neumonic return to op loop
00001718  43F9 000024C6            552          LEA     _ASL,A1
0000171E  4EB9 00002268            553          JSR     WRITE_ASCII
00001724  4EB9 00002298            554          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000172A                           555           **** EA CODE GOES HERE ****
0000172A                           556          * must set unused mode/reg vars to 0
0000172A  4EB9 00001EF8            557          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001730  6000 FA42                558          BRA     DECODE_DONE
00001734                           559  
00001734                           560  LSL_LSR_MEM:    * could be LSL or LSR (memory)
00001734  2602                     561          MOVE.L  D2,D3       * copy instruction word
00001736  0243 01C0                562          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
0000173A  0C43 00C0                563          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is LSR memory
0000173E  6700 000A                564          BEQ     load_LSR_MEM
00001742  0C43 01C0                565          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LSL memory
00001746  6700 001E                566          BEQ     load_LSL_MEM 
0000174A                           567          
0000174A                           568  load_LSR_MEM:   * load and print LSR neumonic return to op loop
0000174A  43F9 000024D5            569          LEA     _LSR,A1
00001750  4EB9 00002268            570          JSR     WRITE_ASCII
00001756  4EB9 00002298            571          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000175C                           572           **** EA CODE GOES HERE ****
0000175C                           573          * must set unused mode/reg vars to 0
0000175C  4EB9 00001EF8            574          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001762  6000 FA10                575          BRA     DECODE_DONE
00001766                           576          
00001766                           577  load_LSL_MEM:   * load and print LSL neumonic return to op loop
00001766  43F9 000024D0            578          LEA     _LSL,A1
0000176C  4EB9 00002268            579          JSR     WRITE_ASCII
00001772  4EB9 00002298            580          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001778                           581           **** EA CODE GOES HERE ****
00001778                           582          * must set unused mode/reg vars to 0
00001778  4EB9 00001EF8            583          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000177E  6000 F9F4                584          BRA     DECODE_DONE
00001782                           585  
00001782                           586  REG_shift:      * could be ASL, ASR, LSL, LSR (register)
00001782  2602                     587          MOVE.L  D2,D3       * copy instruction word
00001784  0243 0038                588          ANDI.W  #Bit2Mask,D3    * mask, isolate bits 5-3
00001788  0C43 0000                589          CMPI.W  #$0000,D3        * if bits 5-3 are 000, instruction is ASL or ASR (reg)
0000178C  6700 001A                590          BEQ     ASL_ASR_REG
00001790  0C43 0020                591          CMPI.W  #$0020,D3       * if bits 5-3 are 100, instruction is ASL or ASR (reg)
00001794  6700 0012                592          BEQ     ASL_ASR_REG
00001798  0C43 0008                593          CMPI.W  #$0008,D3       * if bits 5-3 are 001, instruction is LSL or LSR (reg)
0000179C  6700 00F6                594          BEQ     LSL_LSR_REG
000017A0  0C43 0028                595          CMPI.W  #$0028,D3       * if bits 5-3 are 101, instruction is LSL or LSR (reg)
000017A4  6700 00EE                596          BEQ     LSL_LSR_REG
000017A8                           597          
000017A8                           598  ASL_ASR_REG:    * could be ASL or ASR (register)
000017A8  2602                     599          MOVE.L  D2,D3       * copy instruction word
000017AA  0283 000001C0            600          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
000017B0                           601          
000017B0  0C43 0000                602          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ASR.B register
000017B4  6700 002A                603          BEQ     load_ASR_B_REG
000017B8  0C43 0040                604          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ASR.W register
000017BC  6700 0040                605          BEQ     load_ASR_W_REG
000017C0  0C43 0080                606          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ASR.L register
000017C4  6700 0056                607          BEQ     load_ASR_L_REG
000017C8                           608          
000017C8  0C43 0100                609          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is ASL.B register
000017CC  6700 006C                610          BEQ     load_ASL_B_REG
000017D0  0C43 0140                611          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is ASL.W register
000017D4  6700 0082                612          BEQ     load_ASL_W_REG
000017D8  0C43 0180                613          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is ASL.L register
000017DC  6700 0098                614          BEQ     load_ASL_L_REG
000017E0                           615  
000017E0                           616  load_ASR_B_REG:   * load and print ASR.B neumonic return to op loop
000017E0  43F9 000024EF            617          LEA     _ASR_B,A1
000017E6  4EB9 00002268            618          JSR     WRITE_ASCII
000017EC  4EB9 00002298            619          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000017F2  13FC 0001 000023F8       620          MOVE.B  #BYTE,INST_SZ   * save instruction size
000017FA  6000 F978                621          BRA     DECODE_DONE
000017FE                           622          
000017FE                           623  load_ASR_W_REG:   * load and print ASR.W neumonic return to op loop
000017FE  43F9 000024F6            624          LEA     _ASR_W,A1
00001804  4EB9 00002268            625          JSR     WRITE_ASCII
0000180A  4EB9 00002298            626          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001810  13FC 0003 000023F8       627          MOVE.B  #WORD,INST_SZ   * save instruction size
00001818  6000 F95A                628          BRA     DECODE_DONE
0000181C                           629          
0000181C                           630  load_ASR_L_REG:   * load and print ASR.L neumonic return to op loop
0000181C  43F9 000024FD            631          LEA     _ASR_L,A1
00001822  4EB9 00002268            632          JSR     WRITE_ASCII
00001828  4EB9 00002298            633          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000182E  13FC 0002 000023F8       634          MOVE.B  #LONG,INST_SZ   * save instruction size
00001836  6000 F93C                635          BRA     DECODE_DONE
0000183A                           636          
0000183A                           637  load_ASL_B_REG:   * load and print ASL.B neumonic return to op loop
0000183A  43F9 000024DA            638          LEA     _ASL_B,A1
00001840  4EB9 00002268            639          JSR     WRITE_ASCII
00001846  4EB9 00002298            640          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000184C  13FC 0001 000023F8       641          MOVE.B  #BYTE,INST_SZ   * save instruction size
00001854  6000 F91E                642          BRA     DECODE_DONE
00001858                           643          
00001858                           644  load_ASL_W_REG:   * load and print ASL.W neumonic return to op loop
00001858  43F9 000024E1            645          LEA     _ASL_W,A1
0000185E  4EB9 00002268            646          JSR     WRITE_ASCII
00001864  4EB9 00002298            647          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000186A  13FC 0003 000023F8       648          MOVE.B  #WORD,INST_SZ   * save instruction size
00001872  6000 F900                649          BRA     DECODE_DONE
00001876                           650          
00001876                           651  load_ASL_L_REG:   * load and print ASL.L neumonic return to op loop
00001876  43F9 000024E8            652          LEA     _ASL_L,A1
0000187C  4EB9 00002268            653          JSR     WRITE_ASCII
00001882  4EB9 00002298            654          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001888  13FC 0002 000023F8       655          MOVE.B  #LONG,INST_SZ   * save instruction size
00001890  6000 F8E2                656          BRA     DECODE_DONE
00001894                           657  
00001894                           658  LSL_LSR_REG:    * could be LSL or LSR (register)
00001894  2602                     659          MOVE.L  D2,D3       * copy instruction word
00001896  0283 000001C0            660          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
0000189C                           661          
0000189C  0C43 0000                662          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is LSR.B register
000018A0  6700 002A                663          BEQ     load_LSR_B_REG
000018A4  0C43 0040                664          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is LSR.W register
000018A8  6700 0040                665          BEQ     load_LSR_W_REG
000018AC  0C43 0080                666          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is LSR.L register
000018B0  6700 0056                667          BEQ     load_LSR_L_REG
000018B4                           668          
000018B4  0C43 0100                669          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is LSL.B register
000018B8  6700 006C                670          BEQ     load_LSL_B_REG
000018BC  0C43 0140                671          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is LSL.W register
000018C0  6700 0082                672          BEQ     load_LSL_W_REG
000018C4  0C43 0180                673          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is LSL.L register
000018C8  6700 0098                674          BEQ     load_LSL_L_REG
000018CC                           675  
000018CC                           676  load_LSR_B_REG:   * load and print LSR.B neumonic return to op loop
000018CC  43F9 00002519            677          LEA     _LSR_B,A1
000018D2  4EB9 00002268            678          JSR     WRITE_ASCII
000018D8  4EB9 00002298            679          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018DE  13FC 0001 000023F8       680          MOVE.B  #BYTE,INST_SZ   * save instruction size
000018E6  6000 F88C                681          BRA     DECODE_DONE
000018EA                           682          
000018EA                           683  load_LSR_W_REG:   * load and print LSR.W neumonic return to op loop
000018EA  43F9 00002520            684          LEA     _LSR_W,A1
000018F0  4EB9 00002268            685          JSR     WRITE_ASCII
000018F6  4EB9 00002298            686          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018FC  13FC 0003 000023F8       687          MOVE.B  #WORD,INST_SZ   * save instruction size
00001904  6000 F86E                688          BRA     DECODE_DONE
00001908                           689          
00001908                           690  load_LSR_L_REG:   * load and print LSR.L neumonic return to op loop
00001908  43F9 00002527            691          LEA     _LSR_L,A1
0000190E  4EB9 00002268            692          JSR     WRITE_ASCII
00001914  4EB9 00002298            693          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000191A  13FC 0002 000023F8       694          MOVE.B  #LONG,INST_SZ   * save instruction size
00001922  6000 F850                695          BRA     DECODE_DONE
00001926                           696          
00001926                           697  load_LSL_B_REG:   * load and print LSL.B neumonic return to op loop
00001926  43F9 00002504            698          LEA     _LSL_B,A1
0000192C  4EB9 00002268            699          JSR     WRITE_ASCII
00001932  4EB9 00002298            700          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001938  13FC 0001 000023F8       701          MOVE.B  #BYTE,INST_SZ   * save instruction size
00001940  6000 F832                702          BRA     DECODE_DONE
00001944                           703          
00001944                           704  load_LSL_W_REG:   * load and print LSL.W neumonic return to op loop
00001944  43F9 0000250B            705          LEA     _LSL_W,A1
0000194A  4EB9 00002268            706          JSR     WRITE_ASCII
00001950  4EB9 00002298            707          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001956  13FC 0003 000023F8       708          MOVE.B  #WORD,INST_SZ   * save instruction size
0000195E  6000 F814                709          BRA     DECODE_DONE
00001962                           710          
00001962                           711  load_LSL_L_REG:   * load and print LSL.L neumonic return to op loop
00001962  43F9 00002512            712          LEA     _LSL_L,A1
00001968  4EB9 00002268            713          JSR     WRITE_ASCII
0000196E  4EB9 00002298            714          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001974  13FC 0002 000023F8       715          MOVE.B  #LONG,INST_SZ   * save instruction size
0000197C  6000 F7F6                716          BRA     DECODE_DONE
00001980                           717  
00001980                           718  ****       EA       ****
00001980                           719  
00001980                           720  **** MOVE_EA FIRST EA COMMAND *********
00001980                           721  MOVE_EA:
00001980  2602                     722          MOVE.L  D2,D3           *copy instruction to D3 for register
00001982  2802                     723          MOVE.L  D2,D4           *copy instruction to D4 for mode
00001984  0244 0038                724          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001988  0243 0007                725          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
0000198C  E68C                     726          LSR.L   #3,D4
0000198E  13C4 000023FB            727          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001994  13C3 000023FC            728          MOVE.B  D3,SRC_REG      * save source register to memory
0000199A  C8FC 0006                729          MULU    #6,D4
0000199E  C6FC 0006                730          MULU    #6,D3
000019A2  43F9 00001D3C            731          LEA     EA_MODE,A1
000019A8  4EB1 4000                732          JSR     (A1,D4)
000019AC  43F9 00002557            733          LEA     _COMMA,A1
000019B2  4EB9 00002268            734          JSR     WRITE_ASCII
000019B8                           735  
000019B8  4243                     736          CLR     D3
000019BA  4244                     737          CLR     D4 
000019BC                           738  ******* MOVE_EA SECOND EA COMMAND **********
000019BC  2602                     739          MOVE.L  D2,D3           *copy instruction to D3 for register
000019BE  2802                     740          MOVE.L  D2,D4           *copy instruction to D4 for modE
000019C0  0243 0E00                741          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
000019C4  0244 01C0                742          ANDI.W  #Bit1Mask,D4    *mask to isolate 3-bit mode
000019C8  1A3C 0009                743          MOVE.B  #9, D5
000019CC  EA6B                     744          LSR     D5,D3 
000019CE  EC8C                     745          LSR.L   #6,D4
000019D0  13C4 000023F9            746          MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
000019D6  13C3 000023FA            747          MOVE.B  D3,DEST_REG      * save destination register to memory 
000019DC  C8FC 0006                748          MULU   #6,D4
000019E0  C6FC 0006                749          MULU   #6,D3
000019E4                           750         
000019E4  43F9 00001D3C            751          LEA     EA_MODE,A1 
000019EA  4EB1 4000                752          JSR     (A1,D4)
000019EE  4E75                     753          RTS
000019F0                           754  
000019F0                           755  ********** LEA_EA ***********
000019F0                           756  LEA_EA:
000019F0  2602                     757          MOVE.L  D2,D3 
000019F2  2802                     758          MOVE.L  D2,D4
000019F4  0244 0038                759          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
000019F8  0243 0007                760          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
000019FC  E68C                     761          LSR.L   #3,D4
000019FE  13C4 000023FB            762          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001A04  13C3 000023FC            763          MOVE.B  D3,SRC_REG      * save source register to memory
00001A0A  C8FC 0006                764          MULU    #6,D4
00001A0E  C6FC 0006                765          MULU    #6,D3
00001A12                           766  
00001A12  43F9 00001D3C            767          LEA     EA_MODE,A1
00001A18  4EB1 4000                768          JSR     (A1,D4)
00001A1C  43F9 00002557            769          LEA     _COMMA,A1
00001A22  4EB9 00002268            770          JSR     WRITE_ASCII
00001A28                           771  
00001A28  4243                     772          CLR     D3
00001A2A  4244                     773          CLR     D4 
00001A2C                           774  
00001A2C                           775  
00001A2C  2602                     776          MOVE.L  D2,D3 
00001A2E  0243 0E00                777          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001A32  1A3C 0009                778          MOVE.B  #9, D5
00001A36  EA6B                     779          LSR     D5,D3 
00001A38  13C3 000023FA            780          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001A3E  C6FC 0006                781          MULU   #6,D3
00001A42  383C 0001                782          MOVE.W  #$0001,D4       *set mode to address register
00001A46  C8FC 0006                783          MULU    #6,D4
00001A4A                           784  
00001A4A                           785  
00001A4A  43F9 00001D3C            786          LEA     EA_MODE,A1 
00001A50  4EB1 4000                787          JSR     (A1,D4)
00001A54  4E75                     788          RTS
00001A56                           789  
00001A56                           790  *********** BCC_DISP *********
00001A56                           791  BCC_DISP:
00001A56  4243                     792          CLR D3
00001A58  2602                     793          MOVE.L  D2,D3
00001A5A  43F9 00002543            794          LEA     _ABS,A1
00001A60  4EB9 00002268            795          JSR     WRITE_ASCII
00001A66  0243 00FF                796          ANDI.W  #$00FF,D3
00001A6A  0C43 0000                797          CMPI.W  #$0000,D3 
00001A6E  6700 000C                798          BEQ     NEXT_WORD 
00001A72  0C43 0000                799          CMPI.W  #$0000,D3 
00001A76  6600 000C                800          BNE     LAST_8
00001A7A  4E75                     801          RTS
00001A7C                           802  
00001A7C                           803  NEXT_WORD:
00001A7C  4EB9 00002044            804          JSR     NEXT_MEM_WORD_TO_BUF
00001A82  4E75                     805          RTS 
00001A84                           806  
00001A84                           807  LAST_8:
00001A84  4245                     808          CLR D5
00001A86                           809  
00001A86  3A0D                     810          MOVE.W  A5,D5
00001A88  5505                     811          SUB.B   #2,D5
00001A8A  5443                     812          ADD.W   #2,D3
00001A8C  DA43                     813          ADD.W   D3,D5
00001A8E  3245                     814          MOVEA.W D5,A1
00001A90  4EB9 00002216            815          JSR WRITE_HEX_TO_ASCII
00001A96  4E75                     816          RTS
00001A98                           817  
00001A98                           818  
00001A98                           819  
00001A98                           820  ********* DM_EA ************
00001A98                           821  DM_EA:
00001A98  2602                     822          MOVE.L  D2,D3 
00001A9A  2802                     823          MOVE.L  D2,D4
00001A9C  0244 0038                824          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001AA0  0243 0007                825          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001AA4  E68C                     826          LSR.L   #3,D4
00001AA6  13C4 000023FB            827          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001AAC  13C3 000023FC            828          MOVE.B  D3,SRC_REG      * save source register to memory
00001AB2  C8FC 0006                829          MULU    #6,D4
00001AB6  C6FC 0006                830          MULU    #6,D3
00001ABA                           831  
00001ABA  43F9 00001D3C            832          LEA     EA_MODE,A1
00001AC0  4EB1 4000                833          JSR     (A1,D4)
00001AC4  43F9 00002557            834          LEA     _COMMA,A1
00001ACA  4EB9 00002268            835          JSR     WRITE_ASCII
00001AD0                           836  
00001AD0  4243                     837          CLR     D3
00001AD2  4244                     838          CLR     D4 
00001AD4                           839  
00001AD4  2602                     840          MOVE.L  D2,D3 
00001AD6  0243 0E00                841          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001ADA  1A3C 0009                842          MOVE.B  #9, D5
00001ADE  EA6B                     843          LSR     D5,D3 
00001AE0  13C3 000023FA            844          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001AE6  C6FC 0006                845          MULU   #6,D3
00001AEA  43F9 0000252E            846          LEA     _DR,A1 
00001AF0  4EB9 00002268            847          JSR WRITE_ASCII
00001AF6                           848  
00001AF6                           849  
00001AF6  43F9 00001E58            850          LEA     EA_REG,A1 
00001AFC  4EB1 3000                851          JSR     (A1,D3)
00001B00  4E75                     852          RTS 
00001B02                           853  
00001B02                           854  ****** 0PMODE_EA ************
00001B02                           855  OPMODE_EA:
00001B02  2802                     856          MOVE.L  D2,D4
00001B04  0244 01C0                857          ANDI.W  #Bit1Mask,D4            *FIND OPMODE
00001B08  EC8C                     858          LSR.L   #6,D4
00001B0A  13C4 000023F9            859          MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
00001B10  C8FC 0006                860          MULU    #6,D4 
00001B14                           861  
00001B14  43F9 00001C82            862          LEA     OPMODE,A1               *LOAD OPMODE TABLE
00001B1A  4EB1 4000                863          JSR     (A1,D4)                 *JMP TO OPMODE TABLE
00001B1E                           864  
00001B1E                           865  
00001B1E  BA3C 0001                866          CMP.B   #%1,D5                  *if flag == 1, <ea> V Dn - Dn
00001B22  6700 0082                867          BEQ     D_TO_EA
00001B26  BA3C 0003                868          CMP.B   #%11,D5                 *if flag == 2, <ea> - An
00001B2A  6700 00E8                869          BEQ     EA_TO_A
00001B2E  BA3C 0001                870          CMP.B   #%1,D5                  *else, Dn V <ea> - <ea>
00001B32  6600 0004                871          BNE     EA_TO_D
00001B36  4E75                     872          RTS
00001B38                           873  EA_TO_D:
00001B38  4243                     874          CLR     D3
00001B3A  4244                     875          CLR     D4
00001B3C                           876  
00001B3C  2602                     877          MOVE.L  D2,D3 
00001B3E  2802                     878          MOVE.L  D2,D4
00001B40  0244 0038                879          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001B44  0243 0007                880          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001B48  E68C                     881          LSR.L   #3,D4
00001B4A  13C4 000023FB            882          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001B50  13C3 000023FC            883          MOVE.B  D3,SRC_REG      * save source register to memory
00001B56  C8FC 0006                884          MULU    #6,D4
00001B5A  C6FC 0006                885          MULU    #6,D3
00001B5E                           886  
00001B5E  43F9 00001D3C            887          LEA     EA_MODE,A1
00001B64  4EB1 4000                888          JSR     (A1,D4)
00001B68  43F9 00002557            889          LEA     _COMMA,A1
00001B6E  4EB9 00002268            890          JSR     WRITE_ASCII
00001B74                           891  
00001B74  4243                     892          CLR     D3
00001B76  4244                     893          CLR     D4 
00001B78                           894  
00001B78  2602                     895          MOVE.L  D2,D3 
00001B7A  0243 0E00                896          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001B7E  1A3C 0009                897          MOVE.B  #9, D5
00001B82  EA6B                     898          LSR     D5,D3 
00001B84  13C3 000023FA            899          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001B8A  C6FC 0006                900          MULU   #6,D3
00001B8E  43F9 0000252E            901          LEA     _DR,A1 
00001B94  4EB9 00002268            902          JSR WRITE_ASCII
00001B9A                           903  
00001B9A                           904  
00001B9A  43F9 00001E58            905          LEA     EA_REG,A1 
00001BA0  4EB1 3000                906          JSR     (A1,D3)
00001BA4  4E75                     907          RTS
00001BA6                           908  
00001BA6                           909  D_TO_EA:
00001BA6                           910  
00001BA6  4243                     911          CLR     D3
00001BA8  4244                     912          CLR     D4 
00001BAA                           913  
00001BAA  2602                     914          MOVE.L  D2,D3 
00001BAC  0243 0E00                915          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001BB0  1A3C 0009                916          MOVE.B  #9, D5
00001BB4  EA6B                     917          LSR     D5,D3 
00001BB6  13C3 000023FA            918          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001BBC  C6FC 0006                919          MULU   #6,D3
00001BC0  43F9 0000252E            920          LEA     _DR,A1 
00001BC6  4EB9 00002268            921          JSR WRITE_ASCII
00001BCC                           922  
00001BCC                           923  
00001BCC  43F9 00001E58            924          LEA     EA_REG,A1 
00001BD2  4EB1 3000                925          JSR     (A1,D3)
00001BD6  43F9 00002557            926          LEA     _COMMA,A1
00001BDC  4EB9 00002268            927          JSR     WRITE_ASCII
00001BE2                           928  
00001BE2  4243                     929          CLR     D3
00001BE4  4244                     930          CLR     D4
00001BE6                           931  
00001BE6  2602                     932          MOVE.L  D2,D3 
00001BE8  2802                     933          MOVE.L  D2,D4
00001BEA  0244 0038                934          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001BEE  0243 0007                935          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001BF2  E68C                     936          LSR.L   #3,D4
00001BF4  13C4 000023FB            937          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001BFA  13C3 000023FC            938          MOVE.B  D3,SRC_REG      * save source register to memory
00001C00  C8FC 0006                939          MULU    #6,D4
00001C04  C6FC 0006                940          MULU    #6,D3
00001C08                           941  
00001C08  43F9 00001D3C            942          LEA     EA_MODE,A1
00001C0E  4EB1 4000                943          JSR     (A1,D4)
00001C12  4E75                     944          RTS
00001C14                           945  
00001C14                           946  EA_TO_A:
00001C14  4243                     947          CLR     D3
00001C16  4244                     948          CLR     D4
00001C18                           949  
00001C18  2602                     950          MOVE.L  D2,D3 
00001C1A  2802                     951          MOVE.L  D2,D4
00001C1C  0244 0038                952          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001C20  0243 0007                953          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001C24  E68C                     954          LSR.L   #3,D4
00001C26  13C4 000023FB            955          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001C2C  13C3 000023FC            956          MOVE.B  D3,SRC_REG      * save source register to memory
00001C32  C8FC 0006                957          MULU    #6,D4
00001C36  C6FC 0006                958          MULU    #6,D3
00001C3A                           959  
00001C3A  43F9 00001D3C            960          LEA     EA_MODE,A1
00001C40  4EB1 4000                961          JSR     (A1,D4)
00001C44  43F9 00002557            962          LEA     _COMMA,A1
00001C4A  4EB9 00002268            963          JSR     WRITE_ASCII
00001C50                           964  
00001C50  4243                     965          CLR     D3
00001C52  4244                     966          CLR     D4 
00001C54                           967  
00001C54  2602                     968          MOVE.L  D2,D3 
00001C56  0243 0E00                969          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001C5A  1A3C 0009                970          MOVE.B  #9, D5
00001C5E  EA6B                     971          LSR     D5,D3 
00001C60  13C3 000023FA            972          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001C66  C6FC 0006                973          MULU   #6,D3
00001C6A  43F9 00002530            974          LEA     _AR,A1 
00001C70  4EB9 00002268            975          JSR WRITE_ASCII
00001C76                           976  
00001C76                           977  
00001C76  43F9 00001E58            978          LEA     EA_REG,A1 
00001C7C  4EB1 3000                979          JSR     (A1,D3)
00001C80  4E75                     980          RTS
00001C82                           981  
00001C82                           982  ******* OPMODE **********
00001C82                           983  OPMODE:
00001C82  4EF9 00001CB2            984          JMP     OM000
00001C88  4EF9 00001CC2            985          JMP     OM001
00001C8E  4EF9 00001CD2            986          JMP     OM010
00001C94  4EF9 00001CE2            987          JMP     OM011
00001C9A  4EF9 00001CF4            988          JMP     OM100
00001CA0  4EF9 00001D06            989          JMP     OM101
00001CA6  4EF9 00001D18            990          JMP     OM110
00001CAC  4EF9 00001D2A            991          JMP     OM111
00001CB2                           992  
00001CB2                           993  OM000:
00001CB2  43F9 0000249F            994          LEA     _B,A1
00001CB8  4EB9 00002268            995          JSR     WRITE_ASCII
00001CBE  4245                     996          CLR     D5
00001CC0  4E75                     997          RTS   
00001CC2                           998  OM001:
00001CC2  43F9 000024A3            999          LEA     _W,A1
00001CC8  4EB9 00002268           1000          JSR     WRITE_ASCII
00001CCE  4245                    1001          CLR     D5
00001CD0                          1002  
00001CD0  4E75                    1003          RTS   
00001CD2                          1004  OM010:
00001CD2  43F9 000024A7           1005          LEA     _L,A1
00001CD8  4EB9 00002268           1006          JSR     WRITE_ASCII
00001CDE  4245                    1007          CLR     D5
00001CE0                          1008  
00001CE0  4E75                    1009          RTS   
00001CE2                          1010  OM011:
00001CE2  43F9 000024A3           1011          LEA     _W,A1
00001CE8  4EB9 00002268           1012          JSR     WRITE_ASCII
00001CEE  1A3C 0003               1013          MOVE.B  #%11,D5
00001CF2  4E75                    1014          RTS   
00001CF4                          1015  OM100:
00001CF4  43F9 0000249F           1016          LEA     _B,A1
00001CFA  4EB9 00002268           1017          JSR     WRITE_ASCII
00001D00  1A3C 0001               1018          MOVE.B  #%1,D5
00001D04                          1019  
00001D04  4E75                    1020          RTS   
00001D06                          1021  OM101:
00001D06  43F9 000024A3           1022          LEA     _W,A1
00001D0C  4EB9 00002268           1023          JSR     WRITE_ASCII
00001D12  1A3C 0001               1024          MOVE.B  #%1,D5
00001D16                          1025  
00001D16  4E75                    1026          RTS   
00001D18                          1027  OM110:
00001D18  43F9 000024A7           1028          LEA     _L,A1
00001D1E  4EB9 00002268           1029          JSR     WRITE_ASCII
00001D24  1A3C 0001               1030          MOVE.B  #%1,D5
00001D28                          1031  
00001D28  4E75                    1032          RTS   
00001D2A                          1033  OM111:
00001D2A  43F9 000024A7           1034          LEA     _L,A1
00001D30  4EB9 00002268           1035          JSR     WRITE_ASCII
00001D36  1A3C 0003               1036          MOVE.B  #%11,D5
00001D3A  4E75                    1037          RTS   
00001D3C                          1038   
00001D3C                          1039          
00001D3C                          1040  
00001D3C                          1041  
00001D3C                          1042  ******** JUMP TABLE FOR EA MODES *********
00001D3C                          1043  EA_MODE:
00001D3C  4EF9 00001D6C           1044          JMP     EA000
00001D42  4EF9 00001D84           1045          JMP     EA001
00001D48  4EF9 00001D9C           1046          JMP     EA010
00001D4E  4EF9 00001DC0           1047          JMP     EA011
00001D54  4EF9 00001DE4           1048          JMP     EA100
00001D5A  4EF9 00001E08           1049          JMP     EA101
00001D60  4EF9 00001E0A           1050          JMP     EA110
00001D66  4EF9 00001E0C           1051          JMP     EA111
00001D6C                          1052  
00001D6C                          1053  EA000:
00001D6C  43F9 0000252E           1054          LEA     _DR,A1 
00001D72  4EB9 00002268           1055          JSR     WRITE_ASCII
00001D78  43F9 00001E58           1056          LEA     EA_REG,A1
00001D7E  4EB1 3000               1057          JSR     (A1,D3)
00001D82  4E75                    1058          RTS     
00001D84                          1059  EA001:
00001D84  43F9 00002530           1060          LEA     _AR,A1 
00001D8A  4EB9 00002268           1061          JSR     WRITE_ASCII
00001D90  43F9 00001E58           1062          LEA     EA_REG,A1
00001D96  4EB1 3000               1063          JSR     (A1,D3)
00001D9A  4E75                    1064          RTS     
00001D9C                          1065  EA010:
00001D9C  43F9 00002532           1066          LEA     _IND_AR1,A1 
00001DA2  4EB9 00002268           1067          JSR     WRITE_ASCII
00001DA8  43F9 00001E58           1068          LEA     EA_REG,A1
00001DAE  4EB1 3000               1069          JSR     (A1,D3)
00001DB2  43F9 00002535           1070          LEA     _IND_AR2,A1
00001DB8  4EB9 00002268           1071          JSR     WRITE_ASCII
00001DBE  4E75                    1072          RTS     
00001DC0                          1073      
00001DC0                          1074  EA011:
00001DC0  43F9 00002537           1075          LEA     _AR_POST1,A1 
00001DC6  4EB9 00002268           1076          JSR     WRITE_ASCII
00001DCC  43F9 00001E58           1077          LEA     EA_REG,A1
00001DD2  4EB1 3000               1078          JSR     (A1,D3)
00001DD6  43F9 0000253A           1079          LEA     _AR_POST2,A1
00001DDC  4EB9 00002268           1080          JSR     WRITE_ASCII
00001DE2  4E75                    1081          RTS
00001DE4                          1082       
00001DE4                          1083      
00001DE4                          1084  EA100:
00001DE4  43F9 0000253D           1085          LEA     _AR_PRE1,A1 
00001DEA  4EB9 00002268           1086          JSR     WRITE_ASCII
00001DF0  43F9 00001E58           1087          LEA     EA_REG,A1
00001DF6  4EB1 3000               1088          JSR     (A1,D3)
00001DFA  43F9 00002541           1089          LEA     _AR_PRE2,A1
00001E00  4EB9 00002268           1090          JSR     WRITE_ASCII
00001E06  4E75                    1091          RTS   
00001E08                          1092  
00001E08  4E75                    1093  EA101:  RTS
00001E0A                          1094  
00001E0A  4E75                    1095  EA110:  RTS
00001E0C                          1096  
00001E0C                          1097  EA111:      
00001E0C  86FC 0006               1098          DIVU    #6,D3   * divide register num by 6 to undo jmp table multiplication
00001E10                          1099          
00001E10  B67C 0000               1100          CMP #0,D3   * if reg 0 load word from mem
00001E14  6600 0016               1101          BNE EA111_R1
00001E18  43F9 00002543           1102          LEA _ABS,A1
00001E1E  4EB9 00002268           1103          JSR WRITE_ASCII     * write $ to buffer
00001E24  4EB9 00002044           1104          JSR NEXT_MEM_WORD_TO_BUF
00001E2A  4E75                    1105          RTS
00001E2C                          1106  EA111_R1:
00001E2C  B67C 0001               1107          CMP #1,D3   * if reg 1 load long from mem
00001E30  6600 0016               1108          BNE EA111_R4
00001E34  43F9 00002543           1109          LEA _ABS,A1
00001E3A  4EB9 00002268           1110          JSR WRITE_ASCII     * write $ to buffer
00001E40  4EB9 0000205A           1111          JSR NEXT_MEM_LONG_TO_BUF
00001E46  4E75                    1112          RTS
00001E48                          1113  EA111_R4:       
00001E48  B67C 0004               1114          CMP #%100,D3  * if reg 4 load immediate value
00001E4C                          1115          * will need to know instruction size to propperly grab this
00001E4C  6600 0008               1116          BNE EA_MODE_DONE    * EA error if not equal to one of the valid modes
00001E50  4EB9 00001FF6           1117          JSR ADD_IMMEDIATE_TO_BUF
00001E56                          1118  EA_MODE_DONE:
00001E56  4E75                    1119          RTS
00001E58                          1120          
00001E58                          1121  
00001E58                          1122  ********* JUMP TABLE FOR REGISTERS ******
00001E58                          1123  EA_REG:
00001E58  4EF9 00001E88           1124          JMP     REG000
00001E5E  4EF9 00001E96           1125          JMP     REG001
00001E64  4EF9 00001EA4           1126          JMP     REG010
00001E6A  4EF9 00001EB2           1127          JMP     REG011
00001E70  4EF9 00001EC0           1128          JMP     REG100
00001E76  4EF9 00001ECE           1129          JMP     REG101
00001E7C  4EF9 00001EDC           1130          JMP     REG110
00001E82  4EF9 00001EEA           1131          JMP     REG111
00001E88                          1132  
00001E88                          1133  REG000:
00001E88  43F9 00002547           1134          LEA     _ZERO,A1 
00001E8E  4EB9 00002268           1135          JSR     WRITE_ASCII
00001E94  4E75                    1136          RTS   
00001E96                          1137  REG001:
00001E96  43F9 00002549           1138          LEA     _ONE,A1 
00001E9C  4EB9 00002268           1139          JSR     WRITE_ASCII
00001EA2  4E75                    1140          RTS   
00001EA4                          1141  REG010:
00001EA4  43F9 0000254B           1142          LEA     _TWO,A1 
00001EAA  4EB9 00002268           1143          JSR     WRITE_ASCII
00001EB0  4E75                    1144          RTS   
00001EB2                          1145  REG011:
00001EB2  43F9 0000254D           1146          LEA     _THREE,A1 
00001EB8  4EB9 00002268           1147          JSR     WRITE_ASCII
00001EBE  4E75                    1148          RTS   
00001EC0                          1149  REG100:
00001EC0  43F9 0000254F           1150          LEA     _FOUR,A1 
00001EC6  4EB9 00002268           1151          JSR     WRITE_ASCII
00001ECC  4E75                    1152          RTS   
00001ECE                          1153  REG101:
00001ECE  43F9 00002551           1154          LEA     _FIVE,A1 
00001ED4  4EB9 00002268           1155          JSR     WRITE_ASCII
00001EDA  4E75                    1156          RTS   
00001EDC                          1157  REG110:
00001EDC  43F9 00002553           1158          LEA     _SIX,A1 
00001EE2  4EB9 00002268           1159          JSR     WRITE_ASCII
00001EE8  4E75                    1160          RTS   
00001EEA                          1161  REG111:
00001EEA  43F9 00002555           1162          LEA     _SEVEN,A1 
00001EF0  4EB9 00002268           1163          JSR     WRITE_ASCII
00001EF6  4E75                    1164          RTS   
00001EF8                          1165    
00001EF8                          1166   
00001EF8                          1167  ***      EA ERRORS      ***
00001EF8                          1168  
00001EF8                          1169  * invalid codes for all instructions
00001EF8                          1170  BASE_EA_ERR_CHK:
00001EF8  48E7 C080               1171          MOVEM.L D0-D1/A0,-(SP)
00001EFC                          1172          * load source modes and registers
00001EFC  1039 000023FB           1173          MOVE.B  SRC_MODE,D0
00001F02  1239 000023FC           1174          MOVE.B  SRC_REG,D1
00001F08  0C00 0008               1175          CMPI.B  #8,D0
00001F0C  6C00 0068               1176          BGE     EA_ERR
00001F10  C0FC 0006               1177          MULU   #6,D0       
00001F14  41F9 00001F46           1178          LEA     BASE_EA_ERR_MODES,A0 
00001F1A  4EB0 0000               1179          JSR     (A0,D0)
00001F1E                          1180  
00001F1E                          1181          * load destination modes and registers
00001F1E  1039 000023F9           1182          MOVE.B  DEST_MODE,D0
00001F24  1239 000023FA           1183          MOVE.B  DEST_REG,D1
00001F2A  0C00 0008               1184          CMPI.B  #8,D0
00001F2E  6C00 0046               1185          BGE     EA_ERR
00001F32  C0FC 0006               1186          MULU   #6,D0
00001F36  41F9 00001F46           1187          LEA     BASE_EA_ERR_MODES,A0 
00001F3C  4EB0 0000               1188          JSR     (A0,D0)
00001F40                          1189  
00001F40  4CDF 0103               1190          MOVEM.L (SP)+,D0-D1/A0
00001F44  4E75                    1191          RTS
00001F46                          1192  * jmp table to handle base ea errors        
00001F46                          1193  BASE_EA_ERR_MODES:
00001F46                          1194          * NOP slide to catch good modes and direct to rts
00001F46  4E71                    1195          NOP
00001F48  4E71                    1196          NOP
00001F4A  4E71                    1197          NOP
00001F4C  4E71                    1198          NOP
00001F4E  4E71                    1199          NOP
00001F50  4E71                    1200          NOP
00001F52  4E71                    1201          NOP
00001F54  4E71                    1202          NOP
00001F56  4E71                    1203          NOP
00001F58  4E71                    1204          NOP
00001F5A  4E71                    1205          NOP
00001F5C  4E71                    1206          NOP
00001F5E  4E75                    1207          RTS * return on good modes
00001F60  4E71                    1208          NOP * 2 extra words needed for ofset to jmps
00001F62  4E71                    1209          NOP
00001F64  4EF9 00001F76           1210          JMP EA_ERR      * mode (d16,An)      
00001F6A  4EF9 00001F76           1211          JMP EA_ERR      * mode (d8,An,Xn)
00001F70  4EF9 00001FA6           1212          JMP MODE_7_CHK
00001F76                          1213  
00001F76                          1214          
00001F76                          1215  * write error to string buffer and move on to next instruction
00001F76                          1216  EA_ERR:
00001F76  48E7 8040               1217          MOVEM.L D0/A1,-(SP)
00001F7A  2039 000022FC           1218          MOVE.L  END_OP_CODE_PTR,D0      * load end of opcode pointer
00001F80  0C80 00000000           1219          CMPI.L  #0,D0                   * if ptr is 0 use existing str buf value
00001F86  6700 0004               1220          BEQ     LOAD_EA_ERR_MSG
00001F8A  2840                    1221          MOVEA.L D0,A4                   * reset string buffer pointer to end of opcode neumonic 
00001F8C                          1222          * load error message to buffer
00001F8C                          1223  LOAD_EA_ERR_MSG:
00001F8C  43F9 0000280C           1224          LEA     EA_ERR_MSG,A1
00001F92  4EB9 00002268           1225          JSR     WRITE_ASCII
00001F98  13FC 00FF 000023FD      1226          MOVE.B  #-1,EA_ERR_FLAG
00001FA0  4CDF 0201               1227          MOVEM.L (SP)+,D0/A1
00001FA4  4E75                    1228          RTS
00001FA6                          1229  
00001FA6                          1230  * check mode 7 for invalid reg values
00001FA6                          1231  MODE_7_CHK:
00001FA6  48E7 4000               1232          MOVEM.L D1,-(SP)
00001FAA  B23C 0002               1233          CMP.B #%010,D1 * check for (d16,PC) 
00001FAE  67C6                    1234          BEQ   EA_ERR
00001FB0  B23C 0003               1235          CMP.B #%011,D1 * check for (d8,PC,Xn)
00001FB4  67C0                    1236          BEQ   EA_ERR
00001FB6  4CDF 0002               1237          MOVEM.L (SP)+,D1
00001FBA  4E75                    1238          RTS   
00001FBC                          1239  
00001FBC                          1240  * destination adress register and imediate mode are invalid eas
00001FBC                          1241  DEST_AN_IM_INVALID:
00001FBC  48E7 C000               1242          MOVEM.L D0-D1,-(SP)
00001FC0                          1243          * load source modes and registers
00001FC0                          1244    * load destination modes and registers
00001FC0  1039 000023F9           1245          MOVE.B  DEST_MODE,D0
00001FC6  1239 000023FA           1246          MOVE.B  DEST_REG,D1
00001FCC  B03C 0001               1247          CMP.B   #1,D0   * if address register mode error
00001FD0  6600 000A               1248          BNE     AN_IM_01
00001FD4  4EB8 1F76               1249          JSR     EA_ERR
00001FD8  6000 0016               1250          BRA     AN_IM_02
00001FDC                          1251  AN_IM_01:
00001FDC  B03C 0007               1252          CMP.B   #7,D0    * if immediate data error
00001FE0  6600 000E               1253          BNE     AN_IM_02
00001FE4  B23C 0004               1254          CMP.B   #4,D1
00001FE8  6600 0006               1255          BNE     AN_IM_02
00001FEC  4EB8 1F76               1256          JSR     EA_ERR     
00001FF0                          1257  AN_IM_02: 
00001FF0  4CDF 0003               1258          MOVEM.L (SP)+,D0-D1
00001FF4  4E75                    1259          RTS
00001FF6                          1260  
00001FF6                          1261  ***       UTILS     ****
00001FF6                          1262  
00001FF6                          1263  ADD_IMMEDIATE_TO_BUF:
00001FF6  48E7 4040               1264          MOVEM.L D1/A1,-(SP)
00001FFA  1239 000023F8           1265          MOVE.B  INST_SZ,D1  * load instruction size
00002000  0C01 0001               1266          CMPI.B  #BYTE,D1
00002004  6700 000A               1267          BEQ IN_IM_W     * if byte goto word since behavior is the same
00002008  0C01 0003               1268                  CMPI.B  #WORD,D1
0000200C  6600 001A               1269          BNE CMP_IM_L    * if not equal to word branch compare to long
00002010                          1270  IN_IM_W:
00002010  43F9 00002545           1271          LEA _IMD,A1     * print next mem word as imediate data to buffer
00002016  4EB9 00002268           1272          JSR WRITE_ASCII
0000201C  4EB9 00002044           1273          JSR NEXT_MEM_WORD_TO_BUF
00002022  4CDF 0202               1274          MOVEM.L (SP)+,D1/A1
00002026  4E75                    1275          RTS
00002028                          1276  CMP_IM_L:
00002028  0C01 0002               1277          CMPI.B  #LONG,D1
0000202C                          1278  *       TODO BNE        EA ERROR
0000202C  43F9 00002545           1279          LEA _IMD,A1      * print next mem long as imediate data to buffer
00002032  4EB9 00002268           1280          JSR WRITE_ASCII
00002038  4EB9 0000205A           1281          JSR     NEXT_MEM_LONG_TO_BUF
0000203E  4CDF 0202               1282          MOVEM.L (SP)+,D1/A1
00002042  4E75                    1283          RTS
00002044                          1284  
00002044                          1285  * read next word of memory to str_buffer advancing current pointer
00002044                          1286  NEXT_MEM_WORD_TO_BUF:
00002044  48E7 4400               1287          MOVEM.L D1/D5,-(SP)
00002048  548D                    1288          ADDA.L  #2,A5   * advance pointer
0000204A  3215                    1289          MOVE.W  (A5),D1 * load next word of memory
0000204C  7A00                    1290          MOVEQ.L #0,D5   * set hex length to word
0000204E  4EB9 00002216           1291          JSR     WRITE_HEX_TO_ASCII
00002054  4CDF 0022               1292          MOVEM.L (SP)+,D1/D5
00002058  4E75                    1293          RTS
0000205A                          1294          
0000205A                          1295  * read next Long of memory to str_buffer advancing current pointer
0000205A                          1296  NEXT_MEM_LONG_TO_BUF:
0000205A  48E7 4400               1297          MOVEM.L D1/D5,-(SP)
0000205E  548D                    1298          ADDA.L  #2,A5 * advance pointer
00002060  2215                    1299          MOVE.L  (A5),D1
00002062  548D                    1300          ADDA.L  #2,A5 * advance pointer again to account for long
00002064  7A20                    1301          MOVEQ.L #32,D5  * set hex length to long
00002066  4EB9 00002216           1302          JSR     WRITE_HEX_TO_ASCII
0000206C  4CDF 0022               1303          MOVEM.L (SP)+,D1/D5
00002070  4E75                    1304          RTS
00002072                          1305  
00002072                          1306  * prompts user for choice
00002072                          1307  * sets d6 to valid choice
00002072                          1308  GET_CHOICE: 
00002072  48E7 C040               1309          MOVEM.L   D0/D1/A1,-(SP)
00002076                          1310  HC_INT_LP:
00002076  4EB9 000022DE           1311          JSR     RESET_BUF_PTR   * move a4 to start of string buffer
0000207C  43F9 000025E7           1312          LEA     CHOICE_PROMPT,A1
00002082  4EB9 00002268           1313          JSR     WRITE_ASCII
00002088  4EB9 000022B6           1314          JSR     TERM_PNT_RST_BUF
0000208E  103C 0004               1315          MOVE.B  #4,D0   * read a number from keyboard into d1
00002092  4E4F                    1316          TRAP    #15
00002094                          1317  CHOICE_1:
00002094  0C41 0001               1318          CMPI    #DISSASEMBLE ,D1
00002098  6700 0024               1319          BEQ     CHOICE_DNE    
0000209C                          1320  CHOICE_2:
0000209C  0C41 0002               1321          CMPI    #QUIT_PROG,D1
000020A0  6700 001C               1322          BEQ     CHOICE_DNE    
000020A4                          1323  CHOICE_ERR:
000020A4  43F9 0000263C           1324          LEA     INV_CHOICE,A1
000020AA  4EB9 00002268           1325          JSR     WRITE_ASCII
000020B0  4EB9 000022B6           1326          JSR     TERM_PNT_RST_BUF
000020B6  4EB9 000020C6           1327          JSR     WAIT_USR_INPUT
000020BC  60B8                    1328          BRA     HC_INT_LP
000020BE                          1329          
000020BE                          1330  CHOICE_DNE:
000020BE  1C01                    1331          MOVE.B  D1,D6
000020C0  4CDF 0203               1332          MOVEM.L   (SP)+,D0/D1/A1
000020C4  4E75                    1333          RTS               
000020C6                          1334  
000020C6                          1335  * prompt user to press enter to continue
000020C6                          1336  WAIT_USR_INPUT:            
000020C6  48E7 C040               1337          MOVEM.L   D0/D1/A1,-(SP)
000020CA  43F9 00002657           1338          LEA     ENT_TO_CONT,A1  * load and print prompt
000020D0  4EB9 00002206           1339          JSR     PRINT_A1
000020D6  7005                    1340          MOVEQ.L #5,D0   * read in a char from keyboard
000020D8  4E4F                    1341          TRAP    #15
000020DA  4CDF 0203               1342          MOVEM.L   (SP)+,D0/D1/A1
000020DE  4E75                    1343          RTS
000020E0                          1344  
000020E0                          1345  LOAD_DATA_STR_INTO_BUF: * expects address to be in a5
000020E0  48E7 4000               1346          MOVEM.L   D1,-(SP)
000020E4  4EB9 000022DE           1347          JSR     RESET_BUF_PTR
000020EA  220D                    1348          MOVE.L  A5,D1
000020EC  7A20                    1349          MOVEQ   #32,D5   * set hex length to long for address
000020EE  4EB9 00002216           1350          JSR     WRITE_HEX_TO_ASCII * write memory address to buffer
000020F4  4EB9 00002292           1351          JSR     WRITE_TAB_A4    * wrtie a tab
000020FA  43F9 0000282D           1352          LEA     DATA_MSG,A1     * Load template for data
00002100  4EB9 00002268           1353          JSR     WRITE_ASCII     * write 'DATA    $' to buffer
00002106  3215                    1354          MOVE.W  (A5),D1   * load address contents of memory to d1 for printing
00002108  7A00                    1355          MOVEQ   #0,D5   * set hex length to word for memory contents
0000210A  4EB9 00002216           1356          JSR     WRITE_HEX_TO_ASCII * save to buffer
00002110  4CDF 0002               1357          MOVEM.L   (SP)+,D1
00002114  4E75                    1358          RTS
00002116                          1359  
00002116  103C 0009               1360  DONE    MOVE.B  #9,D0       * Trap task 9 halt simulator
0000211A  4E4F                    1361          TRAP    #15
0000211C                          1362          
0000211C                          1363  * Converts ASCII string containing chars 0-9 and A-F uppercase to hexidecimal number
0000211C                          1364  * returns result in D6
0000211C                          1365  TO_HEX
0000211C  48E7 E060               1366          MOVEM.L   D0-D2/A1-A2,-(SP)   * save state of registers to be changed
00002120  4282                    1367          CLR.L   D2      * clear to hold digit magnitude
00002122  4286                    1368          CLR.L   D6      * clear to hold result
00002124  5341                    1369          SUBI    #1,D1    * subtract 1
00002126  C2FC 0004               1370          MULU    #4,D1   * multiply length by four to get length in binary
0000212A                          1371          
0000212A                          1372  TO_HEX_INTERNAL:
0000212A  1019                    1373          MOVE.B  (A1)+,D0     * Load char at A1 into D0
0000212C  6700 001A               1374          BEQ     END_H       * GOTO end if byte is zero (null terminated)
00002130  0C40 0039               1375          CMPI    #$39,D0     * compare char value to 39
00002134  6F00 0004               1376          BLE     _0_9        * GOTO 0_9 if <= 39
00002138  5F00                    1377  A_F     SUBI.B  #$7,D0      * Subtract 7 from D0) for ASCII A-F
0000213A  0200 000F               1378  _0_9    ANDI.B  #$0F,D0     * AND with 00001111 to isolate left most 4 bits, converts to hex
0000213E  2400                    1379          MOVE.L  D0,D2        * put hex digit in D2
00002140  E3AA                    1380          LSL.L   D1,D2       * shift hex digit final postion    
00002142  DC82                    1381          ADD.L   D2,D6       * add to hex result
00002144  5981                    1382          SUBI.L    #4,D1       * subract one hex digit of bits from remaining length 
00002146  60E2                    1383          BRA     TO_HEX_INTERNAL   * convert next byte
00002148  4CDF 0607               1384  END_H   MOVEM.L (SP)+,D0-D2/A1-A2
0000214C  4E75                    1385          RTS
0000214E                          1386  
0000214E                          1387  
0000214E                          1388  *   input address to hexadecimal saves output at A1
0000214E                          1389  IN_ADDR_TO_HEX:
0000214E  48E7 0200               1390          MOVEM.L   D6,-(SP)
00002152  4EB8 211C               1391          JSR     TO_HEX          * else convert to hex
00002156  2286                    1392          MOVE.L  D6,(A1)
00002158  4CDF 0040               1393          MOVEM.L   (SP)+,D6
0000215C  4E75                    1394          RTS
0000215E                          1395  
0000215E                          1396  * check start and end addresses for errors
0000215E                          1397  CHK_ST_E_ADRS: * sets D5 to 1 if an error has ocurred
0000215E  48E7 4800               1398          MOVEM.L   D1/D4,-(SP)
00002162  7A00                    1399          MOVEQ   #0,D5       * clear error flag
00002164  2439 000022E4           1400          MOVE.L  ST_ADDR,D2  * load start address
0000216A  2639 000022F0           1401          MOVE.L  E_ADDR,D3   * load end address
00002170                          1402          
00002170                          1403  LEN_CHK:                    * check address length
00002170  1239 00002304           1404          MOVE.B  ST_LEN,D1   * load start and end address lengths
00002176  1839 00002305           1405          MOVE.B  E_LEN,D4
0000217C                          1406          
0000217C  0C01 0008               1407          CMPI.B  #8,D1       * check if start addr length is less than or equal to 8
00002180  6F00 000E               1408          BLE     E_LEN_CHK   * check end address if no length error
00002184  4EB9 000021C4           1409          JSR     PLEN_ERR    * print length error message
0000218A  7A01                    1410          MOVEQ   #1,D5       * set error flag
0000218C  6000 0012               1411          BRA     ODD_CHK     * skip end length check if start failed
00002190                          1412  E_LEN_CHK:
00002190  0C04 0008               1413          CMPI.B  #8,D4
00002194  6F00 000A               1414          BLE     ODD_CHK     * if no error skip to odd checking
00002198  4EB9 000021C4           1415          JSR     PLEN_ERR    * print length error message
0000219E  7A01                    1416          MOVEQ   #1,D5       * set error flag
000021A0                          1417  
000021A0                          1418  ODD_CHK:                    * check if start address is odd
000021A0  0802 0000               1419          BTST.L  #0,D2       * test start addres LSB to see if even
000021A4  6700 000A               1420          BEQ     S_GT_E
000021A8  4EB9 000021DA           1421          JSR     PODD_ERR    * print odd start address error
000021AE  7A01                    1422          MOVEQ   #1,D5       * set error flag
000021B0                          1423          
000021B0                          1424  S_GT_E:                     * start address greater than or less than end
000021B0  B483                    1425          CMP.L   D3,D2      * check if end is greater than or equal to start
000021B2  6F00 000A               1426          BLE     CHK_SEA_DONE   * skip to end if no error
000021B6  4EB9 000021F0           1427          JSR     PS_GT_ERR   * print start greater than end error
000021BC  7A01                    1428          MOVEQ   #1,D5       * set error flag
000021BE                          1429        
000021BE                          1430  CHK_SEA_DONE:
000021BE  4CDF 0012               1431          MOVEM.L   (SP)+,D1/D4
000021C2  4E75                    1432          RTS             
000021C4                          1433          
000021C4                          1434  *   print address length input error
000021C4                          1435  PLEN_ERR:
000021C4  48E7 0040               1436          MOVEM.L   A1,-(SP) 
000021C8  43F9 00002709           1437          LEA     ADR_LEN_ERR,A1   * load address input error message 
000021CE  4EB9 00002206           1438          JSR     PRINT_A1
000021D4  4CDF 0200               1439          MOVEM.L   (SP)+,A1
000021D8  4E75                    1440          RTS         
000021DA                          1441  
000021DA                          1442  PODD_ERR: * print start address odd error
000021DA  48E7 0040               1443          MOVEM.L   A1,-(SP) 
000021DE  43F9 0000274E           1444          LEA     ADR_ODD_ERR,A1
000021E4  4EB9 00002206           1445          JSR     PRINT_A1
000021EA  4CDF 0200               1446          MOVEM.L   (SP)+,A1
000021EE  4E75                    1447          RTS
000021F0                          1448  
000021F0                          1449  PS_GT_ERR: * print start address greater than end address error
000021F0  48E7 0040               1450          MOVEM.L   A1,-(SP) 
000021F4  43F9 00002784           1451          LEA     ADR_S_GT_E,A1
000021FA  4EB9 00002206           1452          JSR     PRINT_A1
00002200  4CDF 0200               1453          MOVEM.L   (SP)+,A1
00002204  4E75                    1454          RTS
00002206                          1455  
00002206                          1456   
00002206                          1457  PRINT_A1:
00002206  48E7 8000               1458          MOVEM.L   D0,-(SP) * save register state
0000220A  103C 000E               1459          MOVE.B  #14,D0   * print A1
0000220E  4E4F                    1460          TRAP    #15
00002210  4CDF 0001               1461          MOVEM.L   (SP)+,D0  *  restore register state
00002214  4E75                    1462          RTS
00002216                          1463  
00002216                          1464  ****************************************************
00002216                          1465  * Subroutines for printing and writing to and from
00002216                          1466  * the string buffer at A4
00002216                          1467  ****************************************************        
00002216                          1468  
00002216                          1469  * d5 is a flag for hex value length d5==32 long is used
00002216                          1470  * any other value short is used        
00002216                          1471  WRITE_HEX_TO_ASCII: * write hex in d1 to a4 as ascii
00002216                          1472          * may need to add case to handle sign extended shorts
00002216  48E7 3800               1473          MOVEM.L   D2-D4,-(SP)
0000221A  2401                    1474          MOVE.L  D1,D2   * copy input to working temp var
0000221C  0C85 00000020           1475          CMPI.L  #32,D5           * if masked value is 0 there is no value in long portion of register for unsigned ints
00002222  6600 000E               1476          BNE     h_short         * if not 32 hex value is short else long
00002226                          1477          * setup params for long processing
00002226  263C F0000000           1478          MOVE.L  #$F0000000,D3   * init mask for isolating first long hex most significand digit
0000222C  781C                    1479          MOVE.L  #28,D4          * init shift value for first long hex MSD
0000222E  6000 000A               1480          BRA     h_a_loop
00002232                          1481          
00002232                          1482  h_short: * setup params for short processing
00002232  263C 0000F000           1483          MOVE.L  #$F000,D3   * init mask for isolating first short hex most significand digit
00002238  780C                    1484          MOVE.L  #12,D4      * init shift value for first short hex MSD
0000223A                          1485          
0000223A                          1486  h_a_loop:
0000223A  0C84 00000000           1487          CMPI.L  #0,D4   * compare shift value to 0
00002240  6D00 0020               1488          BLT     h_a_dne * done if less than 0
00002244  2401                    1489          MOVE.L  D1,D2   * copy input to working temp var
00002246  C483                    1490          AND.L   D3,D2   * isolate digit
00002248  E8AA                    1491          LSR.L   D4,D2   * shift to rightmost position
0000224A                          1492          
0000224A  0C82 0000000A           1493          CMPI.L  #$A,D2   * compare to A
00002250  6D00 0004               1494          BLT     h_a_low  * if less than A 0-9
00002254  5E42                    1495          ADDI    #7,D2    * add an additional 7 to A-F     
00002256                          1496  h_a_low:
00002256  0642 0030               1497          ADDI    #$30,D2  * add $30 to convert to ascii
0000225A  18C2                    1498          MOVE.B  D2,(A4)+ * write digit to pointer location
0000225C                          1499          
0000225C  E88B                    1500          LSR.L   #4,D3   * shift mask to isolate next hex digit
0000225E  5984                    1501          SUBI.L  #4,D4   * subtract shift for next digit
00002260  60D8                    1502          BRA     h_a_loop    * return to loop start
00002262  4CDF 001C               1503  h_a_dne MOVEM.L   (SP)+,D2-D4
00002266  4E75                    1504          RTS
00002268                          1505  
00002268                          1506  WRITE_ASCII:    * copies null terminated string from A1 to A4 without null
00002268  48E7 4040               1507          MOVEM.L   D1/A1,-(SP)
0000226C                          1508  w_a_loop:
0000226C  1219                    1509          MOVE.B  (A1)+,D1    * load value at A1
0000226E  6700 0006               1510          BEQ     w_a_done    * if 0(null) is moved copy is done
00002272  18C1                    1511          MOVE.B  D1,(A4)+    * else copy value to A4
00002274  60F6                    1512          BRA     w_a_loop
00002276                          1513  w_a_done:
00002276  4CDF 0202               1514          MOVEM.L   (SP)+,D1/A1
0000227A  4E75                    1515          RTS
0000227C                          1516  
0000227C                          1517  WRITE_NULL_A4: * used to terminate a string in memory 
0000227C  18FC 0000               1518          MOVE.B  #0,(A4)+
00002280  4E75                    1519          RTS
00002282                          1520          
00002282                          1521  WRITE_SPC_A4: * writes an ascii space at a4
00002282  18FC 0020               1522          MOVE.B  #SPACE,(A4)+
00002286  4E75                    1523          RTS 
00002288                          1524  
00002288                          1525  WRITE_NL_A4: * writes a newline at a4
00002288  18FC 000D               1526          MOVE.B  #CR,(A4)+
0000228C  18FC 000A               1527          MOVE.B  #LF,(A4)+
00002290  4E75                    1528          RTS
00002292                          1529          
00002292                          1530  WRITE_TAB_A4:
00002292  18FC 0009               1531          MOVE.B  #TAB,(A4)+
00002296  4E75                    1532          RTS   
00002298                          1533  
00002298                          1534  * writes current string buffer pointer address to end_op_code_ptr
00002298                          1535  SET_END_OP_CODE_PTR:
00002298  23CC 000022FC           1536          MOVE.L  A4,END_OP_CODE_PTR
0000229E  4E75                    1537          RTS
000022A0                          1538  
000022A0                          1539  NL_TERM_PNT_RST_BUF: * write newline, null then print contents then reset bufffer
000022A0  4EB8 2288               1540          JSR     WRITE_NL_A4
000022A4  4EB8 227C               1541          JSR     WRITE_NULL_A4
000022A8  4EB9 000022C8           1542          JSR     PRINT_STR_BUF
000022AE  4EB9 000022DE           1543          JSR     RESET_BUF_PTR
000022B4  4E75                    1544          RTS
000022B6                          1545          
000022B6                          1546  TERM_PNT_RST_BUF: * write null then print contents then reset bufffer pointer
000022B6  4EB8 227C               1547          JSR     WRITE_NULL_A4
000022BA  4EB9 000022C8           1548          JSR     PRINT_STR_BUF
000022C0  4EB9 000022DE           1549          JSR     RESET_BUF_PTR
000022C6  4E75                    1550          RTS
000022C8                          1551          
000022C8                          1552  PRINT_STR_BUF: * prints string buffer contents to console
000022C8  48E7 8040               1553          MOVEM.L   D0/A1,-(SP)
000022CC  43F9 00002307           1554          LEA     STR_BUF,A1  * load string buffer
000022D2  303C 000E               1555          MOVE    #14,D0       * print contents
000022D6  4E4F                    1556          TRAP    #15
000022D8  4CDF 0201               1557          MOVEM.L   (SP)+,D0/A1
000022DC  4E75                    1558          RTS
000022DE                          1559  
000022DE                          1560  RESET_BUF_PTR:  * sets a4 to start of string buffer
000022DE  387C 2307               1561          MOVEA   #STR_BUF,A4
000022E2  4E75                    1562          RTS        
000022E4                          1563  
000022E4                          1564  ****    VARS    ****
000022E4                          1565  ST_ADDR DS.L    3   * allocate 3 longs for address ascii input needs 9 bytes to get 8 chars 
000022F0                          1566  E_ADDR  DS.L    3   * and null terminator, allocating 12 bytes to account for this
000022FC                          1567  
000022FC                          1568  END_OP_CODE_PTR:
000022FC= 00000000                1569          DCB.L   1,0 * pointer to end of opcode neumonic in the string buffer, used for ea errors
00002300                          1570  
00002300                          1571  CURRENT_ADDR:
00002300= 00000000                1572          DCB.L   1,0 * BACKUP FOR CURRENT ADDRESS POINTER
00002304                          1573  
00002304= 00                      1574  ST_LEN  DCB.B   1,0 * var to track start address length
00002305= 01 00                   1575  E_LEN   DC.B    1,0 * var to track end address length
00002307= 00 00 00 00 00 00 ...   1576  STR_BUF DCB.B   241,0  * buffer to hold 240 chars + null terminator. 3 80 char lines
000023F8= 00                      1577  INST_SZ DCB.B   1,0     * used to store instuction size
000023F9                          1578  DEST_MODE:
000023F9= 00                      1579          DCB.B   1,0     * var for destination ea mode
000023FA                          1580  DEST_REG:
000023FA= 00                      1581          DCB.B   1,0     * var to save destination register in
000023FB                          1582  SRC_MODE:
000023FB= 00                      1583          DCB.B   1,0     * var for source ea mode
000023FC                          1584  SRC_REG: 
000023FC= 00                      1585          DCB.B   1,0     * var to save source register in  
000023FD                          1586  EA_ERR_FLAG:
000023FD= 00                      1587          DCB.B   1,0     * var for ea error status
000023FE                          1588           
000023FE                          1589  ****    CONST   ****
000023FE  =0000000D               1590  CR          EQU     $0D     * carraige return          
000023FE  =0000000A               1591  LF          EQU     $0A     * line feed
000023FE  =00000020               1592  SPACE       EQU     $20     * ascii space
000023FE  =00000009               1593  TAB         EQU     $09     * ascii tab character
000023FE  =00000001               1594  DISSASEMBLE EQU     $01     * dissasemble choice number
000023FE  =00000002               1595  QUIT_PROG   EQU     $02     * quit choice number
000023FE  =00000001               1596  BYTE        EQU     %01
000023FE  =00000003               1597  WORD        EQU     %11
000023FE  =00000002               1598  LONG        EQU     %10
000023FE                          1599  
000023FE                          1600  * masks for isolating nibbles with and 0 being least significant nibble
000023FE  =0000F000               1601  Nib3Mask    EQU     $F000 
000023FE  =00000F00               1602  Nib2Mask    EQU     $0F00
000023FE  =000000F0               1603  Nib1Mask    EQU     $00F0
000023FE  =0000000F               1604  Nib0Mask    EQU     $000F
000023FE                          1605  
000023FE  =00000E00               1606  Bit0Mask    EQU     $0E00
000023FE  =000001C0               1607  Bit1Mask    EQU     $01C0
000023FE  =00000038               1608  Bit2Mask    EQU     $0038
000023FE  =00000007               1609  Bit3Mask    EQU     $0007
000023FE                          1610  
000023FE  =000000FF               1611  Byte0Mask   EQU     $00FF
000023FE  =0000FF00               1612  Byte1Mask   EQU     $FF00
000023FE                          1613  
000023FE                          1614  ****    Instructions    ****
000023FE= 4E 4F 54 2E 42 20 00    1615  _NOT_B  DC.B    'NOT.B ',0
00002405= 4E 4F 54 2E 57 20 00    1616  _NOT_W  DC.B    'NOT.W ',0
0000240C= 4E 4F 54 2E 4C 20 00    1617  _NOT_L  DC.B    'NOT.L ',0
00002413= 4E 4F 50 20 00          1618  _NOP    DC.B    'NOP ',0
00002418= 52 54 53 20 00          1619  _RTS    DC.B    'RTS ',0
0000241D= 4D 4F 56 45 4D 2E ...   1620  _MOVEM_W DC.B   'MOVEM.W ',0
00002426= 4D 4F 56 45 4D 2E ...   1621  _MOVEM_L DC.B   'MOVEM.L ',0
0000242F= 4D 4F 56 45 2E 42 ...   1622  _MOVE_B DC.B    'MOVE.B ',0
00002437= 4D 4F 56 45 2E 4C ...   1623  _MOVE_L DC.B    'MOVE.L ',0
0000243F= 4D 4F 56 45 2E 57 ...   1624  _MOVE_W DC.B    'MOVE.W ',0
00002447= 4D 4F 56 45 41 2E ...   1625  _MOVEA_L DC.B   'MOVEA.L ',0
00002450= 4D 4F 56 45 41 2E ...   1626  _MOVEA_W DC.B   'MOVEA.W ',0
00002459= 4A 53 52 20 00          1627  _JSR    DC.B    'JSR ',0
0000245E= 4C 45 41 20 00          1628  _LEA    DC.B    'LEA ',0
00002463= 41 44 44 51 2E 42 ...   1629  _ADDQ_B DC.B    'ADDQ.B ',0
0000246B= 41 44 44 51 2E 57 ...   1630  _ADDQ_W DC.B    'ADDQ.W ',0
00002473= 41 44 44 51 2E 4C ...   1631  _ADDQ_L DC.B    'ADDQ.L ',0
0000247B= 42 52 41 20 00          1632  _BRA    DC.B    'BRA ',0
00002480= 42 45 51 20 00          1633  _BEQ    DC.B    'BEQ ',0
00002485= 42 47 54 20 00          1634  _BGT    DC.B    'BGT ',0
0000248A= 42 4C 45 20 00          1635  _BLE    DC.B    'BLE ',0
0000248F= 4D 4F 56 45 51 20 00    1636  _MOVEQ  DC.B    'MOVEQ ',0
00002496= 44 49 56 55 20 00       1637  _DIVU   DC.B    'DIVU ',0
0000249C= 4F 52 00                1638  _OR     DC.B    'OR',0
0000249F= 2E 42 20 00             1639  _B   DC.B    '.B ',0
000024A3= 2E 57 20 00             1640  _W   DC.B    '.W ',0
000024A7= 2E 4C 20 00             1641  _L   DC.B    '.L ',0
000024AB= 53 55 42 20 00          1642  _SUB    DC.B    'SUB ',0
000024B0= 4D 55 4C 53 20 00       1643  _MULS   DC.B    'MULS ',0
000024B6= 41 4E 44 20 00          1644  _AND    DC.B    'AND ',0
000024BB= 41 44 44 20 00          1645  _ADD    DC.B    'ADD ',0
000024C0= 41 44 44 41 20 00       1646  _ADDA   DC.B    'ADDA ',0
000024C6= 41 53 4C 20 00          1647  _ASL    DC.B    'ASL ',0
000024CB= 41 53 52 20 00          1648  _ASR    DC.B    'ASR ',0
000024D0= 4C 53 4C 20 00          1649  _LSL    DC.B    'LSL ',0
000024D5= 4C 53 52 20 00          1650  _LSR    DC.B    'LSR ',0
000024DA= 41 53 4C 2E 42 20 00    1651  _ASL_B  DC.B    'ASL.B ',0
000024E1= 41 53 4C 2E 57 20 00    1652  _ASL_W  DC.B    'ASL.W ',0
000024E8= 41 53 4C 2E 4C 20 00    1653  _ASL_L  DC.B    'ASL.L ',0
000024EF= 41 53 52 2E 42 20 00    1654  _ASR_B  DC.B    'ASR.B ',0
000024F6= 41 53 52 2E 57 20 00    1655  _ASR_W  DC.B    'ASR.W ',0
000024FD= 41 53 52 2E 4C 20 00    1656  _ASR_L  DC.B    'ASR.L ',0
00002504= 4C 53 4C 2E 42 20 00    1657  _LSL_B  DC.B    'LSL.B ',0
0000250B= 4C 53 4C 2E 57 20 00    1658  _LSL_W  DC.B    'LSL.W ',0
00002512= 4C 53 4C 2E 4C 20 00    1659  _LSL_L  DC.B    'LSL.L ',0
00002519= 4C 53 52 2E 42 20 00    1660  _LSR_B  DC.B    'LSR.B ',0
00002520= 4C 53 52 2E 57 20 00    1661  _LSR_W  DC.B    'LSR.W ',0
00002527= 4C 53 52 2E 4C 20 00    1662  _LSR_L  DC.B    'LSR.L ',0
0000252E                          1663  
0000252E                          1664  ****    Modes    ****
0000252E= 44 00                   1665  _DR             DC.B   'D',0
00002530= 41 00                   1666  _AR             DC.B   'A',0
00002532= 28 41 00                1667  _IND_AR1        DC.B   '(A',0
00002535= 29 00                   1668  _IND_AR2        DC.B   ')',0
00002537= 28 41 00                1669  _AR_POST1       DC.B   '(A',0
0000253A= 29 2B 00                1670  _AR_POST2       DC.B   ')+',0
0000253D= 2D 28 41 00             1671  _AR_PRE1        DC.B   '-(A',0
00002541= 29 00                   1672  _AR_PRE2        DC.B   ')',0
00002543= 24 00                   1673  _ABS            DC.B    '$',0
00002545= 23 00                   1674  _IMD            DC.B    '#',0
00002547                          1675  
00002547                          1676  ****    Numbers    ****
00002547= 30 00                   1677  _ZERO   DC.B    '0',0
00002549= 31 00                   1678  _ONE    DC.B    '1',0
0000254B= 32 00                   1679  _TWO    DC.B    '2',0
0000254D= 33 00                   1680  _THREE  DC.B    '3',0
0000254F= 34 00                   1681  _FOUR   DC.B    '4',0
00002551= 35 00                   1682  _FIVE   DC.B    '5',0
00002553= 36 00                   1683  _SIX    DC.B    '6',0
00002555= 37 00                   1684  _SEVEN  DC.B    '7',0
00002557= 2C 00                   1685  _COMMA  DC.B    ',',0
00002559                          1686  
00002559                          1687  ****    MODE CMP VALUES    ****
00002559  =00000000               1688  cDR             EQU     $0000
00002559  =00000040               1689  cAR             EQU     $0040
00002559  =00000080               1690  cIND_AR         EQU     $0080
00002559  =000000C0               1691  cAR_POST        EQU     $00C0
00002559  =00000100               1692  cAR_PRE         EQU     $0100
00002559  =000001C0               1693  cABS            EQU     $01C0
00002559                          1694  
00002559                          1695  ****    MESSAGES    ****
00002559                          1696  
00002559= 2A 2A 2A 2A 2A 2A ...   1697  WELCOME     DC.B    '*********************************************',CR,LF
00002588= 2A 20 57 65 6C 63 ...   1698              DC.B    '* Welcome to EASY 68K Disasembler by Nibble *',CR,LF
000025B7= 2A 2A 2A 2A 2A 2A ...   1699              DC.B    '*********************************************',CR,LF,0
000025E7                          1700              
000025E7                          1701  CHOICE_PROMPT:
000025E7= 45 6E 74 65 72 20 ...   1702              DC.B    'Enter a number to make a choice:',CR,LF
00002609= 31 3A 20 44 69 73 ...   1703              DC.B    '1: Dissasemble an Address Range',CR,LF
0000262A= 32 3A 20 45 78 69 ...   1704              DC.B    '2: Exit Program',CR,LF,0
0000263C                          1705         
0000263C= 45 52 52 4F 52 3A ...   1706  INV_CHOICE  DC.B    'ERROR: INVALID selection',CR,LF,0
00002657                          1707  
00002657= 0D 0A 50 72 65 73 ...   1708  ENT_TO_CONT DC.B    CR,LF,'Press enter to continue...',CR,LF,0
00002676                          1709  
00002676= 0D 0A 45 6E 74 65 ...   1710  ST_A_MSG    DC.B    CR,LF,'Enter an address range in hexidecimal to be dissasembled',CR,LF * start address message
000026B2= 56 61 6C 69 64 20 ...   1711              DC.B    'Valid address chars: 0-1 A-F case insensitive',CR,LF  
000026E1= 45 6E 74 65 72 20 ...   1712              DC.B    'Enter start address:',0    
000026F6                          1713              
000026F6= 45 6E 74 65 72 20 ...   1714  E_A_MSG     DC.B    'Enter end address:',0    * end address message
00002709                          1715  
00002709= 0D 0A 45 52 52 4F ...   1716  ADR_LEN_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-8 hexidecimal digits long',CR,LF,0    * address input error message
0000274E                          1717  
0000274E= 0D 0A 45 52 52 4F ...   1718  ADR_ODD_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must be even',CR,LF,0  * odd input address error message
00002784                          1719              
00002784= 0D 0A 45 52 52 4F ...   1720  ADR_S_GT_E  DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must come before end address',CR,LF,0 * start greater than end address error msg
000027CA                          1721  
000027CA= 0D 0A 45 52 52 4F ...   1722  HEX_ERR     DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-1 A-F case insensitive',CR,LF,0
0000280C                          1723  
0000280C= 45 52 52 4F 52 3A ...   1724  EA_ERR_MSG  DC.B    'ERROR: INVALID EFFECTIVE ADDRESS',0      * error message for invalid eas
0000282D                          1725  
0000282D= 44 41 54 41 20 20 ...   1726  DATA_MSG    DC.B    'DATA   $',0
00002836                          1727  
00002836= 43 4F 4E 56 45 52 ...   1728  TEST_MSG    DC.B    'CONVERTED ADDRESS IS: ',0  * test message for printing start and end addresses
0000284D                          1729              
0000284D                          1730              END     INIT        * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDQ_               1454
ADD_IMMEDIATE_TO_BUF  1FF6
ADR_LEN_ERR         2709
ADR_ODD_ERR         274E
ADR_S_GT_E          2784
AN_IM_01            1FDC
AN_IM_02            1FF0
ASL_ASR_MEM         16E6
ASL_ASR_REG         17A8
A_F                 2138
BASE_EA_ERR_CHK     1EF8
BASE_EA_ERR_MODES   1F46
BCC_DISP            1A56
BIT0MASK            E00
BIT1MASK            1C0
BIT2MASK            38
BIT3MASK            7
BYTE                1
BYTE0MASK           FF
BYTE1MASK           FF00
CABS                1C0
CAR                 40
CAR_POST            C0
CAR_PRE             100
CDR                 0
CHK_LFT_NIB         1108
CHK_SEA_DONE        21BE
CHK_ST_E_ADRS       215E
CHOICE_1            2094
CHOICE_2            209C
CHOICE_DNE          20BE
CHOICE_ERR          20A4
CHOICE_PROMPT       25E7
CIND_AR             80
CMP_IM_L            2028
CR                  D
CURRENT_ADDR        2300
DATA_MSG            282D
DECODE_DONE         1174
DEST_AN_IM_INVALID  1FBC
DEST_MODE           23F9
DEST_REG            23FA
DISSASEMBLE         1
DM_EA               1A98
DONE                2116
D_TO_EA             1BA6
EA000               1D6C
EA001               1D84
EA010               1D9C
EA011               1DC0
EA100               1DE4
EA101               1E08
EA110               1E0A
EA111               1E0C
EA111_R1            1E2C
EA111_R4            1E48
EA_ERR              1F76
EA_ERR_FLAG         23FD
EA_ERR_MSG          280C
EA_MODE             1D3C
EA_MODE_DONE        1E56
EA_REG              1E58
EA_TO_A             1C14
EA_TO_D             1B38
END_H               2148
END_OP_CODE_PTR     22FC
ENT_TO_CONT         2657
E_ADDR              22F0
E_A_MSG             26F6
E_LEN               2305
E_LEN_CHK           2190
GET_CHOICE          2072
HC_INT_LP           2076
HEX_ERR             27CA
H_A_DNE             2262
H_A_LOOP            223A
H_A_LOW             2256
H_SHORT             2232
INIT                1000
INPUT_START         1028
INST_SZ             23F8
INV_CHOICE          263C
IN_ADDR_TO_HEX      214E
IN_IM_W             2010
LAST_8              1A84
LEA_EA              19F0
LEN_CHK             2170
LF                  A
LOAD_ADD            1696
LOAD_ADDA           1674
LOAD_ADDQ_B         1472
LOAD_ADDQ_L         14BA
LOAD_ADDQ_W         1496
LOAD_AND            1638
LOAD_ASL_B_REG      183A
LOAD_ASL_L_REG      1876
LOAD_ASL_MEM        1718
LOAD_ASL_W_REG      1858
LOAD_ASR_B_REG      17E0
LOAD_ASR_L_REG      181C
LOAD_ASR_MEM        16FC
LOAD_ASR_W_REG      17FE
LOAD_BEQ            151A
LOAD_BGT            1536
LOAD_BLE            1552
LOAD_BRA            1504
LOAD_DATA_STR_INTO_BUF  20E0
LOAD_DIVU           159A
LOAD_EA_ERR_MSG     1F8C
LOAD_JSR            13F6
LOAD_LEA            13D4
LOAD_LSL_B_REG      1926
LOAD_LSL_L_REG      1962
LOAD_LSL_MEM        1766
LOAD_LSL_W_REG      1944
LOAD_LSR_B_REG      18CC
LOAD_LSR_L_REG      1908
LOAD_LSR_MEM        174A
LOAD_LSR_W_REG      18EA
LOAD_MOVEA_L        11DC
LOAD_MOVEA_W        124C
LOAD_MOVEM_L        1430
LOAD_MOVEM_W        140C
LOAD_MOVEQ          156E
LOAD_MOVE_B         1196
LOAD_MOVE_L         1206
LOAD_MOVE_W         1276
LOAD_MULS           1616
LOAD_NOP            13A8
LOAD_NOT_B          1302
LOAD_NOT_L          1356
LOAD_NOT_W          132C
LOAD_OR             15BC
LOAD_RTS            13BE
LOAD_SUB            15DE
LONG                2
LSL_LSR_MEM         1734
LSL_LSR_REG         1894
MEMORY_SHIFT        16D0
MODE_7_CHK          1FA6
MOVE_EA             1980
NEXT_MEM_LONG_TO_BUF  205A
NEXT_MEM_WORD_TO_BUF  2044
NEXT_WORD           1A7C
NIB0MASK            F
NIB1MASK            F0
NIB2MASK            F00
NIB3MASK            F000
NL_TERM_PNT_RST_BUF  22A0
NOP_RTS_JSR         1380
NOT_                12E4
NO_EA_ERROR         118C
ODD_CHK             21A0
OM000               1CB2
OM001               1CC2
OM010               1CD2
OM011               1CE2
OM100               1CF4
OM101               1D06
OM110               1D18
OM111               1D2A
OPMODE              1C82
OPMODE_EA           1B02
OP_2                11C6
OP_3                1236
OP_4                12A6
OP_6                14DE
OP_8                1584
OP_C                1600
OP_CODES            10AC
OP_D                165A
OP_DONE             1194
OP_E                16B8
OP_ERR              116E
OP_START            10BE
PLEN_ERR            21C4
PODD_ERR            21DA
PRINT_A1            2206
PRINT_STR_BUF       22C8
PS_GT_ERR           21F0
QUIT                10A6
QUIT_PROG           2
REG000              1E88
REG001              1E96
REG010              1EA4
REG011              1EB2
REG100              1EC0
REG101              1ECE
REG110              1EDC
REG111              1EEA
REG_SHIFT           1782
RESET_BUF_PTR       22DE
SET_END_OP_CODE_PTR  2298
SPACE               20
SRC_MODE            23FB
SRC_REG             23FC
START               101A
STR_BUF             2307
ST_ADDR             22E4
ST_A_MSG            2676
ST_DIS              1096
ST_LEN              2304
S_GT_E              21B0
TAB                 9
TERM_PNT_RST_BUF    22B6
TEST_MSG            2836
TO_HEX              211C
TO_HEX_INTERNAL     212A
WAIT_USR_INPUT      20C6
WELCOME             2559
WORD                3
WRITE_ASCII         2268
WRITE_HEX_TO_ASCII  2216
WRITE_NL_A4         2288
WRITE_NULL_A4       227C
WRITE_SPC_A4        2282
WRITE_TAB_A4        2292
W_A_DONE            2276
W_A_LOOP            226C
_0_9                213A
_ABS                2543
_ADD                24BB
_ADDA               24C0
_ADDQ_B             2463
_ADDQ_L             2473
_ADDQ_W             246B
_AND                24B6
_AR                 2530
_AR_POST1           2537
_AR_POST2           253A
_AR_PRE1            253D
_AR_PRE2            2541
_ASL                24C6
_ASL_B              24DA
_ASL_L              24E8
_ASL_W              24E1
_ASR                24CB
_ASR_B              24EF
_ASR_L              24FD
_ASR_W              24F6
_B                  249F
_BEQ                2480
_BGT                2485
_BLE                248A
_BRA                247B
_COMMA              2557
_DIVU               2496
_DR                 252E
_FIVE               2551
_FOUR               254F
_IMD                2545
_IND_AR1            2532
_IND_AR2            2535
_JSR                2459
_L                  24A7
_LEA                245E
_LSL                24D0
_LSL_B              2504
_LSL_L              2512
_LSL_W              250B
_LSR                24D5
_LSR_B              2519
_LSR_L              2527
_LSR_W              2520
_MOVEA_L            2447
_MOVEA_W            2450
_MOVEM_L            2426
_MOVEM_W            241D
_MOVEQ              248F
_MOVE_B             242F
_MOVE_L             2437
_MOVE_W             243F
_MULS               24B0
_NOP                2413
_NOT_B              23FE
_NOT_L              240C
_NOT_W              2405
_ONE                2549
_OR                 249C
_RTS                2418
_SEVEN              2555
_SIX                2553
_SUB                24AB
_THREE              254D
_TWO                254B
_W                  24A3
_ZERO               2547
