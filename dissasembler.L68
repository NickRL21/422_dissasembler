00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 12/4/2019 4:41:23 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :  Dissasembler
00000000                             3  * Written by :  Nick, Shelby, and Zoe
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7          ORG     $1000
00001000                             8          
00001000                             9  ****    MAIN LOOP   ****
00001000  4E71                      10  INIT:   NOP     * line for testing
00001002  4EB9 000021D6             11          JSR     RESET_BUF_PTR
00001008  43F9 00002451             12          LEA     WELCOME,A1      * print welcome message
0000100E  4EB9 00002160             13          JSR     WRITE_ASCII
00001014  4EB9 000021AE             14          JSR     TERM_PNT_RST_BUF
0000101A                            15          
0000101A                            16  START:  
0000101A  4EB9 00001F6A             17          JSR     GET_CHOICE      * get choice from user to dissasemble or quit
00001020  0C46 0002                 18          CMPI    #QUIT_PROG,D6
00001024  6700 0080                 19          BEQ     QUIT
00001028                            20          
00001028                            21  
00001028                            22  INPUT_START:
00001028  43F9 0000256E             23          LEA     ST_A_MSG,A1     * load start address prompt message
0000102E  4EB9 00002160             24          JSR     WRITE_ASCII     * write to string buffer
00001034  4EB9 000021AE             25          JSR     TERM_PNT_RST_BUF * terminate string buffer and print reseting pointer at A4
0000103A                            26          
0000103A  43F9 000021DC             27          LEA     ST_ADDR,A1 * load start address
00001040  4291                      28          CLR.L   (A1)    * clear long at a1
00001042  103C 0002                 29          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001046  4E4F                      30          TRAP    #15
00001048  13C1 000021FC             31          MOVE.B  D1,ST_LEN    * save start length to memory 
0000104E                            32          
0000104E  4EB9 00002046             33          JSR     IN_ADDR_TO_HEX  * convert start address to hex
00001054                            34               
00001054  43F9 000025EE             35          LEA     E_A_MSG,A1      * load end address prompt message
0000105A  4EB9 00002160             36          JSR     WRITE_ASCII     * print message
00001060  4EB9 000021AE             37          JSR     TERM_PNT_RST_BUF  * print and reset buffer no newline
00001066                            38          
00001066  43F9 000021E8             39          LEA     E_ADDR,A1  * load end address
0000106C  4291                      40          CLR.L   (A1)    * clear long at end address
0000106E  103C 0002                 41          MOVE.B  #2,D0   * trap task 2 read a null terminated string from keyboard at A1 length at D1
00001072  4E4F                      42          TRAP    #15
00001074  13C1 000021FD             43          MOVE.B  D1,E_LEN    * save end length to memory
0000107A                            44          
0000107A  4EB9 00002046             45          JSR     IN_ADDR_TO_HEX  * convert end address to hex
00001080                            46          
00001080  4EB9 00002056             47          JSR     CHK_ST_E_ADRS   * check addresses for errors
00001086  0C05 0001                 48          CMPI.B  #1,D5           * if an error occured return to start
0000108A  6600 000A                 49          BNE     ST_DIS          * branch to dissasembly if no errors
0000108E  4EB9 00001FBE             50          JSR     WAIT_USR_INPUT    
00001094  6092                      51          BRA     INPUT_START     * return to start
00001096                            52          
00001096                            53          * print converted addresses for testing purposes
00001096                            54          
00001096  4EB9 000010AC             55  ST_DIS  JSR     OP_CODES
0000109C                            56          
0000109C  4EB9 00002198             57          JSR     NL_TERM_PNT_RST_BUF * print newline after op codes
000010A2                            58           
000010A2  6000 FF76                 59          BRA     START 
000010A6                            60  
000010A6                            61  
000010A6  103C 0009                 62  QUIT    MOVE.B  #9,D0
000010AA  4E4F                      63          TRAP    #15 * stop sim
000010AC                            64  
000010AC                            65  
000010AC                            66  ****    OP-CODES    ****
000010AC                            67  OP_CODES:
000010AC  4EB9 000021D6             68          JSR     RESET_BUF_PTR   * reset string buffer pointer
000010B2  2A79 000021DC             69          MOVE.L  ST_ADDR,A5  * load starting address into a5
000010B8  2C79 000021E8             70          MOVE.L  E_ADDR,A6   * load ending address into a6
000010BE                            71          
000010BE                            72  OP_START:          
000010BE                            73          * write address and a tab to str buffer
000010BE  220D                      74          MOVE.L  A5,D1   * load address from A5 into D1
000010C0  23C1 000021F8             75          MOVE.L  D1,CURRENT_ADDR * save backup of opcode word address
000010C6  7A20                      76          MOVEQ   #32,D5   * set hex length to long for address printing
000010C8  4EB9 0000210E             77          JSR     WRITE_HEX_TO_ASCII
000010CE  4EB9 0000218A             78          JSR     WRITE_TAB_A4
000010D4                            79          
000010D4  3415                      80          MOVE.W (A5),D2 * load word of memory into D1
000010D6                            81  
000010D6                            82          * clear ea mode and register values
000010D6  13FC 0000 000022F4        83          MOVE.B #0,SRC_REG
000010DE  13FC 0000 000022F2        84          MOVE.B #0,DEST_REG
000010E6  13FC 0000 000022F3        85          MOVE.B #0,SRC_MODE
000010EE  13FC 0000 000022F1        86          MOVE.B #0,DEST_MODE
000010F6  23FC 00000000 000021F4    87          MOVE.L  #0,END_OP_CODE_PTR * clear end of op-code str buffer pointer
00001100  13FC 0000 000022F5        88          MOVE.B  #0,EA_ERR_FLAG * clear ea error flag
00001108                            89          
00001108                            90  CHK_LFT_NIB:
00001108  2602                      91          MOVE.L  D2,D3   * copy to d2
0000110A                            92          
0000110A  0243 F000                 93          ANDI.W  #Nib3Mask,D3 * clear all but left four bits
0000110E  0C43 1000                 94          CMPI.W  #$1000,D3   * if nibble3 == 1, branch to move byte (1)
00001112  6700 0082                 95          BEQ     load_MOVE_B
00001116  0C43 2000                 96          CMPI.W  #$2000,D3   * if nibble3 == 2, branch to that set (move.l, movea.l)
0000111A  6700 00AA                 97          BEQ     OP_2
0000111E  0C43 3000                 98          CMPI.W  #$3000,D3   * if nibble3 == 3, branch to that set (move.w, movea.w)
00001122  6700 0112                 99          BEQ     OP_3              
00001126  0C43 4000                100          CMPI.W  #$4000,D3   * if nibble3 == 4 branch to that set (not/nop/rts/jsr/movem/lea)
0000112A  6700 017A                101          BEQ     OP_4 
0000112E  0C43 5000                102          CMPI.W  #$5000,D3   * if nibble3 == 5, branch to ADDQ (5)
00001132  6700 0320                103          BEQ     ADDQ_
00001136  0C43 6000                104          CMPI.W  #$6000,D3   * if nibble3 == 6, branch to that set (bra, bcc)
0000113A  6700 03A2                105          BEQ     OP_6
0000113E  0C43 7000                106          CMPI.W  #$7000,D3   * if nibble3 == 7, branch to MOVEQ
00001142  6700 041E                107          BEQ     load_MOVEQ
00001146  0C43 8000                108          CMPI.W  #$8000,D3   * if nibble3 == 8, branch to that set (divu, or)
0000114A  6700 042C                109          BEQ     OP_8
0000114E  0C43 9000                110          CMPI.W  #$9000,D3   * if nibble3 == 9, branch to SUB
00001152  6700 047E                111          BEQ     load_SUB
00001156  0C43 C000                112          CMPI.W  #$C000,D3   * if nibble3 == C, branch to that set (muls, and)
0000115A  6700 0492                113          BEQ     OP_C
0000115E  0C43 D000                114          CMPI.W  #$D000,D3   * if nibble3 == D, branch to that set (add, adda)
00001162  6700 04D8                115          BEQ     OP_D
00001166  0C43 E000                116          CMPI.W  #$E000,D3   * if nibble3 == E, branch to that set (asl, asr, lsl, lsr)
0000116A  6700 0522                117          BEQ     OP_E
0000116E                           118                         
0000116E  4EB9 00001FD8            119  OP_ERR  JSR     LOAD_DATA_STR_INTO_BUF   
00001174                           120  
00001174                           121  DECODE_DONE:    * print newline then check if op-code loop is done
00001174  4EB9 00002198            122          JSR     NL_TERM_PNT_RST_BUF * write newline then print
0000117A  0C39 00FF 000022F5       123          CMP.B   #-1,EA_ERR_FLAG
00001182  6600 0008                124          BNE     NO_EA_ERROR
00001186  2A79 000021F8            125          MOVEA.L CURRENT_ADDR,A5 * reset curent address if ea error occurred
0000118C                           126   NO_EA_ERROR:
0000118C  548D                     127          ADD.L   #2,A5   * increment current address pointer by 2 bytes 
0000118E  BBCE                     128          CMP.L   A6,A5  * loop if start is less than or equal to end
00001190  6F00 FF2C                129          BLE     OP_START
00001194  4E75                     130  OP_DONE RTS
00001196                           131  
00001196                           132  load_MOVE_B:    * load and print MOVE.B neumonic return to op loop
00001196  43F9 00002327            133          LEA     _MOVE_B,A1
0000119C  4EB9 00002160            134          JSR     WRITE_ASCII
000011A2  4EB9 00002190            135          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011A8  13FC 0001 000022F0       136          MOVE.B  #BYTE,INST_SZ   * save instruction size
000011B0  4243                     137          CLR     D3
000011B2  4EB9 00001956            138          JSR     MOVE_EA
000011B8                           139          **** EA CODE GOES HERE ****
000011B8                           140          * must set unused mode/reg vars to 0
000011B8  4EB9 00001DF0            141          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000011BE  4EB9 00001EB4            142          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000011C4  60AE                     143          BRA     DECODE_DONE
000011C6                           144         
000011C6                           145  OP_2:   * could be MOVE.L or MOVEA.L
000011C6  2602                     146          MOVE.L  D2,D3   * copy instruction word
000011C8  0243 01C0                147          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000011CC  0C43 0040                148          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.L
000011D0  6700 000A                149          BEQ     load_MOVEA_L
000011D4  0C43 0040                150          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.L
000011D8  6600 002C                151          BNE     load_MOVE_L
000011DC                           152          
000011DC                           153  load_MOVEA_L:   * load and print MOVEA.L neumonic return to op loop
000011DC  43F9 0000233F            154          LEA     _MOVEA_L,A1
000011E2  4EB9 00002160            155          JSR     WRITE_ASCII
000011E8  4EB9 00002190            156          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000011EE  13FC 0002 000022F0       157          MOVE.B  #LONG,INST_SZ   * save instruction size
000011F6                           158           **** EA CODE GOES HERE ****
000011F6  4EB9 00001956            159          JSR     MOVE_EA
000011FC                           160          * must set unused mode/reg vars to 0
000011FC  4EB9 00001DF0            161          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001202  6000 FF70                162          BRA     DECODE_DONE
00001206                           163  
00001206                           164  load_MOVE_L:    * load and print MOVE.L neumonic return to op loop
00001206  43F9 0000232F            165          LEA     _MOVE_L,A1
0000120C  4EB9 00002160            166          JSR     WRITE_ASCII
00001212  4EB9 00002190            167          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001218  13FC 0002 000022F0       168          MOVE.B  #LONG,INST_SZ   * save instruction size
00001220  4EB9 00001956            169          JSR     MOVE_EA
00001226  4EB9 00001DF0            170          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000122C  4EB9 00001EB4            171          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001232  6000 FF40                172          BRA     DECODE_DONE
00001236                           173          
00001236                           174  OP_3:   * could be MOVE.W or MOVEA.W
00001236  2602                     175          MOVE.L  D2,D3   * copy instruction word
00001238  0243 01C0                176          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
0000123C  0C43 0040                177          CMPI.W  #$0040,D3        * if bits 8-6 are 001, instruction is MOVEA.W
00001240  6700 000A                178          BEQ     load_MOVEA_W
00001244  0C43 0040                179          CMPI.W  #$0040,D3        * if bits 8-6 are NOT 001, instruction is MOVE.W
00001248  6600 002C                180          BNE     load_MOVE_W
0000124C                           181          
0000124C                           182  load_MOVEA_W:   * load and print MOVEA.W neumonic return to op loop
0000124C  43F9 00002348            183          LEA     _MOVEA_W,A1
00001252  4EB9 00002160            184          JSR     WRITE_ASCII
00001258  4EB9 00002190            185          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000125E  13FC 0003 000022F0       186          MOVE.B  #WORD,INST_SZ   * save instruction size
00001266                           187           **** EA CODE GOES HERE ****
00001266  4EB9 00001956            188          JSR     MOVE_EA
0000126C                           189          * must set unused mode/reg vars to 0
0000126C  4EB9 00001DF0            190          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001272  6000 FF00                191          BRA     DECODE_DONE
00001276                           192  
00001276                           193  load_MOVE_W:    * load and print MOVE.W neumonic return to op loop
00001276  43F9 00002337            194          LEA     _MOVE_W,A1
0000127C  4EB9 00002160            195          JSR     WRITE_ASCII
00001282  4EB9 00002190            196          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001288  13FC 0003 000022F0       197          MOVE.B  #WORD,INST_SZ   * save instruction size
00001290  4EB9 00001956            198          JSR     MOVE_EA
00001296  4EB9 00001DF0            199          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000129C  4EB9 00001EB4            200          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
000012A2  6000 FED0                201          BRA     DECODE_DONE
000012A6                           202  
000012A6                           203  OP_4:   * could be not, nop, rts, jsr, MOVEM.L, lea
000012A6  2602                     204          MOVE.L  D2,D3   * copy instruction word
000012A8  0243 0F00                205          ANDI.W  #Nib2Mask,D3
000012AC  0C43 0600                206          CMPI.W  #$0600,D3   * if nibble 2 is 6, instruction is NOT
000012B0  6700 0032                207          BEQ     NOT_
000012B4                           208  
000012B4  0C43 0E00                209          CMPI.W  #$0E00,D3  * if nibble 2 is E could be nop or rts or jsr
000012B8  6700 00C6                210          BEQ     NOP_RTS_JSR
000012BC                           211          
000012BC                           212          * try for LEA
000012BC  2602                     213          MOVE.L  D2,D3
000012BE  0243 01C0                214          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012C2  0C43 01C0                215          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LEA
000012C6  6700 010C                216          BEQ     load_LEA
000012CA                           217          
000012CA                           218          * try for MOVEM.W or MOVEM.L
000012CA  2602                     219          MOVE.L  D2,D3
000012CC  0243 01C0                220          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 for size
000012D0  0C43 0080                221          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is MOVEM.W
000012D4  6700 0136                222          BEQ     load_MOVEM_W
000012D8  0C43 00C0                223          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is MOVEM.L
000012DC  6700 0152                224          BEQ     load_MOVEM_L
000012E0                           225  
000012E0                           226          
000012E0  6000 FE8C                227          BRA     OP_ERR  * return to error decoding
000012E4                           228          
000012E4                           229  NOT_:   * instruction is not, determine size
000012E4  2602                     230          MOVE.L  D2,D3
000012E6  0243 01C0                231          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000012EA  0C43 0000                232          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is NOT.B
000012EE  6700 0012                233          BEQ     load_NOT_B
000012F2  0C43 0040                234          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is NOT.W
000012F6  6700 0034                235          BEQ     load_NOT_W
000012FA  0C43 0080                236          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is NOT.L
000012FE  6700 0056                237          BEQ     load_NOT_L
00001302                           238           
00001302                           239         
00001302                           240  load_NOT_B:   * load and print NOT.B neumonic return to op loop
00001302  43F9 000022F6            241          LEA     _NOT_B,A1
00001308  4EB9 00002160            242          JSR     WRITE_ASCII
0000130E  4EB9 00002190            243          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001314  13FC 0001 000022F0       244          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000131C                           245           **** EA CODE GOES HERE ****
0000131C                           246          * must set unused mode/reg vars to 0
0000131C  4EB9 00001DF0            247          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001322  4EB9 00001EB4            248          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001328  6000 FE4A                249          BRA     DECODE_DONE
0000132C                           250          
0000132C                           251  load_NOT_W:   * load and print NOT.W neumonic return to op loop
0000132C  43F9 000022FD            252          LEA     _NOT_W,A1
00001332  4EB9 00002160            253          JSR     WRITE_ASCII
00001338  4EB9 00002190            254          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000133E  13FC 0003 000022F0       255          MOVE.B  #WORD,INST_SZ   * save instruction size
00001346                           256           **** EA CODE GOES HERE ****
00001346                           257          * must set unused mode/reg vars to 0
00001346  4EB9 00001DF0            258          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000134C  4EB9 00001EB4            259          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
00001352  6000 FE20                260          BRA     DECODE_DONE
00001356                           261          
00001356                           262  load_NOT_L:   * load and print NOT.L neumonic return to op loop
00001356  43F9 00002304            263          LEA     _NOT_L,A1
0000135C  4EB9 00002160            264          JSR     WRITE_ASCII
00001362  4EB9 00002190            265          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001368  13FC 0002 000022F0       266          MOVE.B  #LONG,INST_SZ   * save instruction size
00001370                           267           **** EA CODE GOES HERE ****
00001370                           268          * must set unused mode/reg vars to 0
00001370  4EB9 00001DF0            269          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001376  4EB9 00001EB4            270          JSR     DEST_AN_IM_INVALID * check specific invalid EAS
0000137C  6000 FDF6                271          BRA     DECODE_DONE
00001380                           272  
00001380                           273  NOP_RTS_JSR: * could be NOP or RTS or JSR
00001380  2602                     274          MOVE.L  D2,D3
00001382  0243 01C0                275          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001386  0C43 0080                276          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is JSR
0000138A  6700 006A                277          BEQ     load_JSR
0000138E                           278      
0000138E  2602                     279          MOVE.L  D2,D3       *copy instruction word
00001390  0243 00FF                280          ANDI.W  #Byte0Mask,D3 * isolate right most byte
00001394                           281          
00001394  0C03 0071                282          CMPI.B  #$71,D3     * test for NOP
00001398  6700 000E                283          BEQ     load_NOP
0000139C  0C03 0075                284          CMPI.B  #$75, D3    * test for RTS
000013A0  6700 001C                285          BEQ     load_RTS
000013A4                           286              
000013A4  6000 FDC8                287          BRA     OP_ERR  * return to error decoding
000013A8                           288  
000013A8                           289  load_NOP:   * load and print NOP neumonic return to op loop
000013A8  43F9 0000230B            290          LEA     _NOP,A1
000013AE  4EB9 00002160            291          JSR     WRITE_ASCII
000013B4  4EB9 00002190            292          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013BA  6000 FDB8                293          BRA     DECODE_DONE
000013BE                           294          
000013BE                           295  load_RTS:   * load and print RTS neumonic return to op loop
000013BE  43F9 00002310            296          LEA     _RTS,A1
000013C4  4EB9 00002160            297          JSR     WRITE_ASCII
000013CA  4EB9 00002190            298          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013D0  6000 FDA2                299          BRA     DECODE_DONE
000013D4                           300          
000013D4                           301  load_LEA:   * load and print LEA neumonic return to op loop
000013D4  43F9 00002356            302          LEA     _LEA,A1
000013DA  4EB9 00002160            303          JSR     WRITE_ASCII
000013E0  4EB9 00002190            304          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000013E6                           305           **** EA CODE GOES HERE ****
000013E6  4EB9 000019C6            306           JSR    LEA_EA
000013EC                           307          * must set unused mode/reg vars to 0
000013EC  4EB9 00001DF0            308          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000013F2  6000 FD80                309          BRA     DECODE_DONE
000013F6                           310          
000013F6                           311  load_JSR:   * load and print JSR neumonic return to op loop
000013F6  43F9 00002351            312          LEA     _JSR,A1
000013FC  4EB9 00002160            313          JSR     WRITE_ASCII
00001402  4EB9 00002190            314          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001408  6000 FD6A                315          BRA     DECODE_DONE
0000140C                           316          
0000140C                           317  load_MOVEM_W:   * load and print MOVEM.W neumonic return to op loop
0000140C  43F9 00002315            318          LEA     _MOVEM_W,A1
00001412  4EB9 00002160            319          JSR     WRITE_ASCII
00001418  4EB9 00002190            320          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000141E  13FC 0003 000022F0       321      MOVE.B  #WORD,INST_SZ   * save instruction size
00001426                           322           **** EA CODE GOES HERE ****
00001426                           323          * must set unused mode/reg vars to 0
00001426  4EB9 00001DF0            324          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000142C  6000 FD46                325          BRA     DECODE_DONE
00001430                           326          
00001430                           327  load_MOVEM_L:   * load and print MOVEM.L neumonic return to op loop
00001430  43F9 0000231E            328          LEA     _MOVEM_L,A1
00001436  4EB9 00002160            329          JSR     WRITE_ASCII
0000143C  4EB9 00002190            330          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001442  13FC 0002 000022F0       331          MOVE.B  #LONG,INST_SZ   * save instruction size
0000144A                           332           **** EA CODE GOES HERE ****
0000144A                           333          * must set unused mode/reg vars to 0
0000144A  4EB9 00001DF0            334          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001450  6000 FD22                335          BRA     DECODE_DONE
00001454                           336  
00001454                           337  ADDQ_:  * instruction is addq, determine size
00001454  2602                     338          MOVE.L  D2,D3
00001456  0243 01C0                339          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
0000145A  0C43 0000                340          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ADDQ.B
0000145E  6700 0012                341          BEQ     load_ADDQ_B
00001462  0C43 0040                342          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ADDQ.W
00001466  6700 002E                343          BEQ     load_ADDQ_W
0000146A  0C43 0080                344          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ADDQ.L
0000146E  6700 004A                345          BEQ     load_ADDQ_L           
00001472                           346  
00001472                           347  load_ADDQ_B:  * load and print ADDQ.B neumonic return to op loop
00001472  43F9 0000235B            348          LEA     _ADDQ_B,A1
00001478  4EB9 00002160            349          JSR     WRITE_ASCII
0000147E  4EB9 00002190            350          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001484  13FC 0001 000022F0       351          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000148C                           352           **** EA CODE GOES HERE ****
0000148C                           353          * must set unused mode/reg vars to 0
0000148C  4EB9 00001DF0            354          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001492  6000 FCE0                355          BRA     DECODE_DONE
00001496                           356        
00001496                           357  load_ADDQ_W:  * load and print ADDQ.W neumonic return to op loop
00001496  43F9 00002363            358          LEA     _ADDQ_W,A1
0000149C  4EB9 00002160            359          JSR     WRITE_ASCII
000014A2  4EB9 00002190            360          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014A8  13FC 0003 000022F0       361          MOVE.B  #WORD,INST_SZ   * save instruction size
000014B0                           362           **** EA CODE GOES HERE ****
000014B0                           363          * must set unused mode/reg vars to 0
000014B0  4EB9 00001DF0            364          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014B6  6000 FCBC                365          BRA     DECODE_DONE
000014BA                           366          
000014BA                           367  load_ADDQ_L:  * load and print ADDQ.L neumonic return to op loop
000014BA  43F9 0000236B            368          LEA     _ADDQ_L,A1
000014C0  4EB9 00002160            369          JSR     WRITE_ASCII
000014C6  4EB9 00002190            370          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000014CC  13FC 0002 000022F0       371          MOVE.B  #LONG,INST_SZ
000014D4                           372           **** EA CODE GOES HERE ****
000014D4                           373          * must set unused mode/reg vars to 0
000014D4  4EB9 00001DF0            374          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000014DA  6000 FC98                375          BRA     DECODE_DONE
000014DE                           376          
000014DE                           377  OP_6:   * could be BRA, BEQ, BGT, BLE
000014DE  2602                     378          MOVE.L  D2,D3   * copy instruction word
000014E0  0243 0F00                379          ANDI.W  #Nib2Mask,D3
000014E4  0C43 0000                380          CMPI.W  #$0000,D3   * if nibble 2 is 0, instruction is BRA
000014E8  6700 001A                381          BEQ     load_BRA
000014EC  0C43 0700                382          CMPI.W  #$0700,D3   * if nibble 2 is 7, instruction is BEQ
000014F0  6700 0028                383          BEQ     load_BEQ
000014F4  0C43 0E00                384          CMPI.W  #$0E00,D3   * if nibble 2 is E, instruction is BGT
000014F8  6700 003C                385          BEQ     load_BGT
000014FC  0C43 0F00                386          CMPI.W  #$0F00,D3   * if nibble 2 is F, instruction is BLE
00001500  6700 004A                387          BEQ     load_BLE
00001504                           388          
00001504                           389  load_BRA:   * load and print BRA neumonic return to op loop
00001504  43F9 00002373            390          LEA     _BRA,A1
0000150A  4EB9 00002160            391          JSR     WRITE_ASCII
00001510  4EB9 00002190            392          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001516  6000 FC5C                393          BRA     DECODE_DONE
0000151A                           394          
0000151A                           395  load_BEQ:   * load and print BEQ neumonic return to op loop
0000151A  43F9 00002378            396          LEA     _BEQ,A1
00001520  4EB9 00002160            397          JSR     WRITE_ASCII
00001526  4EB9 00001F3C            398          JSR     NEXT_MEM_WORD_TO_BUF
0000152C  4EB9 00002190            399          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001532  6000 FC40                400          BRA     DECODE_DONE
00001536                           401  
00001536                           402  load_BGT:   * load and print BGT neumonic return to op loop
00001536  43F9 0000237D            403          LEA     _BGT,A1
0000153C  4EB9 00002160            404          JSR     WRITE_ASCII
00001542  4EB9 00002190            405          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001548  6000 FC2A                406          BRA     DECODE_DONE
0000154C                           407          
0000154C                           408  load_BLE:   * load and print BLE neumonic return to op loop
0000154C  43F9 00002382            409          LEA     _BLE,A1
00001552  4EB9 00002160            410          JSR     WRITE_ASCII
00001558  4EB9 00002190            411          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000155E  6000 FC14                412          BRA     DECODE_DONE
00001562                           413          
00001562                           414  load_MOVEQ: * load and print MOVEQ neumonic return to op loop
00001562  43F9 00002387            415          LEA     _MOVEQ,A1
00001568  4EB9 00002160            416          JSR     WRITE_ASCII
0000156E  4EB9 00002190            417          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001574  6000 FBFE                418          BRA     DECODE_DONE
00001578                           419          
00001578                           420  OP_8:       * could be DIVU or OR
00001578  2602                     421          MOVE.L  D2,D3       * copy instruction word
0000157A  0243 01C0                422          ANDI.W  #Bit1Mask,D3   * mask, isolate distinguishing bits 8-6
0000157E  0C43 00C0                423          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is DIVU
00001582  6700 000A                424          BEQ     load_DIVU
00001586  0C43 00C0                425          CMPI.W  #$00C0,D3       * if bits 8-6 are NOT 011, instruction is OR
0000158A  6600 0024                426          BNE     load_OR
0000158E                           427  
0000158E                           428  load_DIVU:  * load and print DIVU neumonic return to op loop
0000158E  43F9 0000238E            429          LEA     _DIVU,A1
00001594  4EB9 00002160            430          JSR     WRITE_ASCII
0000159A  4EB9 00002190            431          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015A0                           432           **** EA CODE GOES HERE ****
000015A0  4EB9 00001A2C            433          JSR     DIVU_EA
000015A6                           434          * must set unused mode/reg vars to 0
000015A6  4EB9 00001DF0            435          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015AC  6000 FBC6                436          BRA     DECODE_DONE
000015B0                           437          
000015B0                           438  load_OR:    * load and print DIVU neuomnic return to op loop
000015B0  43F9 00002394            439          LEA     _OR,A1
000015B6  4EB9 00002160            440          JSR     WRITE_ASCII
000015BC  4EB9 00002190            441          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015C2                           442           **** EA CODE GOES HERE ****
000015C2  4EB9 00001A96            443          JSR     OR_EA
000015C8                           444          * must set unused mode/reg vars to 0
000015C8  4EB9 00001DF0            445          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015CE  6000 FBA4                446          BRA     DECODE_DONE
000015D2                           447  
000015D2                           448  load_SUB:   * load and print SUB neumonic return to op loop
000015D2  43F9 000023A3            449          LEA     _SUB,A1
000015D8  4EB9 00002160            450          JSR     WRITE_ASCII
000015DE  4EB9 00002190            451          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000015E4                           452           **** EA CODE GOES HERE ****
000015E4                           453          * must set unused mode/reg vars to 0
000015E4  4EB9 00001DF0            454          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000015EA  6000 FB88                455          BRA     DECODE_DONE
000015EE                           456  
000015EE                           457  OP_C:       * could be MULS or AND
000015EE  2602                     458          MOVE.L  D2,D3       * copy instruction word
000015F0  0243 01C0                459          ANDI.W  #Bit1Mask,D3    * mask, isolate distinguishing bits 8-6
000015F4  0C43 01C0                460          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is MULS
000015F8  6700 000A                461          BEQ     load_MULS
000015FC  0C43 01C0                462          CMPI.W  #$01C0,D3       * if bits 8-6 are NOT 111, instruction is AND
00001600  6600 001E                463          BNE     load_AND
00001604                           464          
00001604                           465  load_MULS:  * load and print MULS neumonic return to op loop
00001604  43F9 000023A8            466          LEA     _MULS,A1
0000160A  4EB9 00002160            467          JSR     WRITE_ASCII
00001610  4EB9 00002190            468          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001616                           469           **** EA CODE GOES HERE ****
00001616                           470          * must set unused mode/reg vars to 0
00001616  4EB9 00001DF0            471          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000161C  6000 FB56                472          BRA     DECODE_DONE
00001620                           473          
00001620                           474  load_AND:   * load and print AND neumonic return to op loop
00001620  43F9 000023AE            475          LEA     _AND,A1
00001626  4EB9 00002160            476          JSR     WRITE_ASCII
0000162C  4EB9 00002190            477          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001632                           478           **** EA CODE GOES HERE ****
00001632                           479          * must set unused mode/reg vars to 0
00001632  4EB9 00001DF0            480          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001638  6000 FB3A                481          BRA     DECODE_DONE
0000163C                           482  
0000163C                           483  OP_D:       * could be ADD or ADDA
0000163C  2602                     484          MOVE.L  D2,D3       * copy instruction word
0000163E  0243 01C0                485          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6 (opmode but distinguishes instr.)
00001642  0C43 00C0                486          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ADDA
00001646  6700 000E                487          BEQ     load_ADDA
0000164A  0C43 01C0                488          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is also ADDA
0000164E  6700 0006                489          BEQ     load_ADDA
00001652  6600 001E                490          BNE     load_ADD        * if bits 8-6 are not either, instruction is ADD
00001656                           491          
00001656                           492  load_ADDA:  * load and print ADDA neumonic return to op loop
00001656  43F9 000023B8            493          LEA     _ADDA,A1
0000165C  4EB9 00002160            494          JSR     WRITE_ASCII
00001662  4EB9 00002190            495          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001668                           496           **** EA CODE GOES HERE ****
00001668                           497          * must set unused mode/reg vars to 0
00001668  4EB9 00001DF0            498          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000166E  6000 FB04                499          BRA     DECODE_DONE
00001672                           500  
00001672                           501  load_ADD:   * load and print ADD neumonic return to op loop
00001672  43F9 000023B3            502          LEA     _ADD,A1
00001678  4EB9 00002160            503          JSR     WRITE_ASCII
0000167E  4EB9 00002190            504          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001684                           505           **** EA CODE GOES HERE ****
00001684                           506          * must set unused mode/reg vars to 0
00001684  4EB9 00001DF0            507          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
0000168A  6000 FAE8                508          BRA     DECODE_DONE
0000168E                           509  
0000168E                           510  OP_E:       * could be ASL, ASR, LSL, LSR (memory or register)
0000168E  2602                     511          MOVE.L  D2,D3       * copy instruction word
00001690  0283 FFFF00FF            512          ANDI.L  #$FFFF00FF,D3   * mask, isolate bits 7-6
00001696  0C43 00C0                513          CMPI.W  #$00C0,D3       * if bits 7-6 are 11, instruction is MEMORY shift
0000169A  6700 000A                514          BEQ     MEMORY_shift
0000169E  0C43 00C0                515          CMPI.W  #$00C0,D3       * if bits 7-6 are NOT 11, instruction is REG shift
000016A2  6600 00B4                516          BNE     REG_shift
000016A6                           517          
000016A6                           518  MEMORY_shift:   * could be ASL, ASR, LSL, LSR (memory)
000016A6  2602                     519          MOVE.L  D2,D3       * copy instruction word
000016A8  0243 0E00                520          ANDI.W  #Bit0Mask,D3    * mask, isolate bits 11-9
000016AC  0C43 0000                521          CMPI.W  #$0000,D3       * if bits 11-9 are 000, instruction is ASL or ASR (memory)
000016B0  6700 000A                522          BEQ     ASL_ASR_MEM
000016B4  0C43 0200                523          CMPI.W  #$0200,D3       * if bits 11-9 are 001, instruction is LSL or LSR (memory)
000016B8  6700 0050                524          BEQ     LSL_LSR_MEM
000016BC                           525          
000016BC                           526  ASL_ASR_MEM:    * could be ASL or ASR (memory)
000016BC  2602                     527          MOVE.L  D2,D3       * copy instruction word
000016BE  0243 01C0                528          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
000016C2  0C43 00C0                529          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is ASR memory
000016C6  6700 000A                530          BEQ     load_ASR_MEM
000016CA  0C43 01C0                531          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is ASL memory
000016CE  6700 001E                532          BEQ     load_ASL_MEM
000016D2                           533          
000016D2                           534  load_ASR_MEM:   * load and print ASR neumonic return to op loop
000016D2  43F9 000023C3            535          LEA     _ASR,A1
000016D8  4EB9 00002160            536          JSR     WRITE_ASCII
000016DE  4EB9 00002190            537          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000016E4                           538           **** EA CODE GOES HERE ****
000016E4                           539          * must set unused mode/reg vars to 0
000016E4  4EB9 00001DF0            540          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
000016EA  6000 FA88                541          BRA     DECODE_DONE
000016EE                           542          
000016EE                           543  load_ASL_MEM:   * load and print ASL neumonic return to op loop
000016EE  43F9 000023BE            544          LEA     _ASL,A1
000016F4  4EB9 00002160            545          JSR     WRITE_ASCII
000016FA  4EB9 00002190            546          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001700                           547           **** EA CODE GOES HERE ****
00001700                           548          * must set unused mode/reg vars to 0
00001700  4EB9 00001DF0            549          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001706  6000 FA6C                550          BRA     DECODE_DONE
0000170A                           551  
0000170A                           552  LSL_LSR_MEM:    * could be LSL or LSR (memory)
0000170A  2602                     553          MOVE.L  D2,D3       * copy instruction word
0000170C  0243 01C0                554          ANDI.W  #Bit1Mask,D3    * mask, isolate bits 8-6
00001710  0C43 00C0                555          CMPI.W  #$00C0,D3       * if bits 8-6 are 011, instruction is LSR memory
00001714  6700 000A                556          BEQ     load_LSR_MEM
00001718  0C43 01C0                557          CMPI.W  #$01C0,D3       * if bits 8-6 are 111, instruction is LSL memory
0000171C  6700 001E                558          BEQ     load_LSL_MEM 
00001720                           559          
00001720                           560  load_LSR_MEM:   * load and print LSR neumonic return to op loop
00001720  43F9 000023CD            561          LEA     _LSR,A1
00001726  4EB9 00002160            562          JSR     WRITE_ASCII
0000172C  4EB9 00002190            563          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001732                           564           **** EA CODE GOES HERE ****
00001732                           565          * must set unused mode/reg vars to 0
00001732  4EB9 00001DF0            566          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001738  6000 FA3A                567          BRA     DECODE_DONE
0000173C                           568          
0000173C                           569  load_LSL_MEM:   * load and print LSL neumonic return to op loop
0000173C  43F9 000023C8            570          LEA     _LSL,A1
00001742  4EB9 00002160            571          JSR     WRITE_ASCII
00001748  4EB9 00002190            572          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000174E                           573           **** EA CODE GOES HERE ****
0000174E                           574          * must set unused mode/reg vars to 0
0000174E  4EB9 00001DF0            575          JSR     BASE_EA_ERR_CHK * check globaly invalid eas
00001754  6000 FA1E                576          BRA     DECODE_DONE
00001758                           577  
00001758                           578  REG_shift:      * could be ASL, ASR, LSL, LSR (register)
00001758  2602                     579          MOVE.L  D2,D3       * copy instruction word
0000175A  0243 0038                580          ANDI.W  #Bit2Mask,D3    * mask, isolate bits 5-3
0000175E  0C43 0000                581          CMPI.W  #$0000,D3        * if bits 5-3 are 000, instruction is ASL or ASR (reg)
00001762  6700 001A                582          BEQ     ASL_ASR_REG
00001766  0C43 0020                583          CMPI.W  #$0020,D3       * if bits 5-3 are 100, instruction is ASL or ASR (reg)
0000176A  6700 0012                584          BEQ     ASL_ASR_REG
0000176E  0C43 0008                585          CMPI.W  #$0008,D3       * if bits 5-3 are 001, instruction is LSL or LSR (reg)
00001772  6700 00F6                586          BEQ     LSL_LSR_REG
00001776  0C43 0028                587          CMPI.W  #$0028,D3       * if bits 5-3 are 101, instruction is LSL or LSR (reg)
0000177A  6700 00EE                588          BEQ     LSL_LSR_REG
0000177E                           589          
0000177E                           590  ASL_ASR_REG:    * could be ASL or ASR (register)
0000177E  2602                     591          MOVE.L  D2,D3       * copy instruction word
00001780  0283 000001C0            592          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
00001786                           593          
00001786  0C43 0000                594          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is ASR.B register
0000178A  6700 002A                595          BEQ     load_ASR_B_REG
0000178E  0C43 0040                596          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is ASR.W register
00001792  6700 0040                597          BEQ     load_ASR_W_REG
00001796  0C43 0080                598          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is ASR.L register
0000179A  6700 0056                599          BEQ     load_ASR_L_REG
0000179E                           600          
0000179E  0C43 0100                601          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is ASL.B register
000017A2  6700 006C                602          BEQ     load_ASL_B_REG
000017A6  0C43 0140                603          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is ASL.W register
000017AA  6700 0082                604          BEQ     load_ASL_W_REG
000017AE  0C43 0180                605          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is ASL.L register
000017B2  6700 0098                606          BEQ     load_ASL_L_REG
000017B6                           607  
000017B6                           608  load_ASR_B_REG:   * load and print ASR.B neumonic return to op loop
000017B6  43F9 000023E7            609          LEA     _ASR_B,A1
000017BC  4EB9 00002160            610          JSR     WRITE_ASCII
000017C2  4EB9 00002190            611          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000017C8  13FC 0001 000022F0       612          MOVE.B  #BYTE,INST_SZ   * save instruction size
000017D0  6000 F9A2                613          BRA     DECODE_DONE
000017D4                           614          
000017D4                           615  load_ASR_W_REG:   * load and print ASR.W neumonic return to op loop
000017D4  43F9 000023EE            616          LEA     _ASR_W,A1
000017DA  4EB9 00002160            617          JSR     WRITE_ASCII
000017E0  4EB9 00002190            618          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000017E6  13FC 0003 000022F0       619          MOVE.B  #WORD,INST_SZ   * save instruction size
000017EE  6000 F984                620          BRA     DECODE_DONE
000017F2                           621          
000017F2                           622  load_ASR_L_REG:   * load and print ASR.L neumonic return to op loop
000017F2  43F9 000023F5            623          LEA     _ASR_L,A1
000017F8  4EB9 00002160            624          JSR     WRITE_ASCII
000017FE  4EB9 00002190            625          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001804  13FC 0002 000022F0       626          MOVE.B  #LONG,INST_SZ   * save instruction size
0000180C  6000 F966                627          BRA     DECODE_DONE
00001810                           628          
00001810                           629  load_ASL_B_REG:   * load and print ASL.B neumonic return to op loop
00001810  43F9 000023D2            630          LEA     _ASL_B,A1
00001816  4EB9 00002160            631          JSR     WRITE_ASCII
0000181C  4EB9 00002190            632          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001822  13FC 0001 000022F0       633          MOVE.B  #BYTE,INST_SZ   * save instruction size
0000182A  6000 F948                634          BRA     DECODE_DONE
0000182E                           635          
0000182E                           636  load_ASL_W_REG:   * load and print ASL.W neumonic return to op loop
0000182E  43F9 000023D9            637          LEA     _ASL_W,A1
00001834  4EB9 00002160            638          JSR     WRITE_ASCII
0000183A  4EB9 00002190            639          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
00001840  13FC 0003 000022F0       640          MOVE.B  #WORD,INST_SZ   * save instruction size
00001848  6000 F92A                641          BRA     DECODE_DONE
0000184C                           642          
0000184C                           643  load_ASL_L_REG:   * load and print ASL.L neumonic return to op loop
0000184C  43F9 000023E0            644          LEA     _ASL_L,A1
00001852  4EB9 00002160            645          JSR     WRITE_ASCII
00001858  4EB9 00002190            646          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000185E  13FC 0002 000022F0       647          MOVE.B  #LONG,INST_SZ   * save instruction size
00001866  6000 F90C                648          BRA     DECODE_DONE
0000186A                           649  
0000186A                           650  LSL_LSR_REG:    * could be LSL or LSR (register)
0000186A  2602                     651          MOVE.L  D2,D3       * copy instruction word
0000186C  0283 000001C0            652          ANDI.L  #Bit1Mask,D3    * mask, isolate bits 8-6
00001872                           653          
00001872  0C43 0000                654          CMPI.W  #$0000,D3       * if bits 8-6 are 000, instruction is LSR.B register
00001876  6700 002A                655          BEQ     load_LSR_B_REG
0000187A  0C43 0040                656          CMPI.W  #$0040,D3       * if bits 8-6 are 001, instruction is LSR.W register
0000187E  6700 0040                657          BEQ     load_LSR_W_REG
00001882  0C43 0080                658          CMPI.W  #$0080,D3       * if bits 8-6 are 010, instruction is LSR.L register
00001886  6700 0056                659          BEQ     load_LSR_L_REG
0000188A                           660          
0000188A  0C43 0100                661          CMPI.W  #$0100,D3       * if bits 8-6 are 100, instruction is LSL.B register
0000188E  6700 006C                662          BEQ     load_LSL_B_REG
00001892  0C43 0140                663          CMPI.W  #$0140,D3       * if bits 8-6 are 101, instruction is LSL.W register
00001896  6700 0082                664          BEQ     load_LSL_W_REG
0000189A  0C43 0180                665          CMPI.W  #$0180,D3       * if bits 8-6 are 110, instruction is LSL.L register
0000189E  6700 0098                666          BEQ     load_LSL_L_REG
000018A2                           667  
000018A2                           668  load_LSR_B_REG:   * load and print LSR.B neumonic return to op loop
000018A2  43F9 00002411            669          LEA     _LSR_B,A1
000018A8  4EB9 00002160            670          JSR     WRITE_ASCII
000018AE  4EB9 00002190            671          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018B4  13FC 0001 000022F0       672          MOVE.B  #BYTE,INST_SZ   * save instruction size
000018BC  6000 F8B6                673          BRA     DECODE_DONE
000018C0                           674          
000018C0                           675  load_LSR_W_REG:   * load and print LSR.W neumonic return to op loop
000018C0  43F9 00002418            676          LEA     _LSR_W,A1
000018C6  4EB9 00002160            677          JSR     WRITE_ASCII
000018CC  4EB9 00002190            678          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018D2  13FC 0003 000022F0       679          MOVE.B  #WORD,INST_SZ   * save instruction size
000018DA  6000 F898                680          BRA     DECODE_DONE
000018DE                           681          
000018DE                           682  load_LSR_L_REG:   * load and print LSR.L neumonic return to op loop
000018DE  43F9 0000241F            683          LEA     _LSR_L,A1
000018E4  4EB9 00002160            684          JSR     WRITE_ASCII
000018EA  4EB9 00002190            685          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
000018F0  13FC 0002 000022F0       686          MOVE.B  #LONG,INST_SZ   * save instruction size
000018F8  6000 F87A                687          BRA     DECODE_DONE
000018FC                           688          
000018FC                           689  load_LSL_B_REG:   * load and print LSL.B neumonic return to op loop
000018FC  43F9 000023FC            690          LEA     _LSL_B,A1
00001902  4EB9 00002160            691          JSR     WRITE_ASCII
00001908  4EB9 00002190            692          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000190E  13FC 0001 000022F0       693          MOVE.B  #BYTE,INST_SZ   * save instruction size
00001916  6000 F85C                694          BRA     DECODE_DONE
0000191A                           695          
0000191A                           696  load_LSL_W_REG:   * load and print LSL.W neumonic return to op loop
0000191A  43F9 00002403            697          LEA     _LSL_W,A1
00001920  4EB9 00002160            698          JSR     WRITE_ASCII
00001926  4EB9 00002190            699          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000192C  13FC 0003 000022F0       700          MOVE.B  #WORD,INST_SZ   * save instruction size
00001934  6000 F83E                701          BRA     DECODE_DONE
00001938                           702          
00001938                           703  load_LSL_L_REG:   * load and print LSL.L neumonic return to op loop
00001938  43F9 0000240A            704          LEA     _LSL_L,A1
0000193E  4EB9 00002160            705          JSR     WRITE_ASCII
00001944  4EB9 00002190            706          JSR     SET_END_OP_CODE_PTR     * note mem location following op-code neumonic
0000194A  13FC 0002 000022F0       707          MOVE.B  #LONG,INST_SZ   * save instruction size
00001952  6000 F820                708          BRA     DECODE_DONE
00001956                           709  
00001956                           710  ****       EA       ****
00001956                           711  
00001956                           712  **** MOVE_EA FIRST EA COMMAND *********
00001956                           713  MOVE_EA:
00001956  2602                     714          MOVE.L  D2,D3           *copy instruction to D3 for register
00001958  2802                     715          MOVE.L  D2,D4           *copy instruction to D4 for mode
0000195A  0244 0038                716          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
0000195E  0243 0007                717          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001962  E68C                     718          LSR.L   #3,D4
00001964  13C4 000022F3            719          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
0000196A  13C3 000022F4            720          MOVE.B  D3,SRC_REG      * save source register to memory
00001970  C8FC 0006                721          MULU    #6,D4
00001974  C6FC 0006                722          MULU    #6,D3
00001978  43F9 00001C34            723          LEA     EA_MODE,A1
0000197E  4EB1 4000                724          JSR     (A1,D4)
00001982  43F9 0000244F            725          LEA     _COMMA,A1
00001988  4EB9 00002160            726          JSR     WRITE_ASCII
0000198E                           727  
0000198E  4243                     728          CLR     D3
00001990  4244                     729          CLR     D4 
00001992                           730  ******* MOVE_EA SECOND EA COMMAND **********
00001992  2602                     731          MOVE.L  D2,D3           *copy instruction to D3 for register
00001994  2802                     732          MOVE.L  D2,D4           *copy instruction to D4 for modE
00001996  0243 0E00                733          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
0000199A  0244 01C0                734          ANDI.W  #Bit1Mask,D4    *mask to isolate 3-bit mode
0000199E  1A3C 0009                735          MOVE.B  #9, D5
000019A2  EA6B                     736          LSR     D5,D3 
000019A4  EC8C                     737          LSR.L   #6,D4
000019A6  13C4 000022F1            738          MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
000019AC  13C3 000022F2            739          MOVE.B  D3,DEST_REG      * save destination register to memory 
000019B2  C8FC 0006                740          MULU   #6,D4
000019B6  C6FC 0006                741          MULU   #6,D3
000019BA                           742         
000019BA  43F9 00001C34            743          LEA     EA_MODE,A1 
000019C0  4EB1 4000                744          JSR     (A1,D4)
000019C4  4E75                     745          RTS
000019C6                           746  
000019C6                           747  ********** LEA_EA ***********
000019C6                           748  LEA_EA:
000019C6  2602                     749          MOVE.L  D2,D3 
000019C8  2802                     750          MOVE.L  D2,D4
000019CA  0244 0038                751          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
000019CE  0243 0007                752          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
000019D2  E68C                     753          LSR.L   #3,D4
000019D4  13C4 000022F3            754          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
000019DA  13C3 000022F4            755          MOVE.B  D3,SRC_REG      * save source register to memory
000019E0  C8FC 0006                756          MULU    #6,D4
000019E4  C6FC 0006                757          MULU    #6,D3
000019E8                           758  
000019E8  43F9 00001C34            759          LEA     EA_MODE,A1
000019EE  4EB1 4000                760          JSR     (A1,D4)
000019F2  43F9 0000244F            761          LEA     _COMMA,A1
000019F8  4EB9 00002160            762          JSR     WRITE_ASCII
000019FE                           763  
000019FE  4243                     764          CLR     D3
00001A00  4244                     765          CLR     D4 
00001A02                           766  
00001A02                           767  
00001A02  2602                     768          MOVE.L  D2,D3 
00001A04  0243 0E00                769          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001A08  1A3C 0009                770          MOVE.B  #9, D5
00001A0C  EA6B                     771          LSR     D5,D3 
00001A0E  13C3 000022F2            772          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001A14  C6FC 0006                773          MULU   #6,D3
00001A18  383C 0001                774          MOVE.W  #$0001,D4       *set mode to address register
00001A1C  C8FC 0006                775          MULU    #6,D4
00001A20                           776  
00001A20                           777  
00001A20  43F9 00001C34            778          LEA     EA_MODE,A1 
00001A26  4EB1 4000                779          JSR     (A1,D4)
00001A2A  4E75                     780          RTS
00001A2C                           781  
00001A2C                           782  ********* DIVU_EA ************
00001A2C                           783  DIVU_EA:
00001A2C  2602                     784          MOVE.L  D2,D3 
00001A2E  2802                     785          MOVE.L  D2,D4
00001A30  0244 0038                786          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001A34  0243 0007                787          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001A38  E68C                     788          LSR.L   #3,D4
00001A3A  13C4 000022F3            789          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001A40  13C3 000022F4            790          MOVE.B  D3,SRC_REG      * save source register to memory
00001A46  C8FC 0006                791          MULU    #6,D4
00001A4A  C6FC 0006                792          MULU    #6,D3
00001A4E                           793  
00001A4E  43F9 00001C34            794          LEA     EA_MODE,A1
00001A54  4EB1 4000                795          JSR     (A1,D4)
00001A58  43F9 0000244F            796          LEA     _COMMA,A1
00001A5E  4EB9 00002160            797          JSR     WRITE_ASCII
00001A64                           798  
00001A64  4243                     799          CLR     D3
00001A66  4244                     800          CLR     D4 
00001A68                           801  
00001A68  2602                     802          MOVE.L  D2,D3 
00001A6A  0243 0E00                803          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001A6E  1A3C 0009                804          MOVE.B  #9, D5
00001A72  EA6B                     805          LSR     D5,D3 
00001A74  13C3 000022F2            806          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001A7A  C6FC 0006                807          MULU   #6,D3
00001A7E  43F9 00002426            808          LEA     _DR,A1 
00001A84  4EB9 00002160            809          JSR WRITE_ASCII
00001A8A                           810  
00001A8A                           811  
00001A8A  43F9 00001D50            812          LEA     EA_REG,A1 
00001A90  4EB1 3000                813          JSR     (A1,D3)
00001A94  4E75                     814          RTS 
00001A96                           815  
00001A96                           816  ****** 0R_EA ************
00001A96                           817  OR_EA:
00001A96  2802                     818          MOVE.L  D2,D4
00001A98  0244 01C0                819          ANDI.W  #Bit1Mask,D4            *FIND OPMODE
00001A9C  EC8C                     820          LSR.L   #6,D4
00001A9E                           821          * MOVE.B  D4,DEST_MODE     * save destination ea mode to memory
00001A9E  C8FC 0006                822          MULU    #6,D4 
00001AA2                           823  
00001AA2  43F9 00001B9A            824          LEA     OPMODE,A1               *LOAD OPMODE TABLE
00001AA8  4EB1 4000                825          JSR     (A1,D4)                 *JMP TO OPMODE TABLE
00001AAC                           826  
00001AAC                           827  
00001AAC  BA3C 0001                828          CMP.B   #%1,D5                  *if flag == 1, <ea> V Dn - Dn
00001AB0  6700 007A                829          BEQ     D_TO_EA
00001AB4  BA3C 0001                830          CMP.B   #%1,D5                  *else, Dn V <ea> - <ea>
00001AB8  6600 0004                831          BNE     EA_TO_D
00001ABC  4E75                     832          RTS
00001ABE                           833  EA_TO_D:
00001ABE  4243                     834          CLR     D3
00001AC0  4244                     835          CLR     D4
00001AC2                           836  
00001AC2  2602                     837          MOVE.L  D2,D3 
00001AC4  2802                     838          MOVE.L  D2,D4
00001AC6  0244 0038                839          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001ACA  0243 0007                840          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001ACE  E68C                     841          LSR.L   #3,D4
00001AD0  13C4 000022F3            842          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001AD6  13C3 000022F4            843          MOVE.B  D3,SRC_REG      * save source register to memory
00001ADC  C8FC 0006                844          MULU    #6,D4
00001AE0  C6FC 0006                845          MULU    #6,D3
00001AE4                           846  
00001AE4  43F9 00001C34            847          LEA     EA_MODE,A1
00001AEA  4EB1 4000                848          JSR     (A1,D4)
00001AEE  43F9 0000244F            849          LEA     _COMMA,A1
00001AF4  4EB9 00002160            850          JSR     WRITE_ASCII
00001AFA                           851  
00001AFA  4243                     852          CLR     D3
00001AFC  4244                     853          CLR     D4 
00001AFE                           854  
00001AFE  2602                     855          MOVE.L  D2,D3 
00001B00  0243 0E00                856          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001B04  1A3C 0009                857          MOVE.B  #9, D5
00001B08  EA6B                     858          LSR     D5,D3 
00001B0A  13C3 000022F2            859          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001B10  C6FC 0006                860          MULU   #6,D3
00001B14  43F9 00002426            861          LEA     _DR,A1 
00001B1A  4EB9 00002160            862          JSR WRITE_ASCII
00001B20                           863  
00001B20                           864  
00001B20  43F9 00001D50            865          LEA     EA_REG,A1 
00001B26  4EB1 3000                866          JSR     (A1,D3)
00001B2A  4E75                     867          RTS
00001B2C                           868  
00001B2C                           869  D_TO_EA:
00001B2C                           870  
00001B2C  4243                     871          CLR     D3
00001B2E  4244                     872          CLR     D4 
00001B30                           873  
00001B30  2602                     874          MOVE.L  D2,D3 
00001B32  0243 0E00                875          ANDI.W  #Bit0Mask,D3    *mask to isolate 3-bit register code
00001B36  1A3C 0009                876          MOVE.B  #9, D5
00001B3A  EA6B                     877          LSR     D5,D3 
00001B3C  13C3 000022F2            878          MOVE.B  D3,DEST_REG      * save destination register to memory 
00001B42  C6FC 0006                879          MULU   #6,D3
00001B46  43F9 00002426            880          LEA     _DR,A1 
00001B4C  4EB9 00002160            881          JSR WRITE_ASCII
00001B52                           882  
00001B52                           883  
00001B52  43F9 00001D50            884          LEA     EA_REG,A1 
00001B58  4EB1 3000                885          JSR     (A1,D3)
00001B5C  43F9 0000244F            886          LEA     _COMMA,A1
00001B62  4EB9 00002160            887          JSR     WRITE_ASCII
00001B68                           888  
00001B68  4243                     889          CLR     D3
00001B6A  4244                     890          CLR     D4
00001B6C                           891  
00001B6C  2602                     892          MOVE.L  D2,D3 
00001B6E  2802                     893          MOVE.L  D2,D4
00001B70  0244 0038                894          ANDI.W  #Bit2Mask,D4    *mask to isolate 3-bit source mode
00001B74  0243 0007                895          ANDI.W  #Bit3Mask,D3    *mask to isolate 3-bit source register 
00001B78  E68C                     896          LSR.L   #3,D4
00001B7A  13C4 000022F3            897          MOVE.B  D4,SRC_MODE     * save source ea mode to memory
00001B80  13C3 000022F4            898          MOVE.B  D3,SRC_REG      * save source register to memory
00001B86  C8FC 0006                899          MULU    #6,D4
00001B8A  C6FC 0006                900          MULU    #6,D3
00001B8E                           901  
00001B8E  43F9 00001C34            902          LEA     EA_MODE,A1
00001B94  4EB1 4000                903          JSR     (A1,D4)
00001B98  4E75                     904          RTS
00001B9A                           905  
00001B9A                           906  ******* OPMODE **********
00001B9A                           907  OPMODE:
00001B9A  4EF9 00001BCA            908          JMP     OM000
00001BA0  4EF9 00001BDA            909          JMP     OM001
00001BA6  4EF9 00001BEA            910          JMP     OM010
00001BAC  4EF9 00001BFA            911          JMP     OM011
00001BB2  4EF9 00001BFC            912          JMP     OM100
00001BB8  4EF9 00001C0E            913          JMP     OM101
00001BBE  4EF9 00001C20            914          JMP     OM110
00001BC4  4EF9 00001C32            915          JMP     OM111
00001BCA                           916  
00001BCA                           917  OM000:
00001BCA  43F9 00002397            918          LEA     _B,A1
00001BD0  4EB9 00002160            919          JSR     WRITE_ASCII
00001BD6  4245                     920          CLR     D5
00001BD8  4E75                     921          RTS   
00001BDA                           922  OM001:
00001BDA  43F9 0000239B            923          LEA     _W,A1
00001BE0  4EB9 00002160            924          JSR     WRITE_ASCII
00001BE6  4245                     925          CLR     D5
00001BE8                           926  
00001BE8  4E75                     927          RTS   
00001BEA                           928  OM010:
00001BEA  43F9 0000239F            929          LEA     _L,A1
00001BF0  4EB9 00002160            930          JSR     WRITE_ASCII
00001BF6  4245                     931          CLR     D5
00001BF8                           932  
00001BF8  4E75                     933          RTS   
00001BFA                           934  OM011:
00001BFA  4E75                     935          RTS   
00001BFC                           936  OM100:
00001BFC  43F9 00002397            937          LEA     _B,A1
00001C02  4EB9 00002160            938          JSR     WRITE_ASCII
00001C08  1A3C 0001                939          MOVE.B  #%1,D5
00001C0C                           940  
00001C0C  4E75                     941          RTS   
00001C0E                           942  OM101:
00001C0E  43F9 0000239B            943          LEA     _W,A1
00001C14  4EB9 00002160            944          JSR     WRITE_ASCII
00001C1A  1A3C 0001                945          MOVE.B  #%1,D5
00001C1E                           946  
00001C1E  4E75                     947          RTS   
00001C20                           948  OM110:
00001C20  43F9 0000239F            949          LEA     _L,A1
00001C26  4EB9 00002160            950          JSR     WRITE_ASCII
00001C2C  1A3C 0001                951          MOVE.B  #%1,D5
00001C30                           952  
00001C30  4E75                     953          RTS   
00001C32                           954  OM111:
00001C32  4E75                     955          RTS   
00001C34                           956   
00001C34                           957          
00001C34                           958  
00001C34                           959  
00001C34                           960  ******** JUMP TABLE FOR EA MODES *********
00001C34                           961  EA_MODE:
00001C34  4EF9 00001C64            962          JMP     EA000
00001C3A  4EF9 00001C7C            963          JMP     EA001
00001C40  4EF9 00001C94            964          JMP     EA010
00001C46  4EF9 00001CB8            965          JMP     EA011
00001C4C  4EF9 00001CDC            966          JMP     EA100
00001C52  4EF9 00001D00            967          JMP     EA101
00001C58  4EF9 00001D02            968          JMP     EA110
00001C5E  4EF9 00001D04            969          JMP     EA111
00001C64                           970  
00001C64                           971  EA000:
00001C64  43F9 00002426            972          LEA     _DR,A1 
00001C6A  4EB9 00002160            973          JSR     WRITE_ASCII
00001C70  43F9 00001D50            974          LEA     EA_REG,A1
00001C76  4EB1 3000                975          JSR     (A1,D3)
00001C7A  4E75                     976          RTS     
00001C7C                           977  EA001:
00001C7C  43F9 00002428            978          LEA     _AR,A1 
00001C82  4EB9 00002160            979          JSR     WRITE_ASCII
00001C88  43F9 00001D50            980          LEA     EA_REG,A1
00001C8E  4EB1 3000                981          JSR     (A1,D3)
00001C92  4E75                     982          RTS     
00001C94                           983  EA010:
00001C94  43F9 0000242A            984          LEA     _IND_AR1,A1 
00001C9A  4EB9 00002160            985          JSR     WRITE_ASCII
00001CA0  43F9 00001D50            986          LEA     EA_REG,A1
00001CA6  4EB1 3000                987          JSR     (A1,D3)
00001CAA  43F9 0000242D            988          LEA     _IND_AR2,A1
00001CB0  4EB9 00002160            989          JSR     WRITE_ASCII
00001CB6  4E75                     990          RTS     
00001CB8                           991      
00001CB8                           992  EA011:
00001CB8  43F9 0000242F            993          LEA     _AR_POST1,A1 
00001CBE  4EB9 00002160            994          JSR     WRITE_ASCII
00001CC4  43F9 00001D50            995          LEA     EA_REG,A1
00001CCA  4EB1 3000                996          JSR     (A1,D3)
00001CCE  43F9 00002432            997          LEA     _AR_POST2,A1
00001CD4  4EB9 00002160            998          JSR     WRITE_ASCII
00001CDA  4E75                     999          RTS
00001CDC                          1000       
00001CDC                          1001      
00001CDC                          1002  EA100:
00001CDC  43F9 00002435           1003          LEA     _AR_PRE1,A1 
00001CE2  4EB9 00002160           1004          JSR     WRITE_ASCII
00001CE8  43F9 00001D50           1005          LEA     EA_REG,A1
00001CEE  4EB1 3000               1006          JSR     (A1,D3)
00001CF2  43F9 00002439           1007          LEA     _AR_PRE2,A1
00001CF8  4EB9 00002160           1008          JSR     WRITE_ASCII
00001CFE  4E75                    1009          RTS   
00001D00                          1010  
00001D00  4E75                    1011  EA101:  RTS
00001D02                          1012  
00001D02  4E75                    1013  EA110:  RTS
00001D04                          1014  
00001D04                          1015  EA111:      
00001D04  86FC 0006               1016          DIVU    #6,D3   * divide register num by 6 to undo jmp table multiplication
00001D08                          1017          
00001D08  B67C 0000               1018          CMP #0,D3   * if reg 0 load word from mem
00001D0C  6600 0016               1019          BNE EA111_R1
00001D10  43F9 0000243B           1020          LEA _ABS,A1
00001D16  4EB9 00002160           1021          JSR WRITE_ASCII     * write $ to buffer
00001D1C  4EB9 00001F3C           1022          JSR NEXT_MEM_WORD_TO_BUF
00001D22  4E75                    1023          RTS
00001D24                          1024  EA111_R1:
00001D24  B67C 0001               1025          CMP #1,D3   * if reg 1 load long from mem
00001D28  6600 0016               1026          BNE EA111_R4
00001D2C  43F9 0000243B           1027          LEA _ABS,A1
00001D32  4EB9 00002160           1028          JSR WRITE_ASCII     * write $ to buffer
00001D38  4EB9 00001F52           1029          JSR NEXT_MEM_LONG_TO_BUF
00001D3E  4E75                    1030          RTS
00001D40                          1031  EA111_R4:       
00001D40  B67C 0004               1032          CMP #%100,D3  * if reg 4 load immediate value
00001D44                          1033          * will need to know instruction size to propperly grab this
00001D44  6600 0008               1034          BNE EA_MODE_DONE    * EA error if not equal to one of the valid modes
00001D48  4EB9 00001EEE           1035          JSR ADD_IMMEDIATE_TO_BUF
00001D4E                          1036  EA_MODE_DONE:
00001D4E  4E75                    1037          RTS
00001D50                          1038          
00001D50                          1039  
00001D50                          1040  ********* JUMP TABLE FOR REGISTERS ******
00001D50                          1041  EA_REG:
00001D50  4EF9 00001D80           1042          JMP     REG000
00001D56  4EF9 00001D8E           1043          JMP     REG001
00001D5C  4EF9 00001D9C           1044          JMP     REG010
00001D62  4EF9 00001DAA           1045          JMP     REG011
00001D68  4EF9 00001DB8           1046          JMP     REG100
00001D6E  4EF9 00001DC6           1047          JMP     REG101
00001D74  4EF9 00001DD4           1048          JMP     REG110
00001D7A  4EF9 00001DE2           1049          JMP     REG111
00001D80                          1050  
00001D80                          1051  REG000:
00001D80  43F9 0000243F           1052          LEA     _ZERO,A1 
00001D86  4EB9 00002160           1053          JSR     WRITE_ASCII
00001D8C  4E75                    1054          RTS   
00001D8E                          1055  REG001:
00001D8E  43F9 00002441           1056          LEA     _ONE,A1 
00001D94  4EB9 00002160           1057          JSR     WRITE_ASCII
00001D9A  4E75                    1058          RTS   
00001D9C                          1059  REG010:
00001D9C  43F9 00002443           1060          LEA     _TWO,A1 
00001DA2  4EB9 00002160           1061          JSR     WRITE_ASCII
00001DA8  4E75                    1062          RTS   
00001DAA                          1063  REG011:
00001DAA  43F9 00002445           1064          LEA     _THREE,A1 
00001DB0  4EB9 00002160           1065          JSR     WRITE_ASCII
00001DB6  4E75                    1066          RTS   
00001DB8                          1067  REG100:
00001DB8  43F9 00002447           1068          LEA     _FOUR,A1 
00001DBE  4EB9 00002160           1069          JSR     WRITE_ASCII
00001DC4  4E75                    1070          RTS   
00001DC6                          1071  REG101:
00001DC6  43F9 00002449           1072          LEA     _FIVE,A1 
00001DCC  4EB9 00002160           1073          JSR     WRITE_ASCII
00001DD2  4E75                    1074          RTS   
00001DD4                          1075  REG110:
00001DD4  43F9 0000244B           1076          LEA     _SIX,A1 
00001DDA  4EB9 00002160           1077          JSR     WRITE_ASCII
00001DE0  4E75                    1078          RTS   
00001DE2                          1079  REG111:
00001DE2  43F9 0000244D           1080          LEA     _SEVEN,A1 
00001DE8  4EB9 00002160           1081          JSR     WRITE_ASCII
00001DEE  4E75                    1082          RTS   
00001DF0                          1083    
00001DF0                          1084   
00001DF0                          1085  ***      EA ERRORS      ***
00001DF0                          1086  
00001DF0                          1087  * invalid codes for all instructions
00001DF0                          1088  BASE_EA_ERR_CHK:
00001DF0  48E7 C080               1089          MOVEM.L D0-D1/A0,-(SP)
00001DF4                          1090          * load source modes and registers
00001DF4  1039 000022F3           1091          MOVE.B  SRC_MODE,D0
00001DFA  1239 000022F4           1092          MOVE.B  SRC_REG,D1
00001E00  0C00 0008               1093          CMPI.B  #8,D0
00001E04  6C00 0068               1094          BGE     EA_ERR
00001E08  C0FC 0006               1095          MULU   #6,D0       
00001E0C  41F9 00001E3E           1096          LEA     BASE_EA_ERR_MODES,A0 
00001E12  4EB0 0000               1097          JSR     (A0,D0)
00001E16                          1098  
00001E16                          1099          * load destination modes and registers
00001E16  1039 000022F1           1100          MOVE.B  DEST_MODE,D0
00001E1C  1239 000022F2           1101          MOVE.B  DEST_REG,D1
00001E22  0C00 0008               1102          CMPI.B  #8,D0
00001E26  6C00 0046               1103          BGE     EA_ERR
00001E2A  C0FC 0006               1104          MULU   #6,D0
00001E2E  41F9 00001E3E           1105          LEA     BASE_EA_ERR_MODES,A0 
00001E34  4EB0 0000               1106          JSR     (A0,D0)
00001E38                          1107  
00001E38  4CDF 0103               1108          MOVEM.L (SP)+,D0-D1/A0
00001E3C  4E75                    1109          RTS
00001E3E                          1110  * jmp table to handle base ea errors        
00001E3E                          1111  BASE_EA_ERR_MODES:
00001E3E                          1112          * NOP slide to catch good modes and direct to rts
00001E3E  4E71                    1113          NOP
00001E40  4E71                    1114          NOP
00001E42  4E71                    1115          NOP
00001E44  4E71                    1116          NOP
00001E46  4E71                    1117          NOP
00001E48  4E71                    1118          NOP
00001E4A  4E71                    1119          NOP
00001E4C  4E71                    1120          NOP
00001E4E  4E71                    1121          NOP
00001E50  4E71                    1122          NOP
00001E52  4E71                    1123          NOP
00001E54  4E71                    1124          NOP
00001E56  4E75                    1125          RTS * return on good modes
00001E58  4E71                    1126          NOP * 2 extra words needed for ofset to jmps
00001E5A  4E71                    1127          NOP
00001E5C  4EF9 00001E6E           1128          JMP EA_ERR      * mode (d16,An)      
00001E62  4EF9 00001E6E           1129          JMP EA_ERR      * mode (d8,An,Xn)
00001E68  4EF9 00001E9E           1130          JMP MODE_7_CHK
00001E6E                          1131  
00001E6E                          1132          
00001E6E                          1133  * write error to string buffer and move on to next instruction
00001E6E                          1134  EA_ERR:
00001E6E  48E7 8040               1135          MOVEM.L D0/A1,-(SP)
00001E72  2039 000021F4           1136          MOVE.L  END_OP_CODE_PTR,D0      * load end of opcode pointer
00001E78  0C80 00000000           1137          CMPI.L  #0,D0                   * if ptr is 0 use existing str buf value
00001E7E  6700 0004               1138          BEQ     LOAD_EA_ERR_MSG
00001E82  2840                    1139          MOVEA.L D0,A4                   * reset string buffer pointer to end of opcode neumonic 
00001E84                          1140          * load error message to buffer
00001E84                          1141  LOAD_EA_ERR_MSG:
00001E84  43F9 00002704           1142          LEA     EA_ERR_MSG,A1
00001E8A  4EB9 00002160           1143          JSR     WRITE_ASCII
00001E90  13FC 00FF 000022F5      1144          MOVE.B  #-1,EA_ERR_FLAG
00001E98  4CDF 0201               1145          MOVEM.L (SP)+,D0/A1
00001E9C  4E75                    1146          RTS
00001E9E                          1147  
00001E9E                          1148  * check mode 7 for invalid reg values
00001E9E                          1149  MODE_7_CHK:
00001E9E  48E7 4000               1150          MOVEM.L D1,-(SP)
00001EA2  B23C 0002               1151          CMP.B #%010,D1 * check for (d16,PC) 
00001EA6  67C6                    1152          BEQ   EA_ERR
00001EA8  B23C 0003               1153          CMP.B #%011,D1 * check for (d8,PC,Xn)
00001EAC  67C0                    1154          BEQ   EA_ERR
00001EAE  4CDF 0002               1155          MOVEM.L (SP)+,D1
00001EB2  4E75                    1156          RTS   
00001EB4                          1157  
00001EB4                          1158  * destination adress register and imediate mode are invalid eas
00001EB4                          1159  DEST_AN_IM_INVALID:
00001EB4  48E7 C000               1160          MOVEM.L D0-D1,-(SP)
00001EB8                          1161          * load source modes and registers
00001EB8                          1162    * load destination modes and registers
00001EB8  1039 000022F1           1163          MOVE.B  DEST_MODE,D0
00001EBE  1239 000022F2           1164          MOVE.B  DEST_REG,D1
00001EC4  B03C 0001               1165          CMP.B   #1,D0   * if address register mode error
00001EC8  6600 000A               1166          BNE     AN_IM_01
00001ECC  4EB8 1E6E               1167          JSR     EA_ERR
00001ED0  6000 0016               1168          BRA     AN_IM_02
00001ED4                          1169  AN_IM_01:
00001ED4  B03C 0007               1170          CMP.B   #7,D0    * if immediate data error
00001ED8  6600 000E               1171          BNE     AN_IM_02
00001EDC  B23C 0004               1172          CMP.B   #4,D1
00001EE0  6600 0006               1173          BNE     AN_IM_02
00001EE4  4EB8 1E6E               1174          JSR     EA_ERR     
00001EE8                          1175  AN_IM_02: 
00001EE8  4CDF 0003               1176          MOVEM.L (SP)+,D0-D1
00001EEC  4E75                    1177          RTS
00001EEE                          1178  
00001EEE                          1179  ***       UTILS     ****
00001EEE                          1180  
00001EEE                          1181  ADD_IMMEDIATE_TO_BUF:
00001EEE  48E7 4040               1182          MOVEM.L D1/A1,-(SP)
00001EF2  1239 000022F0           1183          MOVE.B  INST_SZ,D1  * load instruction size
00001EF8  0C01 0001               1184          CMPI.B  #BYTE,D1
00001EFC  6700 000A               1185          BEQ IN_IM_W     * if byte goto word since behavior is the same
00001F00  0C01 0003               1186                  CMPI.B  #WORD,D1
00001F04  6600 001A               1187          BNE CMP_IM_L    * if not equal to word branch compare to long
00001F08                          1188  IN_IM_W:
00001F08  43F9 0000243D           1189          LEA _IMD,A1     * print next mem word as imediate data to buffer
00001F0E  4EB9 00002160           1190          JSR WRITE_ASCII
00001F14  4EB9 00001F3C           1191          JSR NEXT_MEM_WORD_TO_BUF
00001F1A  4CDF 0202               1192          MOVEM.L (SP)+,D1/A1
00001F1E  4E75                    1193          RTS
00001F20                          1194  CMP_IM_L:
00001F20  0C01 0002               1195          CMPI.B  #LONG,D1
00001F24                          1196  *       TODO BNE        EA ERROR
00001F24  43F9 0000243D           1197          LEA _IMD,A1      * print next mem long as imediate data to buffer
00001F2A  4EB9 00002160           1198          JSR WRITE_ASCII
00001F30  4EB9 00001F52           1199          JSR     NEXT_MEM_LONG_TO_BUF
00001F36  4CDF 0202               1200          MOVEM.L (SP)+,D1/A1
00001F3A  4E75                    1201          RTS
00001F3C                          1202  
00001F3C                          1203  * read next word of memory to str_buffer advancing current pointer
00001F3C                          1204  NEXT_MEM_WORD_TO_BUF:
00001F3C  48E7 4400               1205          MOVEM.L D1/D5,-(SP)
00001F40  548D                    1206          ADDA.L  #2,A5   * advance pointer
00001F42  3215                    1207          MOVE.W  (A5),D1 * load next word of memory
00001F44  7A00                    1208          MOVEQ.L #0,D5   * set hex length to word
00001F46  4EB9 0000210E           1209          JSR     WRITE_HEX_TO_ASCII
00001F4C  4CDF 0022               1210          MOVEM.L (SP)+,D1/D5
00001F50  4E75                    1211          RTS
00001F52                          1212          
00001F52                          1213  * read next Long of memory to str_buffer advancing current pointer
00001F52                          1214  NEXT_MEM_LONG_TO_BUF:
00001F52  48E7 4400               1215          MOVEM.L D1/D5,-(SP)
00001F56  548D                    1216          ADDA.L  #2,A5 * advance pointer
00001F58  2215                    1217          MOVE.L  (A5),D1
00001F5A  548D                    1218          ADDA.L  #2,A5 * advance pointer again to account for long
00001F5C  7A20                    1219          MOVEQ.L #32,D5  * set hex length to long
00001F5E  4EB9 0000210E           1220          JSR     WRITE_HEX_TO_ASCII
00001F64  4CDF 0022               1221          MOVEM.L (SP)+,D1/D5
00001F68  4E75                    1222          RTS
00001F6A                          1223  
00001F6A                          1224  * prompts user for choice
00001F6A                          1225  * sets d6 to valid choice
00001F6A                          1226  GET_CHOICE: 
00001F6A  48E7 C040               1227          MOVEM.L   D0/D1/A1,-(SP)
00001F6E                          1228  HC_INT_LP:
00001F6E  4EB9 000021D6           1229          JSR     RESET_BUF_PTR   * move a4 to start of string buffer
00001F74  43F9 000024DF           1230          LEA     CHOICE_PROMPT,A1
00001F7A  4EB9 00002160           1231          JSR     WRITE_ASCII
00001F80  4EB9 000021AE           1232          JSR     TERM_PNT_RST_BUF
00001F86  103C 0004               1233          MOVE.B  #4,D0   * read a number from keyboard into d1
00001F8A  4E4F                    1234          TRAP    #15
00001F8C                          1235  CHOICE_1:
00001F8C  0C41 0001               1236          CMPI    #DISSASEMBLE ,D1
00001F90  6700 0024               1237          BEQ     CHOICE_DNE    
00001F94                          1238  CHOICE_2:
00001F94  0C41 0002               1239          CMPI    #QUIT_PROG,D1
00001F98  6700 001C               1240          BEQ     CHOICE_DNE    
00001F9C                          1241  CHOICE_ERR:
00001F9C  43F9 00002534           1242          LEA     INV_CHOICE,A1
00001FA2  4EB9 00002160           1243          JSR     WRITE_ASCII
00001FA8  4EB9 000021AE           1244          JSR     TERM_PNT_RST_BUF
00001FAE  4EB9 00001FBE           1245          JSR     WAIT_USR_INPUT
00001FB4  60B8                    1246          BRA     HC_INT_LP
00001FB6                          1247          
00001FB6                          1248  CHOICE_DNE:
00001FB6  1C01                    1249          MOVE.B  D1,D6
00001FB8  4CDF 0203               1250          MOVEM.L   (SP)+,D0/D1/A1
00001FBC  4E75                    1251          RTS               
00001FBE                          1252  
00001FBE                          1253  * prompt user to press enter to continue
00001FBE                          1254  WAIT_USR_INPUT:            
00001FBE  48E7 C040               1255          MOVEM.L   D0/D1/A1,-(SP)
00001FC2  43F9 0000254F           1256          LEA     ENT_TO_CONT,A1  * load and print prompt
00001FC8  4EB9 000020FE           1257          JSR     PRINT_A1
00001FCE  7005                    1258          MOVEQ.L #5,D0   * read in a char from keyboard
00001FD0  4E4F                    1259          TRAP    #15
00001FD2  4CDF 0203               1260          MOVEM.L   (SP)+,D0/D1/A1
00001FD6  4E75                    1261          RTS
00001FD8                          1262  
00001FD8                          1263  LOAD_DATA_STR_INTO_BUF: * expects address to be in a5
00001FD8  48E7 4000               1264          MOVEM.L   D1,-(SP)
00001FDC  4EB9 000021D6           1265          JSR     RESET_BUF_PTR
00001FE2  220D                    1266          MOVE.L  A5,D1
00001FE4  7A20                    1267          MOVEQ   #32,D5   * set hex length to long for address
00001FE6  4EB9 0000210E           1268          JSR     WRITE_HEX_TO_ASCII * write memory address to buffer
00001FEC  4EB9 0000218A           1269          JSR     WRITE_TAB_A4    * wrtie a tab
00001FF2  43F9 00002725           1270          LEA     DATA_MSG,A1     * Load template for data
00001FF8  4EB9 00002160           1271          JSR     WRITE_ASCII     * write 'DATA    $' to buffer
00001FFE  3215                    1272          MOVE.W  (A5),D1   * load address contents of memory to d1 for printing
00002000  7A00                    1273          MOVEQ   #0,D5   * set hex length to word for memory contents
00002002  4EB9 0000210E           1274          JSR     WRITE_HEX_TO_ASCII * save to buffer
00002008  4CDF 0002               1275          MOVEM.L   (SP)+,D1
0000200C  4E75                    1276          RTS
0000200E                          1277  
0000200E  103C 0009               1278  DONE    MOVE.B  #9,D0       * Trap task 9 halt simulator
00002012  4E4F                    1279          TRAP    #15
00002014                          1280          
00002014                          1281  * Converts ASCII string containing chars 0-9 and A-F uppercase to hexidecimal number
00002014                          1282  * returns result in D6
00002014                          1283  TO_HEX
00002014  48E7 E060               1284          MOVEM.L   D0-D2/A1-A2,-(SP)   * save state of registers to be changed
00002018  4282                    1285          CLR.L   D2      * clear to hold digit magnitude
0000201A  4286                    1286          CLR.L   D6      * clear to hold result
0000201C  5341                    1287          SUBI    #1,D1    * subtract 1
0000201E  C2FC 0004               1288          MULU    #4,D1   * multiply length by four to get length in binary
00002022                          1289          
00002022                          1290  TO_HEX_INTERNAL:
00002022  1019                    1291          MOVE.B  (A1)+,D0     * Load char at A1 into D0
00002024  6700 001A               1292          BEQ     END_H       * GOTO end if byte is zero (null terminated)
00002028  0C40 0039               1293          CMPI    #$39,D0     * compare char value to 39
0000202C  6F00 0004               1294          BLE     _0_9        * GOTO 0_9 if <= 39
00002030  5F00                    1295  A_F     SUBI.B  #$7,D0      * Subtract 7 from D0) for ASCII A-F
00002032  0200 000F               1296  _0_9    ANDI.B  #$0F,D0     * AND with 00001111 to isolate left most 4 bits, converts to hex
00002036  2400                    1297          MOVE.L  D0,D2        * put hex digit in D2
00002038  E3AA                    1298          LSL.L   D1,D2       * shift hex digit final postion    
0000203A  DC82                    1299          ADD.L   D2,D6       * add to hex result
0000203C  5981                    1300          SUBI.L    #4,D1       * subract one hex digit of bits from remaining length 
0000203E  60E2                    1301          BRA     TO_HEX_INTERNAL   * convert next byte
00002040  4CDF 0607               1302  END_H   MOVEM.L (SP)+,D0-D2/A1-A2
00002044  4E75                    1303          RTS
00002046                          1304  
00002046                          1305  
00002046                          1306  *   input address to hexadecimal saves output at A1
00002046                          1307  IN_ADDR_TO_HEX:
00002046  48E7 0200               1308          MOVEM.L   D6,-(SP)
0000204A  4EB8 2014               1309          JSR     TO_HEX          * else convert to hex
0000204E  2286                    1310          MOVE.L  D6,(A1)
00002050  4CDF 0040               1311          MOVEM.L   (SP)+,D6
00002054  4E75                    1312          RTS
00002056                          1313  
00002056                          1314  * check start and end addresses for errors
00002056                          1315  CHK_ST_E_ADRS: * sets D5 to 1 if an error has ocurred
00002056  48E7 4800               1316          MOVEM.L   D1/D4,-(SP)
0000205A  7A00                    1317          MOVEQ   #0,D5       * clear error flag
0000205C  2439 000021DC           1318          MOVE.L  ST_ADDR,D2  * load start address
00002062  2639 000021E8           1319          MOVE.L  E_ADDR,D3   * load end address
00002068                          1320          
00002068                          1321  LEN_CHK:                    * check address length
00002068  1239 000021FC           1322          MOVE.B  ST_LEN,D1   * load start and end address lengths
0000206E  1839 000021FD           1323          MOVE.B  E_LEN,D4
00002074                          1324          
00002074  0C01 0008               1325          CMPI.B  #8,D1       * check if start addr length is less than or equal to 8
00002078  6F00 000E               1326          BLE     E_LEN_CHK   * check end address if no length error
0000207C  4EB9 000020BC           1327          JSR     PLEN_ERR    * print length error message
00002082  7A01                    1328          MOVEQ   #1,D5       * set error flag
00002084  6000 0012               1329          BRA     ODD_CHK     * skip end length check if start failed
00002088                          1330  E_LEN_CHK:
00002088  0C04 0008               1331          CMPI.B  #8,D4
0000208C  6F00 000A               1332          BLE     ODD_CHK     * if no error skip to odd checking
00002090  4EB9 000020BC           1333          JSR     PLEN_ERR    * print length error message
00002096  7A01                    1334          MOVEQ   #1,D5       * set error flag
00002098                          1335  
00002098                          1336  ODD_CHK:                    * check if start address is odd
00002098  0802 0000               1337          BTST.L  #0,D2       * test start addres LSB to see if even
0000209C  6700 000A               1338          BEQ     S_GT_E
000020A0  4EB9 000020D2           1339          JSR     PODD_ERR    * print odd start address error
000020A6  7A01                    1340          MOVEQ   #1,D5       * set error flag
000020A8                          1341          
000020A8                          1342  S_GT_E:                     * start address greater than or less than end
000020A8  B483                    1343          CMP.L   D3,D2      * check if end is greater than or equal to start
000020AA  6F00 000A               1344          BLE     CHK_SEA_DONE   * skip to end if no error
000020AE  4EB9 000020E8           1345          JSR     PS_GT_ERR   * print start greater than end error
000020B4  7A01                    1346          MOVEQ   #1,D5       * set error flag
000020B6                          1347        
000020B6                          1348  CHK_SEA_DONE:
000020B6  4CDF 0012               1349          MOVEM.L   (SP)+,D1/D4
000020BA  4E75                    1350          RTS             
000020BC                          1351          
000020BC                          1352  *   print address length input error
000020BC                          1353  PLEN_ERR:
000020BC  48E7 0040               1354          MOVEM.L   A1,-(SP) 
000020C0  43F9 00002601           1355          LEA     ADR_LEN_ERR,A1   * load address input error message 
000020C6  4EB9 000020FE           1356          JSR     PRINT_A1
000020CC  4CDF 0200               1357          MOVEM.L   (SP)+,A1
000020D0  4E75                    1358          RTS         
000020D2                          1359  
000020D2                          1360  PODD_ERR: * print start address odd error
000020D2  48E7 0040               1361          MOVEM.L   A1,-(SP) 
000020D6  43F9 00002646           1362          LEA     ADR_ODD_ERR,A1
000020DC  4EB9 000020FE           1363          JSR     PRINT_A1
000020E2  4CDF 0200               1364          MOVEM.L   (SP)+,A1
000020E6  4E75                    1365          RTS
000020E8                          1366  
000020E8                          1367  PS_GT_ERR: * print start address greater than end address error
000020E8  48E7 0040               1368          MOVEM.L   A1,-(SP) 
000020EC  43F9 0000267C           1369          LEA     ADR_S_GT_E,A1
000020F2  4EB9 000020FE           1370          JSR     PRINT_A1
000020F8  4CDF 0200               1371          MOVEM.L   (SP)+,A1
000020FC  4E75                    1372          RTS
000020FE                          1373  
000020FE                          1374   
000020FE                          1375  PRINT_A1:
000020FE  48E7 8000               1376          MOVEM.L   D0,-(SP) * save register state
00002102  103C 000E               1377          MOVE.B  #14,D0   * print A1
00002106  4E4F                    1378          TRAP    #15
00002108  4CDF 0001               1379          MOVEM.L   (SP)+,D0  *  restore register state
0000210C  4E75                    1380          RTS
0000210E                          1381  
0000210E                          1382  ****************************************************
0000210E                          1383  * Subroutines for printing and writing to and from
0000210E                          1384  * the string buffer at A4
0000210E                          1385  ****************************************************        
0000210E                          1386  
0000210E                          1387  * d5 is a flag for hex value length d5==32 long is used
0000210E                          1388  * any other value short is used        
0000210E                          1389  WRITE_HEX_TO_ASCII: * write hex in d1 to a4 as ascii
0000210E                          1390          * may need to add case to handle sign extended shorts
0000210E  48E7 3800               1391          MOVEM.L   D2-D4,-(SP)
00002112  2401                    1392          MOVE.L  D1,D2   * copy input to working temp var
00002114  0C85 00000020           1393          CMPI.L  #32,D5           * if masked value is 0 there is no value in long portion of register for unsigned ints
0000211A  6600 000E               1394          BNE     h_short         * if not 32 hex value is short else long
0000211E                          1395          * setup params for long processing
0000211E  263C F0000000           1396          MOVE.L  #$F0000000,D3   * init mask for isolating first long hex most significand digit
00002124  781C                    1397          MOVE.L  #28,D4          * init shift value for first long hex MSD
00002126  6000 000A               1398          BRA     h_a_loop
0000212A                          1399          
0000212A                          1400  h_short: * setup params for short processing
0000212A  263C 0000F000           1401          MOVE.L  #$F000,D3   * init mask for isolating first short hex most significand digit
00002130  780C                    1402          MOVE.L  #12,D4      * init shift value for first short hex MSD
00002132                          1403          
00002132                          1404  h_a_loop:
00002132  0C84 00000000           1405          CMPI.L  #0,D4   * compare shift value to 0
00002138  6D00 0020               1406          BLT     h_a_dne * done if less than 0
0000213C  2401                    1407          MOVE.L  D1,D2   * copy input to working temp var
0000213E  C483                    1408          AND.L   D3,D2   * isolate digit
00002140  E8AA                    1409          LSR.L   D4,D2   * shift to rightmost position
00002142                          1410          
00002142  0C82 0000000A           1411          CMPI.L  #$A,D2   * compare to A
00002148  6D00 0004               1412          BLT     h_a_low  * if less than A 0-9
0000214C  5E42                    1413          ADDI    #7,D2    * add an additional 7 to A-F     
0000214E                          1414  h_a_low:
0000214E  0642 0030               1415          ADDI    #$30,D2  * add $30 to convert to ascii
00002152  18C2                    1416          MOVE.B  D2,(A4)+ * write digit to pointer location
00002154                          1417          
00002154  E88B                    1418          LSR.L   #4,D3   * shift mask to isolate next hex digit
00002156  5984                    1419          SUBI.L  #4,D4   * subtract shift for next digit
00002158  60D8                    1420          BRA     h_a_loop    * return to loop start
0000215A  4CDF 001C               1421  h_a_dne MOVEM.L   (SP)+,D2-D4
0000215E  4E75                    1422          RTS
00002160                          1423  
00002160                          1424  WRITE_ASCII:    * copies null terminated string from A1 to A4 without null
00002160  48E7 4040               1425          MOVEM.L   D1/A1,-(SP)
00002164                          1426  w_a_loop:
00002164  1219                    1427          MOVE.B  (A1)+,D1    * load value at A1
00002166  6700 0006               1428          BEQ     w_a_done    * if 0(null) is moved copy is done
0000216A  18C1                    1429          MOVE.B  D1,(A4)+    * else copy value to A4
0000216C  60F6                    1430          BRA     w_a_loop
0000216E                          1431  w_a_done:
0000216E  4CDF 0202               1432          MOVEM.L   (SP)+,D1/A1
00002172  4E75                    1433          RTS
00002174                          1434  
00002174                          1435  WRITE_NULL_A4: * used to terminate a string in memory 
00002174  18FC 0000               1436          MOVE.B  #0,(A4)+
00002178  4E75                    1437          RTS
0000217A                          1438          
0000217A                          1439  WRITE_SPC_A4: * writes an ascii space at a4
0000217A  18FC 0020               1440          MOVE.B  #SPACE,(A4)+
0000217E  4E75                    1441          RTS 
00002180                          1442  
00002180                          1443  WRITE_NL_A4: * writes a newline at a4
00002180  18FC 000D               1444          MOVE.B  #CR,(A4)+
00002184  18FC 000A               1445          MOVE.B  #LF,(A4)+
00002188  4E75                    1446          RTS
0000218A                          1447          
0000218A                          1448  WRITE_TAB_A4:
0000218A  18FC 0009               1449          MOVE.B  #TAB,(A4)+
0000218E  4E75                    1450          RTS   
00002190                          1451  
00002190                          1452  * writes current string buffer pointer address to end_op_code_ptr
00002190                          1453  SET_END_OP_CODE_PTR:
00002190  23CC 000021F4           1454          MOVE.L  A4,END_OP_CODE_PTR
00002196  4E75                    1455          RTS
00002198                          1456  
00002198                          1457  NL_TERM_PNT_RST_BUF: * write newline, null then print contents then reset bufffer
00002198  4EB8 2180               1458          JSR     WRITE_NL_A4
0000219C  4EB8 2174               1459          JSR     WRITE_NULL_A4
000021A0  4EB9 000021C0           1460          JSR     PRINT_STR_BUF
000021A6  4EB9 000021D6           1461          JSR     RESET_BUF_PTR
000021AC  4E75                    1462          RTS
000021AE                          1463          
000021AE                          1464  TERM_PNT_RST_BUF: * write null then print contents then reset bufffer pointer
000021AE  4EB8 2174               1465          JSR     WRITE_NULL_A4
000021B2  4EB9 000021C0           1466          JSR     PRINT_STR_BUF
000021B8  4EB9 000021D6           1467          JSR     RESET_BUF_PTR
000021BE  4E75                    1468          RTS
000021C0                          1469          
000021C0                          1470  PRINT_STR_BUF: * prints string buffer contents to console
000021C0  48E7 8040               1471          MOVEM.L   D0/A1,-(SP)
000021C4  43F9 000021FF           1472          LEA     STR_BUF,A1  * load string buffer
000021CA  303C 000E               1473          MOVE    #14,D0       * print contents
000021CE  4E4F                    1474          TRAP    #15
000021D0  4CDF 0201               1475          MOVEM.L   (SP)+,D0/A1
000021D4  4E75                    1476          RTS
000021D6                          1477  
000021D6                          1478  RESET_BUF_PTR:  * sets a4 to start of string buffer
000021D6  387C 21FF               1479          MOVEA   #STR_BUF,A4
000021DA  4E75                    1480          RTS        
000021DC                          1481  
000021DC                          1482  ****    VARS    ****
000021DC                          1483  ST_ADDR DS.L    3   * allocate 3 longs for address ascii input needs 9 bytes to get 8 chars 
000021E8                          1484  E_ADDR  DS.L    3   * and null terminator, allocating 12 bytes to account for this
000021F4                          1485  
000021F4                          1486  END_OP_CODE_PTR:
000021F4= 00000000                1487          DCB.L   1,0 * pointer to end of opcode neumonic in the string buffer, used for ea errors
000021F8                          1488  
000021F8                          1489  CURRENT_ADDR:
000021F8= 00000000                1490          DCB.L   1,0 * BACKUP FOR CURRENT ADDRESS POINTER
000021FC                          1491  
000021FC= 00                      1492  ST_LEN  DCB.B   1,0 * var to track start address length
000021FD= 01 00                   1493  E_LEN   DC.B    1,0 * var to track end address length
000021FF= 00 00 00 00 00 00 ...   1494  STR_BUF DCB.B   241,0  * buffer to hold 240 chars + null terminator. 3 80 char lines
000022F0= 00                      1495  INST_SZ DCB.B   1,0     * used to store instuction size
000022F1                          1496  DEST_MODE:
000022F1= 00                      1497          DCB.B   1,0     * var for destination ea mode
000022F2                          1498  DEST_REG:
000022F2= 00                      1499          DCB.B   1,0     * var to save destination register in
000022F3                          1500  SRC_MODE:
000022F3= 00                      1501          DCB.B   1,0     * var for source ea mode
000022F4                          1502  SRC_REG: 
000022F4= 00                      1503          DCB.B   1,0     * var to save source register in  
000022F5                          1504  EA_ERR_FLAG:
000022F5= 00                      1505          DCB.B   1,0     * var for ea error status
000022F6                          1506           
000022F6                          1507  ****    CONST   ****
000022F6  =0000000D               1508  CR          EQU     $0D     * carraige return          
000022F6  =0000000A               1509  LF          EQU     $0A     * line feed
000022F6  =00000020               1510  SPACE       EQU     $20     * ascii space
000022F6  =00000009               1511  TAB         EQU     $09     * ascii tab character
000022F6  =00000001               1512  DISSASEMBLE EQU     $01     * dissasemble choice number
000022F6  =00000002               1513  QUIT_PROG   EQU     $02     * quit choice number
000022F6  =00000001               1514  BYTE        EQU     %01
000022F6  =00000003               1515  WORD        EQU     %11
000022F6  =00000002               1516  LONG        EQU     %10
000022F6                          1517  
000022F6                          1518  * masks for isolating nibbles with and 0 being least significant nibble
000022F6  =0000F000               1519  Nib3Mask    EQU     $F000 
000022F6  =00000F00               1520  Nib2Mask    EQU     $0F00
000022F6  =000000F0               1521  Nib1Mask    EQU     $00F0
000022F6  =0000000F               1522  Nib0Mask    EQU     $000F
000022F6                          1523  
000022F6  =00000E00               1524  Bit0Mask    EQU     $0E00
000022F6  =000001C0               1525  Bit1Mask    EQU     $01C0
000022F6  =00000038               1526  Bit2Mask    EQU     $0038
000022F6  =00000007               1527  Bit3Mask    EQU     $0007
000022F6                          1528  
000022F6  =000000FF               1529  Byte0Mask   EQU     $00FF
000022F6  =0000FF00               1530  Byte1Mask   EQU     $FF00
000022F6                          1531  
000022F6                          1532  ****    Instructions    ****
000022F6= 4E 4F 54 2E 42 20 00    1533  _NOT_B  DC.B    'NOT.B ',0
000022FD= 4E 4F 54 2E 57 20 00    1534  _NOT_W  DC.B    'NOT.W ',0
00002304= 4E 4F 54 2E 4C 20 00    1535  _NOT_L  DC.B    'NOT.L ',0
0000230B= 4E 4F 50 20 00          1536  _NOP    DC.B    'NOP ',0
00002310= 52 54 53 20 00          1537  _RTS    DC.B    'RTS ',0
00002315= 4D 4F 56 45 4D 2E ...   1538  _MOVEM_W DC.B   'MOVEM.W ',0
0000231E= 4D 4F 56 45 4D 2E ...   1539  _MOVEM_L DC.B   'MOVEM.L ',0
00002327= 4D 4F 56 45 2E 42 ...   1540  _MOVE_B DC.B    'MOVE.B ',0
0000232F= 4D 4F 56 45 2E 4C ...   1541  _MOVE_L DC.B    'MOVE.L ',0
00002337= 4D 4F 56 45 2E 57 ...   1542  _MOVE_W DC.B    'MOVE.W ',0
0000233F= 4D 4F 56 45 41 2E ...   1543  _MOVEA_L DC.B   'MOVEA.L ',0
00002348= 4D 4F 56 45 41 2E ...   1544  _MOVEA_W DC.B   'MOVEA.W ',0
00002351= 4A 53 52 20 00          1545  _JSR    DC.B    'JSR ',0
00002356= 4C 45 41 20 00          1546  _LEA    DC.B    'LEA ',0
0000235B= 41 44 44 51 2E 42 ...   1547  _ADDQ_B DC.B    'ADDQ.B ',0
00002363= 41 44 44 51 2E 57 ...   1548  _ADDQ_W DC.B    'ADDQ.W ',0
0000236B= 41 44 44 51 2E 4C ...   1549  _ADDQ_L DC.B    'ADDQ.L ',0
00002373= 42 52 41 20 00          1550  _BRA    DC.B    'BRA ',0
00002378= 42 45 51 20 00          1551  _BEQ    DC.B    'BEQ ',0
0000237D= 42 47 54 20 00          1552  _BGT    DC.B    'BGT ',0
00002382= 42 4C 45 20 00          1553  _BLE    DC.B    'BLE ',0
00002387= 4D 4F 56 45 51 20 00    1554  _MOVEQ  DC.B    'MOVEQ ',0
0000238E= 44 49 56 55 20 00       1555  _DIVU   DC.B    'DIVU ',0
00002394= 4F 52 00                1556  _OR     DC.B    'OR',0
00002397= 2E 42 20 00             1557  _B   DC.B    '.B ',0
0000239B= 2E 57 20 00             1558  _W   DC.B    '.W ',0
0000239F= 2E 4C 20 00             1559  _L   DC.B    '.L ',0
000023A3= 53 55 42 20 00          1560  _SUB    DC.B    'SUB ',0
000023A8= 4D 55 4C 53 20 00       1561  _MULS   DC.B    'MULS ',0
000023AE= 41 4E 44 20 00          1562  _AND    DC.B    'AND ',0
000023B3= 41 44 44 20 00          1563  _ADD    DC.B    'ADD ',0
000023B8= 41 44 44 41 20 00       1564  _ADDA   DC.B    'ADDA ',0
000023BE= 41 53 4C 20 00          1565  _ASL    DC.B    'ASL ',0
000023C3= 41 53 52 20 00          1566  _ASR    DC.B    'ASR ',0
000023C8= 4C 53 4C 20 00          1567  _LSL    DC.B    'LSL ',0
000023CD= 4C 53 52 20 00          1568  _LSR    DC.B    'LSR ',0
000023D2= 41 53 4C 2E 42 20 00    1569  _ASL_B  DC.B    'ASL.B ',0
000023D9= 41 53 4C 2E 57 20 00    1570  _ASL_W  DC.B    'ASL.W ',0
000023E0= 41 53 4C 2E 4C 20 00    1571  _ASL_L  DC.B    'ASL.L ',0
000023E7= 41 53 52 2E 42 20 00    1572  _ASR_B  DC.B    'ASR.B ',0
000023EE= 41 53 52 2E 57 20 00    1573  _ASR_W  DC.B    'ASR.W ',0
000023F5= 41 53 52 2E 4C 20 00    1574  _ASR_L  DC.B    'ASR.L ',0
000023FC= 4C 53 4C 2E 42 20 00    1575  _LSL_B  DC.B    'LSL.B ',0
00002403= 4C 53 4C 2E 57 20 00    1576  _LSL_W  DC.B    'LSL.W ',0
0000240A= 4C 53 4C 2E 4C 20 00    1577  _LSL_L  DC.B    'LSL.L ',0
00002411= 4C 53 52 2E 42 20 00    1578  _LSR_B  DC.B    'LSR.B ',0
00002418= 4C 53 52 2E 57 20 00    1579  _LSR_W  DC.B    'LSR.W ',0
0000241F= 4C 53 52 2E 4C 20 00    1580  _LSR_L  DC.B    'LSR.L ',0
00002426                          1581  
00002426                          1582  ****    Modes    ****
00002426= 44 00                   1583  _DR             DC.B   'D',0
00002428= 41 00                   1584  _AR             DC.B   'A',0
0000242A= 28 41 00                1585  _IND_AR1        DC.B   '(A',0
0000242D= 29 00                   1586  _IND_AR2        DC.B   ')',0
0000242F= 28 41 00                1587  _AR_POST1       DC.B   '(A',0
00002432= 29 2B 00                1588  _AR_POST2       DC.B   ')+',0
00002435= 2D 28 41 00             1589  _AR_PRE1        DC.B   '-(A',0
00002439= 29 00                   1590  _AR_PRE2        DC.B   ')',0
0000243B= 24 00                   1591  _ABS            DC.B    '$',0
0000243D= 23 00                   1592  _IMD            DC.B    '#',0
0000243F                          1593  
0000243F                          1594  ****    Numbers    ****
0000243F= 30 00                   1595  _ZERO   DC.B    '0',0
00002441= 31 00                   1596  _ONE    DC.B    '1',0
00002443= 32 00                   1597  _TWO    DC.B    '2',0
00002445= 33 00                   1598  _THREE  DC.B    '3',0
00002447= 34 00                   1599  _FOUR   DC.B    '4',0
00002449= 35 00                   1600  _FIVE   DC.B    '5',0
0000244B= 36 00                   1601  _SIX    DC.B    '6',0
0000244D= 37 00                   1602  _SEVEN  DC.B    '7',0
0000244F= 2C 00                   1603  _COMMA  DC.B    ',',0
00002451                          1604  
00002451                          1605  ****    MODE CMP VALUES    ****
00002451  =00000000               1606  cDR             EQU     $0000
00002451  =00000040               1607  cAR             EQU     $0040
00002451  =00000080               1608  cIND_AR         EQU     $0080
00002451  =000000C0               1609  cAR_POST        EQU     $00C0
00002451  =00000100               1610  cAR_PRE         EQU     $0100
00002451  =000001C0               1611  cABS            EQU     $01C0
00002451                          1612  
00002451                          1613  ****    MESSAGES    ****
00002451                          1614  
00002451= 2A 2A 2A 2A 2A 2A ...   1615  WELCOME     DC.B    '*********************************************',CR,LF
00002480= 2A 20 57 65 6C 63 ...   1616              DC.B    '* Welcome to EASY 68K Disasembler by Nibble *',CR,LF
000024AF= 2A 2A 2A 2A 2A 2A ...   1617              DC.B    '*********************************************',CR,LF,0
000024DF                          1618              
000024DF                          1619  CHOICE_PROMPT:
000024DF= 45 6E 74 65 72 20 ...   1620              DC.B    'Enter a number to make a choice:',CR,LF
00002501= 31 3A 20 44 69 73 ...   1621              DC.B    '1: Dissasemble an Address Range',CR,LF
00002522= 32 3A 20 45 78 69 ...   1622              DC.B    '2: Exit Program',CR,LF,0
00002534                          1623         
00002534= 45 52 52 4F 52 3A ...   1624  INV_CHOICE  DC.B    'ERROR: INVALID selection',CR,LF,0
0000254F                          1625  
0000254F= 0D 0A 50 72 65 73 ...   1626  ENT_TO_CONT DC.B    CR,LF,'Press enter to continue...',CR,LF,0
0000256E                          1627  
0000256E= 0D 0A 45 6E 74 65 ...   1628  ST_A_MSG    DC.B    CR,LF,'Enter an address range in hexidecimal to be dissasembled',CR,LF * start address message
000025AA= 56 61 6C 69 64 20 ...   1629              DC.B    'Valid address chars: 0-1 A-F case insensitive',CR,LF  
000025D9= 45 6E 74 65 72 20 ...   1630              DC.B    'Enter start address:',0    
000025EE                          1631              
000025EE= 45 6E 74 65 72 20 ...   1632  E_A_MSG     DC.B    'Enter end address:',0    * end address message
00002601                          1633  
00002601= 0D 0A 45 52 52 4F ...   1634  ADR_LEN_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-8 hexidecimal digits long',CR,LF,0    * address input error message
00002646                          1635  
00002646= 0D 0A 45 52 52 4F ...   1636  ADR_ODD_ERR DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must be even',CR,LF,0  * odd input address error message
0000267C                          1637              
0000267C= 0D 0A 45 52 52 4F ...   1638  ADR_S_GT_E  DC.B    CR,LF,'ERROR INVALID ADDRESS: Start address must come before end address',CR,LF,0 * start greater than end address error msg
000026C2                          1639  
000026C2= 0D 0A 45 52 52 4F ...   1640  HEX_ERR     DC.B    CR,LF,'ERROR INVALID ADDRESS: Input must be 0-1 A-F case insensitive',CR,LF,0
00002704                          1641  
00002704= 45 52 52 4F 52 3A ...   1642  EA_ERR_MSG  DC.B    'ERROR: INVALID EFFECTIVE ADDRESS',0      * error message for invalid eas
00002725                          1643  
00002725= 44 41 54 41 20 20 ...   1644  DATA_MSG    DC.B    'DATA   $',0
0000272E                          1645  
0000272E= 43 4F 4E 56 45 52 ...   1646  TEST_MSG    DC.B    'CONVERTED ADDRESS IS: ',0  * test message for printing start and end addresses
00002745                          1647              
00002745                          1648              END     INIT        * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ADDQ_               1454
ADD_IMMEDIATE_TO_BUF  1EEE
ADR_LEN_ERR         2601
ADR_ODD_ERR         2646
ADR_S_GT_E          267C
AN_IM_01            1ED4
AN_IM_02            1EE8
ASL_ASR_MEM         16BC
ASL_ASR_REG         177E
A_F                 2030
BASE_EA_ERR_CHK     1DF0
BASE_EA_ERR_MODES   1E3E
BIT0MASK            E00
BIT1MASK            1C0
BIT2MASK            38
BIT3MASK            7
BYTE                1
BYTE0MASK           FF
BYTE1MASK           FF00
CABS                1C0
CAR                 40
CAR_POST            C0
CAR_PRE             100
CDR                 0
CHK_LFT_NIB         1108
CHK_SEA_DONE        20B6
CHK_ST_E_ADRS       2056
CHOICE_1            1F8C
CHOICE_2            1F94
CHOICE_DNE          1FB6
CHOICE_ERR          1F9C
CHOICE_PROMPT       24DF
CIND_AR             80
CMP_IM_L            1F20
CR                  D
CURRENT_ADDR        21F8
DATA_MSG            2725
DECODE_DONE         1174
DEST_AN_IM_INVALID  1EB4
DEST_MODE           22F1
DEST_REG            22F2
DISSASEMBLE         1
DIVU_EA             1A2C
DONE                200E
D_TO_EA             1B2C
EA000               1C64
EA001               1C7C
EA010               1C94
EA011               1CB8
EA100               1CDC
EA101               1D00
EA110               1D02
EA111               1D04
EA111_R1            1D24
EA111_R4            1D40
EA_ERR              1E6E
EA_ERR_FLAG         22F5
EA_ERR_MSG          2704
EA_MODE             1C34
EA_MODE_DONE        1D4E
EA_REG              1D50
EA_TO_D             1ABE
END_H               2040
END_OP_CODE_PTR     21F4
ENT_TO_CONT         254F
E_ADDR              21E8
E_A_MSG             25EE
E_LEN               21FD
E_LEN_CHK           2088
GET_CHOICE          1F6A
HC_INT_LP           1F6E
HEX_ERR             26C2
H_A_DNE             215A
H_A_LOOP            2132
H_A_LOW             214E
H_SHORT             212A
INIT                1000
INPUT_START         1028
INST_SZ             22F0
INV_CHOICE          2534
IN_ADDR_TO_HEX      2046
IN_IM_W             1F08
LEA_EA              19C6
LEN_CHK             2068
LF                  A
LOAD_ADD            1672
LOAD_ADDA           1656
LOAD_ADDQ_B         1472
LOAD_ADDQ_L         14BA
LOAD_ADDQ_W         1496
LOAD_AND            1620
LOAD_ASL_B_REG      1810
LOAD_ASL_L_REG      184C
LOAD_ASL_MEM        16EE
LOAD_ASL_W_REG      182E
LOAD_ASR_B_REG      17B6
LOAD_ASR_L_REG      17F2
LOAD_ASR_MEM        16D2
LOAD_ASR_W_REG      17D4
LOAD_BEQ            151A
LOAD_BGT            1536
LOAD_BLE            154C
LOAD_BRA            1504
LOAD_DATA_STR_INTO_BUF  1FD8
LOAD_DIVU           158E
LOAD_EA_ERR_MSG     1E84
LOAD_JSR            13F6
LOAD_LEA            13D4
LOAD_LSL_B_REG      18FC
LOAD_LSL_L_REG      1938
LOAD_LSL_MEM        173C
LOAD_LSL_W_REG      191A
LOAD_LSR_B_REG      18A2
LOAD_LSR_L_REG      18DE
LOAD_LSR_MEM        1720
LOAD_LSR_W_REG      18C0
LOAD_MOVEA_L        11DC
LOAD_MOVEA_W        124C
LOAD_MOVEM_L        1430
LOAD_MOVEM_W        140C
LOAD_MOVEQ          1562
LOAD_MOVE_B         1196
LOAD_MOVE_L         1206
LOAD_MOVE_W         1276
LOAD_MULS           1604
LOAD_NOP            13A8
LOAD_NOT_B          1302
LOAD_NOT_L          1356
LOAD_NOT_W          132C
LOAD_OR             15B0
LOAD_RTS            13BE
LOAD_SUB            15D2
LONG                2
LSL_LSR_MEM         170A
LSL_LSR_REG         186A
MEMORY_SHIFT        16A6
MODE_7_CHK          1E9E
MOVE_EA             1956
NEXT_MEM_LONG_TO_BUF  1F52
NEXT_MEM_WORD_TO_BUF  1F3C
NIB0MASK            F
NIB1MASK            F0
NIB2MASK            F00
NIB3MASK            F000
NL_TERM_PNT_RST_BUF  2198
NOP_RTS_JSR         1380
NOT_                12E4
NO_EA_ERROR         118C
ODD_CHK             2098
OM000               1BCA
OM001               1BDA
OM010               1BEA
OM011               1BFA
OM100               1BFC
OM101               1C0E
OM110               1C20
OM111               1C32
OPMODE              1B9A
OP_2                11C6
OP_3                1236
OP_4                12A6
OP_6                14DE
OP_8                1578
OP_C                15EE
OP_CODES            10AC
OP_D                163C
OP_DONE             1194
OP_E                168E
OP_ERR              116E
OP_START            10BE
OR_EA               1A96
PLEN_ERR            20BC
PODD_ERR            20D2
PRINT_A1            20FE
PRINT_STR_BUF       21C0
PS_GT_ERR           20E8
QUIT                10A6
QUIT_PROG           2
REG000              1D80
REG001              1D8E
REG010              1D9C
REG011              1DAA
REG100              1DB8
REG101              1DC6
REG110              1DD4
REG111              1DE2
REG_SHIFT           1758
RESET_BUF_PTR       21D6
SET_END_OP_CODE_PTR  2190
SPACE               20
SRC_MODE            22F3
SRC_REG             22F4
START               101A
STR_BUF             21FF
ST_ADDR             21DC
ST_A_MSG            256E
ST_DIS              1096
ST_LEN              21FC
S_GT_E              20A8
TAB                 9
TERM_PNT_RST_BUF    21AE
TEST_MSG            272E
TO_HEX              2014
TO_HEX_INTERNAL     2022
WAIT_USR_INPUT      1FBE
WELCOME             2451
WORD                3
WRITE_ASCII         2160
WRITE_HEX_TO_ASCII  210E
WRITE_NL_A4         2180
WRITE_NULL_A4       2174
WRITE_SPC_A4        217A
WRITE_TAB_A4        218A
W_A_DONE            216E
W_A_LOOP            2164
_0_9                2032
_ABS                243B
_ADD                23B3
_ADDA               23B8
_ADDQ_B             235B
_ADDQ_L             236B
_ADDQ_W             2363
_AND                23AE
_AR                 2428
_AR_POST1           242F
_AR_POST2           2432
_AR_PRE1            2435
_AR_PRE2            2439
_ASL                23BE
_ASL_B              23D2
_ASL_L              23E0
_ASL_W              23D9
_ASR                23C3
_ASR_B              23E7
_ASR_L              23F5
_ASR_W              23EE
_B                  2397
_BEQ                2378
_BGT                237D
_BLE                2382
_BRA                2373
_COMMA              244F
_DIVU               238E
_DR                 2426
_FIVE               2449
_FOUR               2447
_IMD                243D
_IND_AR1            242A
_IND_AR2            242D
_JSR                2351
_L                  239F
_LEA                2356
_LSL                23C8
_LSL_B              23FC
_LSL_L              240A
_LSL_W              2403
_LSR                23CD
_LSR_B              2411
_LSR_L              241F
_LSR_W              2418
_MOVEA_L            233F
_MOVEA_W            2348
_MOVEM_L            231E
_MOVEM_W            2315
_MOVEQ              2387
_MOVE_B             2327
_MOVE_L             232F
_MOVE_W             2337
_MULS               23A8
_NOP                230B
_NOT_B              22F6
_NOT_L              2304
_NOT_W              22FD
_ONE                2441
_OR                 2394
_RTS                2310
_SEVEN              244D
_SIX                244B
_SUB                23A3
_THREE              2445
_TWO                2443
_W                  239B
_ZERO               243F
